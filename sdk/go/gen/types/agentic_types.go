// Code generated by stigmer-codegen. DO NOT EDIT.
// Source: agentic_types.go
// Generated: 2026-01-26T03:24:19+05:30

package types

import (
	"google.golang.org/protobuf/types/known/structpb"
)

// AgentExecutionConfig defines optional execution parameters for agent calls.
//
//	These settings override the agent's default configuration for this specific invocation.
type AgentExecutionConfig struct {
	// LLM model to use for this invocation.  Example: "claude-3-5-sonnet", "gpt-4", "claude-3-opus"  Optional - uses agent's default model if not specified.
	Model string `json:"model,omitempty"`
	// Timeout for agent execution in seconds.  Default: 300 (5 minutes)  Optional.
	Timeout int32 `json:"timeout,omitempty"`
	// Temperature for LLM sampling (0.0 to 1.0).  Lower = more deterministic, Higher = more creative  Default: 0.7  Optional.
	Temperature float32 `json:"temperature,omitempty"`
}

// FromProto converts google.protobuf.Struct to AgentExecutionConfig.
func (c *AgentExecutionConfig) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["model"]; ok {
		c.Model = val.GetStringValue()
	}

	if val, ok := fields["timeout"]; ok {
		c.Timeout = int32(val.GetNumberValue())
	}

	if val, ok := fields["temperature"]; ok {
		c.Temperature = float32(val.GetNumberValue())
	}

	return nil
}

// CatchBlock defines error handling logic.
type CatchBlock struct {
	// Variable name to store the error (optional).  Accessible via ${ .error } in catch tasks.
	As string `json:"as,omitempty"`
	// Tasks to execute when error is caught.
	Do []*WorkflowTask `json:"do,omitempty"`
}

// FromProto converts google.protobuf.Struct to CatchBlock.
func (c *CatchBlock) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["as"]; ok {
		c.As = val.GetStringValue()
	}

	if val, ok := fields["do"]; ok {
		c.Do = make([]*WorkflowTask, 0)
		for _, v := range val.GetListValue().GetValues() {
			item := &WorkflowTask{}
			if err := item.FromProto(v.GetStructValue()); err != nil {
				return err
			}
			c.Do = append(c.Do, item)
		}
	}

	return nil
}

// DockerServer defines an MCP server that runs in a Docker container.
type DockerServer struct {
	// Docker image name and tag.  Example: "ghcr.io/org/mcp-server:latest"
	Image string `json:"image,omitempty"`
	// Container command arguments (optional).  Overrides the default CMD in the Docker image.
	Args []string `json:"args,omitempty"`
	// Environment variable placeholders (same as StdioServer).  Example: {"GITHUB_TOKEN": "${GITHUB_TOKEN}"}
	EnvPlaceholders map[string]string `json:"envPlaceholders,omitempty"`
	// Volume mounts for the container (optional).
	Volumes []*VolumeMount `json:"volumes,omitempty"`
	// Docker network to attach the container to (optional, default: "bridge").
	Network string `json:"network,omitempty"`
	// Port mappings for the container (optional).
	Ports []*PortMapping `json:"ports,omitempty"`
	// Container name (optional, auto-generated if not provided).
	ContainerName string `json:"containerName,omitempty"`
}

// FromProto converts google.protobuf.Struct to DockerServer.
func (c *DockerServer) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["image"]; ok {
		c.Image = val.GetStringValue()
	}

	if val, ok := fields["args"]; ok {
		c.Args = make([]string, 0)
		for _, v := range val.GetListValue().GetValues() {
			c.Args = append(c.Args, v.GetStringValue())
		}
	}

	if val, ok := fields["envPlaceholders"]; ok {
		c.EnvPlaceholders = make(map[string]string)
		for k, v := range val.GetStructValue().GetFields() {
			c.EnvPlaceholders[k] = v.GetStringValue()
		}
	}

	if val, ok := fields["volumes"]; ok {
		c.Volumes = make([]*VolumeMount, 0)
		for _, v := range val.GetListValue().GetValues() {
			item := &VolumeMount{}
			if err := item.FromProto(v.GetStructValue()); err != nil {
				return err
			}
			c.Volumes = append(c.Volumes, item)
		}
	}

	if val, ok := fields["network"]; ok {
		c.Network = val.GetStringValue()
	}

	if val, ok := fields["ports"]; ok {
		c.Ports = make([]*PortMapping, 0)
		for _, v := range val.GetListValue().GetValues() {
			item := &PortMapping{}
			if err := item.FromProto(v.GetStructValue()); err != nil {
				return err
			}
			c.Ports = append(c.Ports, item)
		}
	}

	if val, ok := fields["containerName"]; ok {
		c.ContainerName = val.GetStringValue()
	}

	return nil
}

// EnvironmentSpec defines a collection of configuration and secrets.
//
//	Created before AgentInstance or WorkflowInstance, referenced during instance creation.
type EnvironmentSpec struct {
	// Human-readable description of this environment.  Example: "Production AWS credentials for deployment"
	Description string `json:"description,omitempty"`
	// Key-value pairs containing both configuration and secrets.  Each value includes a flag indicating whether it's a secret.  Example: {"AWS_REGION": {value: "us-west-2", is_secret: false},            "AWS_ACCESS_KEY_ID": {value: "AKIA...", is_secret: true}}
	Data map[string]*EnvironmentValue `json:"data,omitempty"`
}

// FromProto converts google.protobuf.Struct to EnvironmentSpec.
func (c *EnvironmentSpec) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["description"]; ok {
		c.Description = val.GetStringValue()
	}

	if val, ok := fields["data"]; ok {
		c.Data = make(map[string]*EnvironmentValue)
		for k, v := range val.GetStructValue().GetFields() {
			item := &EnvironmentValue{}
			if err := item.FromProto(v.GetStructValue()); err != nil {
				return err
			}
			c.Data[k] = item
		}
	}

	return nil
}

// EnvironmentValue represents a single configuration or secret value.
type EnvironmentValue struct {
	// The actual value.  - If is_secret=true: This value is encrypted at rest and redacted in logs  - If is_secret=false: This value is stored as plaintext
	Value string `json:"value,omitempty"`
	// Whether this value should be treated as a secret.  When true:  - Value is encrypted at rest  - Value is redacted in logs  - Value requires special permissions to read  When false:  - Value is stored as plaintext  - Value is visible in audit logs
	IsSecret bool `json:"isSecret,omitempty"`
	// Optional description for documentation.  Example: "AWS access key for S3 bucket access"
	Description string `json:"description,omitempty"`
}

// FromProto converts google.protobuf.Struct to EnvironmentValue.
func (c *EnvironmentValue) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["value"]; ok {
		c.Value = val.GetStringValue()
	}

	if val, ok := fields["isSecret"]; ok {
		c.IsSecret = val.GetBoolValue()
	}

	if val, ok := fields["description"]; ok {
		c.Description = val.GetStringValue()
	}

	return nil
}

// Export defines how to save task output to context.
//
//	Maps to the `export:` block in Zigflow DSL.
//
//	Examples:
//	- {"as": "${.}"} - Export entire output
//	- {"as": "${.fieldName}"} - Export specific field
//	- {"as": "${$context + {taskName: .}}"} - Merge into context
type Export struct {
	// Expression defining how to export output.  Uses Zigflow expression syntax: ${...}
	As string `json:"as,omitempty"`
}

// FromProto converts google.protobuf.Struct to Export.
func (c *Export) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["as"]; ok {
		c.As = val.GetStringValue()
	}

	return nil
}

// FlowControl defines which task executes next.
//
//	Maps to the `then:` directive in Zigflow DSL.
//
//	Examples:
//	- {"then": "nextTaskName"} - Jump to specific task
//	- {"then": "end"} - Terminate workflow
//	- Not set - Continue to next task in sequence (default)
type FlowControl struct {
	// Target task name or "end" to terminate workflow.
	Then string `json:"then,omitempty"`
}

// FromProto converts google.protobuf.Struct to FlowControl.
func (c *FlowControl) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["then"]; ok {
		c.Then = val.GetStringValue()
	}

	return nil
}

// ForkBranch defines a single branch in parallel execution.
type ForkBranch struct {
	// Branch name/identifier.
	Name string `json:"name,omitempty"`
	// Tasks to execute in this branch.
	Do []*WorkflowTask `json:"do,omitempty"`
}

// FromProto converts google.protobuf.Struct to ForkBranch.
func (c *ForkBranch) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["name"]; ok {
		c.Name = val.GetStringValue()
	}

	if val, ok := fields["do"]; ok {
		c.Do = make([]*WorkflowTask, 0)
		for _, v := range val.GetListValue().GetValues() {
			item := &WorkflowTask{}
			if err := item.FromProto(v.GetStructValue()); err != nil {
				return err
			}
			c.Do = append(c.Do, item)
		}
	}

	return nil
}

// HttpEndpoint defines the HTTP endpoint to call.
type HttpEndpoint struct {
	// URI of the endpoint.  Can contain expressions: "https://api.example.com/${.resource}"
	Uri interface{} `json:"uri,omitempty"`
}

// FromProto converts google.protobuf.Struct to HttpEndpoint.
func (c *HttpEndpoint) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["uri"]; ok {
		c.Uri = val.GetStringValue()
	}

	return nil
}

// HttpServer defines an MCP server accessible via HTTP + SSE.
//
//	Used for remote/managed MCP services.
type HttpServer struct {
	// Base URL of the MCP server.  Example: "http://localhost:3000/mcp" or "https://mcp.example.com"
	Url string `json:"url,omitempty"`
	// HTTP headers for authentication/configuration.  Example: {"Authorization": "Bearer ${API_TOKEN}"}  Placeholders like ${API_TOKEN} reference secrets in ConfigSchema.
	Headers map[string]string `json:"headers,omitempty"`
	// Query parameters for the MCP endpoint (optional).  Example: {"version": "v1", "region": "${AWS_REGION}"}
	QueryParams map[string]string `json:"queryParams,omitempty"`
	// Timeout for HTTP requests in seconds (default: 30).
	TimeoutSeconds int32 `json:"timeoutSeconds,omitempty"`
}

// FromProto converts google.protobuf.Struct to HttpServer.
func (c *HttpServer) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["url"]; ok {
		c.Url = val.GetStringValue()
	}

	if val, ok := fields["headers"]; ok {
		c.Headers = make(map[string]string)
		for k, v := range val.GetStructValue().GetFields() {
			c.Headers[k] = v.GetStringValue()
		}
	}

	if val, ok := fields["queryParams"]; ok {
		c.QueryParams = make(map[string]string)
		for k, v := range val.GetStructValue().GetFields() {
			c.QueryParams[k] = v.GetStringValue()
		}
	}

	if val, ok := fields["timeoutSeconds"]; ok {
		c.TimeoutSeconds = int32(val.GetNumberValue())
	}

	return nil
}

// ListenTo defines what signals to listen for.
type ListenTo struct {
	// Listening mode:  - "one": Wait for any one signal  - "all": Wait for all signals
	Mode string `json:"mode,omitempty"`
	// Signals to listen for.
	Signals []*SignalSpec `json:"signals,omitempty"`
}

// FromProto converts google.protobuf.Struct to ListenTo.
func (c *ListenTo) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["mode"]; ok {
		c.Mode = val.GetStringValue()
	}

	if val, ok := fields["signals"]; ok {
		c.Signals = make([]*SignalSpec, 0)
		for _, v := range val.GetListValue().GetValues() {
			item := &SignalSpec{}
			if err := item.FromProto(v.GetStructValue()); err != nil {
				return err
			}
			c.Signals = append(c.Signals, item)
		}
	}

	return nil
}

// McpServerDefinition defines an MCP server without configuration.
//
//	Configuration with secrets happens at AgentInstance level.
//
//	Supports three types of MCP servers:
//	1. **stdio**: Subprocess-based servers (most common)
//	   - Example: npx @modelcontextprotocol/server-github
//	   - Use when: Running Node.js, Python, or other CLI-based MCP servers
//	   - Communication: stdin/stdout
//
//	2. **http**: HTTP + SSE servers (for remote/managed services)
//	   - Example: https://mcp.example.com/github
//	   - Use when: Connecting to remote MCP services, managed infrastructure
//	   - Communication: HTTP requests + Server-Sent Events
//
//	3. **docker**: Containerized MCP servers
//	   - Example: ghcr.io/org/custom-mcp:latest
//	   - Use when: Running custom/isolated MCP servers, need volume mounts
//	   - Communication: stdio (via Docker exec) or HTTP (via port mapping)
type McpServerDefinition struct {
	// Name of the MCP server (e.g., "github", "aws", "slack").
	Name string `json:"name,omitempty"`
	// stdio-based server (subprocess with stdin/stdout communication).
	Stdio *StdioServer `json:"stdio,omitempty"`
	// HTTP-based server (HTTP + Server-Sent Events communication).
	Http *HttpServer `json:"http,omitempty"`
	// Docker-based server (containerized MCP server).
	Docker *DockerServer `json:"docker,omitempty"`
	// Tool names to enable from this server (empty = all tools).
	EnabledTools []string `json:"enabledTools,omitempty"`
}

// FromProto converts google.protobuf.Struct to McpServerDefinition.
func (c *McpServerDefinition) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["name"]; ok {
		c.Name = val.GetStringValue()
	}

	if val, ok := fields["stdio"]; ok {
		c.Stdio = &StdioServer{}
		if err := c.Stdio.FromProto(val.GetStructValue()); err != nil {
			return err
		}
	}

	if val, ok := fields["http"]; ok {
		c.Http = &HttpServer{}
		if err := c.Http.FromProto(val.GetStructValue()); err != nil {
			return err
		}
	}

	if val, ok := fields["docker"]; ok {
		c.Docker = &DockerServer{}
		if err := c.Docker.FromProto(val.GetStructValue()); err != nil {
			return err
		}
	}

	if val, ok := fields["enabledTools"]; ok {
		c.EnabledTools = make([]string, 0)
		for _, v := range val.GetListValue().GetValues() {
			c.EnabledTools = append(c.EnabledTools, v.GetStringValue())
		}
	}

	return nil
}

// McpToolSelection defines which tools from an MCP server are enabled.
type McpToolSelection struct {
	// Tool names to enable from the MCP server (empty = all tools).
	EnabledTools []string `json:"enabledTools,omitempty"`
}

// FromProto converts google.protobuf.Struct to McpToolSelection.
func (c *McpToolSelection) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["enabledTools"]; ok {
		c.EnabledTools = make([]string, 0)
		for _, v := range val.GetListValue().GetValues() {
			c.EnabledTools = append(c.EnabledTools, v.GetStringValue())
		}
	}

	return nil
}

// PortMapping defines a Docker port mapping.
type PortMapping struct {
	// Host port to bind to.
	HostPort int32 `json:"hostPort,omitempty"`
	// Container port to expose.
	ContainerPort int32 `json:"containerPort,omitempty"`
	// Protocol (default: "tcp"). Can be "tcp" or "udp".
	Protocol string `json:"protocol,omitempty"`
}

// FromProto converts google.protobuf.Struct to PortMapping.
func (c *PortMapping) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["hostPort"]; ok {
		c.HostPort = int32(val.GetNumberValue())
	}

	if val, ok := fields["containerPort"]; ok {
		c.ContainerPort = int32(val.GetNumberValue())
	}

	if val, ok := fields["protocol"]; ok {
		c.Protocol = val.GetStringValue()
	}

	return nil
}

// SignalSpec defines a signal/event to listen for.
type SignalSpec struct {
	// Signal identifier.
	Id string `json:"id,omitempty"`
	// Signal type:  - "signal": Temporal signal  - "query": Temporal query  - "update": Temporal update
	Type string `json:"type,omitempty"`
}

// FromProto converts google.protobuf.Struct to SignalSpec.
func (c *SignalSpec) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["id"]; ok {
		c.Id = val.GetStringValue()
	}

	if val, ok := fields["type"]; ok {
		c.Type = val.GetStringValue()
	}

	return nil
}

// StdioServer defines an MCP server that runs as a subprocess.
//
//	Communication happens via stdin/stdout (most common type).
type StdioServer struct {
	// Command to run the MCP server (e.g., "npx", "python", "node").
	Command string `json:"command,omitempty"`
	// Command arguments (e.g., ["-y", "@modelcontextprotocol/server-github"]).
	Args []string `json:"args,omitempty"`
	// Environment variable placeholders (e.g., {"GITHUB_TOKEN": "${GITHUB_TOKEN}"}).  Actual values provided at AgentInstance level via ConfigSchema.  The key is the env var name that the MCP server expects.  The value is a placeholder reference like "${GITHUB_TOKEN}" that maps to  a secret or env_var defined in the Agent's ConfigSchema.
	EnvPlaceholders map[string]string `json:"envPlaceholders,omitempty"`
	// Working directory for the process (optional).
	WorkingDir string `json:"workingDir,omitempty"`
}

// FromProto converts google.protobuf.Struct to StdioServer.
func (c *StdioServer) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["command"]; ok {
		c.Command = val.GetStringValue()
	}

	if val, ok := fields["args"]; ok {
		c.Args = make([]string, 0)
		for _, v := range val.GetListValue().GetValues() {
			c.Args = append(c.Args, v.GetStringValue())
		}
	}

	if val, ok := fields["envPlaceholders"]; ok {
		c.EnvPlaceholders = make(map[string]string)
		for k, v := range val.GetStructValue().GetFields() {
			c.EnvPlaceholders[k] = v.GetStringValue()
		}
	}

	if val, ok := fields["workingDir"]; ok {
		c.WorkingDir = val.GetStringValue()
	}

	return nil
}

// SubAgent represents a sub-agent that can be delegated to.
type SubAgent struct {
	// Inline sub-agent definition.
	InlineSpec *InlineSubAgentSpec `json:"inlineSpec,omitempty"`
	// Reference to existing Agent resource.
	AgentInstanceRefs *ApiResourceReference `json:"agentInstanceRefs,omitempty"`
}

// FromProto converts google.protobuf.Struct to SubAgent.
func (c *SubAgent) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["inlineSpec"]; ok {
		c.InlineSpec = &InlineSubAgentSpec{}
		if err := c.InlineSpec.FromProto(val.GetStructValue()); err != nil {
			return err
		}
	}

	if val, ok := fields["agentInstanceRefs"]; ok {
		c.AgentInstanceRefs = &ApiResourceReference{}
		if err := c.AgentInstanceRefs.FromProto(val.GetStructValue()); err != nil {
			return err
		}
	}

	return nil
}

// SwitchCase defines a single case in a switch statement.
type SwitchCase struct {
	// Case name/identifier.
	Name string `json:"name,omitempty"`
	// Condition expression (optional).  If empty, this is the default case.  Example: "${ $context.value > 5 }"
	When string `json:"when,omitempty"`
	// Target task name to execute if condition matches.
	Then string `json:"then,omitempty"`
}

// FromProto converts google.protobuf.Struct to SwitchCase.
func (c *SwitchCase) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["name"]; ok {
		c.Name = val.GetStringValue()
	}

	if val, ok := fields["when"]; ok {
		c.When = val.GetStringValue()
	}

	if val, ok := fields["then"]; ok {
		c.Then = val.GetStringValue()
	}

	return nil
}

// VolumeMount defines a Docker volume mount.
type VolumeMount struct {
	// Host path to mount.
	HostPath string `json:"hostPath,omitempty"`
	// Container path where the volume is mounted.
	ContainerPath string `json:"containerPath,omitempty"`
	// Whether the mount is read-only (default: false).
	ReadOnly bool `json:"readOnly,omitempty"`
}

// FromProto converts google.protobuf.Struct to VolumeMount.
func (c *VolumeMount) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["hostPath"]; ok {
		c.HostPath = val.GetStringValue()
	}

	if val, ok := fields["containerPath"]; ok {
		c.ContainerPath = val.GetStringValue()
	}

	if val, ok := fields["readOnly"]; ok {
		c.ReadOnly = val.GetBoolValue()
	}

	return nil
}

// WorkflowTask represents a single task in the workflow.
//
//	Uses the "kind + Struct" pattern (like CloudResource in Planton Cloud):
//	- `kind` determines the task type (SET, HTTP_CALL, SWITCH, etc.)
//	- `task_config` contains task-specific configuration as dynamic JSON
//	- Backend unmarshals `task_config` to the appropriate Go struct based on `kind`
//
//	Example (HTTP Call):
//	{
//	  "name": "fetchData",
//	  "kind": "HTTP_CALL",
//	  "task_config": {
//	    "method": "GET",
//	    "endpoint": {"uri": "https://api.example.com/data"},
//	    "headers": {"Authorization": "Bearer ${TOKEN}"}
//	  },
//	  "export": {"as": "${.}"},
//	  "flow": {"then": "processData"}
//	}
type WorkflowTask struct {
	// Task name/identifier (must be unique within workflow).
	Name string `json:"name,omitempty"`
	// Task type (determines how to interpret task_config).
	Kind string `json:"kind,omitempty"`
	// Task-specific configuration (dynamic typed).  Structure depends on `kind` value.   Backend unmarshals this Struct to the appropriate proto message:  - SET: ai.stigmer.agentic.workflow.v1.tasks.SetTaskConfig  - HTTP_CALL: ai.stigmer.agentic.workflow.v1.tasks.HttpCallTaskConfig  - GRPC_CALL: ai.stigmer.agentic.workflow.v1.tasks.GrpcCallTaskConfig  - SWITCH: ai.stigmer.agentic.workflow.v1.tasks.SwitchTaskConfig  - FOR: ai.stigmer.agentic.workflow.v1.tasks.ForTaskConfig  - FORK: ai.stigmer.agentic.workflow.v1.tasks.ForkTaskConfig  - TRY: ai.stigmer.agentic.workflow.v1.tasks.TryTaskConfig  - LISTEN: ai.stigmer.agentic.workflow.v1.tasks.ListenTaskConfig  - WAIT: ai.stigmer.agentic.workflow.v1.tasks.WaitTaskConfig  - CALL_ACTIVITY: ai.stigmer.agentic.workflow.v1.tasks.CallActivityTaskConfig  - RAISE: ai.stigmer.agentic.workflow.v1.tasks.RaiseTaskConfig  - RUN: ai.stigmer.agentic.workflow.v1.tasks.RunTaskConfig   See: apis/ai/stigmer/agentic/workflow/v1/tasks/*.proto for detailed schemas.
	TaskConfig map[string]interface{} `json:"taskConfig,omitempty"`
	// Export configuration (how to save task output to context).  Optional - if not set, output is not saved.
	Export *Export `json:"export,omitempty"`
	// Flow control (which task executes next).  Optional - if not set, continues to next task in sequence.
	Flow *FlowControl `json:"flow,omitempty"`
}

// FromProto converts google.protobuf.Struct to WorkflowTask.
func (c *WorkflowTask) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["name"]; ok {
		c.Name = val.GetStringValue()
	}

	if val, ok := fields["kind"]; ok {
		c.Kind = val.GetStringValue()
	}

	if val, ok := fields["taskConfig"]; ok {
		c.TaskConfig = val.GetStructValue().AsMap()
	}

	if val, ok := fields["export"]; ok {
		c.Export = &Export{}
		if err := c.Export.FromProto(val.GetStructValue()); err != nil {
			return err
		}
	}

	if val, ok := fields["flow"]; ok {
		c.Flow = &FlowControl{}
		if err := c.Flow.FromProto(val.GetStructValue()); err != nil {
			return err
		}
	}

	return nil
}

// InlineSubAgentSpec defines a sub-agent inline without creating a separate resource.
type InlineSubAgentSpec struct {
	// Name of the sub-agent.
	Name string `json:"name,omitempty"`
	// Description of what this sub-agent does.
	Description string `json:"description,omitempty"`
	// Behavior instructions for this sub-agent.
	Instructions string `json:"instructions,omitempty"`
	// MCP server names this sub-agent can use (references McpServerDefinition.name).
	McpServers []string `json:"mcpServers,omitempty"`
	// Tool selections for each MCP server.
	McpToolSelections map[string]*McpToolSelection `json:"mcpToolSelections,omitempty"`
	// References to Skill resources for this sub-agent's knowledge.
	SkillRefs []*ApiResourceReference `json:"skillRefs,omitempty"`
}

// FromProto converts google.protobuf.Struct to InlineSubAgentSpec.
func (c *InlineSubAgentSpec) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["name"]; ok {
		c.Name = val.GetStringValue()
	}

	if val, ok := fields["description"]; ok {
		c.Description = val.GetStringValue()
	}

	if val, ok := fields["instructions"]; ok {
		c.Instructions = val.GetStringValue()
	}

	if val, ok := fields["mcpServers"]; ok {
		c.McpServers = make([]string, 0)
		for _, v := range val.GetListValue().GetValues() {
			c.McpServers = append(c.McpServers, v.GetStringValue())
		}
	}

	if val, ok := fields["mcpToolSelections"]; ok {
		c.McpToolSelections = make(map[string]*McpToolSelection)
		for k, v := range val.GetStructValue().GetFields() {
			item := &McpToolSelection{}
			if err := item.FromProto(v.GetStructValue()); err != nil {
				return err
			}
			c.McpToolSelections[k] = item
		}
	}

	if val, ok := fields["skillRefs"]; ok {
		c.SkillRefs = make([]*ApiResourceReference, 0)
		for _, v := range val.GetListValue().GetValues() {
			item := &ApiResourceReference{}
			if err := item.FromProto(v.GetStructValue()); err != nil {
				return err
			}
			c.SkillRefs = append(c.SkillRefs, item)
		}
	}

	return nil
}

// Configuration that can be applied at execution time.
type ExecutionConfig struct {
	// The model to use for this execution.  Example: "claude-sonnet-4-20250514"
	ModelName string `json:"modelName,omitempty"`
}

// FromProto converts google.protobuf.Struct to ExecutionConfig.
func (c *ExecutionConfig) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["modelName"]; ok {
		c.ModelName = val.GetStringValue()
	}

	return nil
}

// ExecutionValue represents a single runtime configuration or secret value.
type ExecutionValue struct {
	// The actual value.  - If is_secret=true: This value is encrypted at rest and redacted in logs  - If is_secret=false: This value is stored as plaintext
	Value string `json:"value,omitempty"`
	// Whether this value should be treated as a secret.  When true:  - Value is encrypted at rest  - Value is redacted in logs  - Value is deleted when execution completes  When false:  - Value is stored as plaintext  - Value is visible in audit logs
	IsSecret bool `json:"isSecret,omitempty"`
}

// FromProto converts google.protobuf.Struct to ExecutionValue.
func (c *ExecutionValue) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["value"]; ok {
		c.Value = val.GetStringValue()
	}

	if val, ok := fields["isSecret"]; ok {
		c.IsSecret = val.GetBoolValue()
	}

	return nil
}

// WorkflowDocument contains workflow metadata.
//
//	Maps to the `document:` block in Zigflow DSL YAML.
type WorkflowDocument struct {
	// DSL version (semver). Must be "1.0.0" for current Zigflow.
	Dsl string `json:"dsl,omitempty"`
	// Workflow namespace (organization/categorization).
	Namespace string `json:"namespace,omitempty"`
	// Workflow name (unique identifier within namespace).
	Name string `json:"name,omitempty"`
	// Workflow version (semver).
	Version string `json:"version,omitempty"`
	// Human-readable description.
	Description string `json:"description,omitempty"`
}

// FromProto converts google.protobuf.Struct to WorkflowDocument.
func (c *WorkflowDocument) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["dsl"]; ok {
		c.Dsl = val.GetStringValue()
	}

	if val, ok := fields["namespace"]; ok {
		c.Namespace = val.GetStringValue()
	}

	if val, ok := fields["name"]; ok {
		c.Name = val.GetStringValue()
	}

	if val, ok := fields["version"]; ok {
		c.Version = val.GetStringValue()
	}

	if val, ok := fields["description"]; ok {
		c.Description = val.GetStringValue()
	}

	return nil
}
