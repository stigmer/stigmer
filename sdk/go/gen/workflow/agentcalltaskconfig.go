// Code generated by stigmer-codegen. DO NOT EDIT.
// Source: agentcalltaskconfig.go
// Generated: 2026-01-26T04:50:42+05:30

package workflow

import (
	"encoding/json"
	"github.com/stigmer/stigmer/sdk/go/gen/types"
	"google.golang.org/protobuf/types/known/structpb"
)

// AgentCallTaskConfig defines the configuration for AGENT_CALL tasks.
//
//	This enables workflows to invoke AI agents as tasks, delegating complex
//	operations to specialized agents with their own skills and context.
//
//	The agent is referenced by slug (name) and scope. The runtime resolves
//	the (slug, scope) pair to an actual agent:
//	1. If scope is PLATFORM: look only in platform-scoped agents (public)
//	2. If scope is ORGANIZATION: look only in org agents
//	3. If scope is UNSPECIFIED: defaults to ORGANIZATION scope
//	4. Before explicit scope lookup, check manifest (current deployment)
//
//	The workflow's execution context (environment variables, secrets) is
//	passed to the agent invocation, allowing agents to access workflow state.
//
//	YAML Example:
//	  - analyze:
//	      call: agent
//	      with:
//	        agent: "code-reviewer"
//	        scope: organization
//	        message: "Review this code: ${ $context.fetchCode.body }"
//	        env:
//	          GITHUB_TOKEN: "${ .secrets.GH_TOKEN }"
//	        config:
//	          model: "claude-3-5-sonnet"
//	          timeout: 300
//
//	Reference: design doc at stigmer/_cursor/add-agent-config-to-workflow.md
type AgentCallTaskConfig struct {
	// Agent slug/name to invoke (e.g., "code-reviewer", "data-analyst").  The runtime resolves this to an actual agent considering the scope.  Required field.
	Agent string `json:"agent,omitempty"`
	// Agent owner scope (platform or organization).  Determines where to resolve the agent slug.  Default (UNSPECIFIED) = ORGANIZATION scope.  Optional (defaults to organization if not specified).
	Scope string `json:"scope,omitempty"`
	// Instructions/prompt to send to the agent.  Supports interpolation of workflow variables using JQ expressions.  Example: "Analyze this code: ${ $context.fetchCode.body }"  Required field.
	Message interface{} `json:"message,omitempty"`
	// Runtime environment variables to pass to the agent.  Values can be literal strings or JQ expressions that reference  workflow context or secrets.  Example: {"GITHUB_TOKEN": "${ .secrets.GH_TOKEN }"}  Optional.
	Env map[string]string `json:"env,omitempty"`
	// Execution configuration for the agent invocation.  Optional - defaults are applied if not specified.
	Config *types.AgentExecutionConfig `json:"config,omitempty"`
}

// IsTaskConfig marks AgentCallTaskConfig as a TaskConfig implementation.
func (c *AgentCallTaskConfig) IsTaskConfig() {}

// ToProto converts AgentCallTaskConfig to google.protobuf.Struct for proto marshaling.
func (c *AgentCallTaskConfig) ToProto() (*structpb.Struct, error) {
	data := make(map[string]interface{})

	if !isEmpty(c.Agent) {
		data["agent"] = c.Agent
	}
	if !isEmpty(c.Scope) {
		data["scope"] = c.Scope
	}
	if !isEmpty(c.Message) {
		// Smart conversion: accepts string or TaskFieldRef
		data["message"] = coerceToString(c.Message)
	}
	if !isEmpty(c.Env) {
		data["env"] = c.Env
	}
	if !isEmpty(c.Config) && c.Config != nil {
		// Convert Config to proto-compatible format using JSON marshaling
		jsonBytes, err := json.Marshal(c.Config)
		if err != nil {
			return nil, err
		}
		var ConfigMap map[string]interface{}
		if err := json.Unmarshal(jsonBytes, &ConfigMap); err != nil {
			return nil, err
		}
		// Apply smart conversion to expression fields within the message
		data["config"] = ConfigMap
	}

	return structpb.NewStruct(data)
}

// FromProto converts google.protobuf.Struct to AgentCallTaskConfig.
func (c *AgentCallTaskConfig) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["agent"]; ok {
		c.Agent = val.GetStringValue()
	}

	if val, ok := fields["scope"]; ok {
		c.Scope = val.GetStringValue()
	}

	if val, ok := fields["message"]; ok {
		c.Message = val.GetStringValue()
	}

	if val, ok := fields["env"]; ok {
		c.Env = make(map[string]string)
		for k, v := range val.GetStructValue().GetFields() {
			c.Env[k] = v.GetStringValue()
		}
	}

	if val, ok := fields["config"]; ok {
		c.Config = &types.AgentExecutionConfig{}
		if err := c.Config.FromProto(val.GetStructValue()); err != nil {
			return err
		}
	}

	return nil
}
