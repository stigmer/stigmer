# Rule: Implement Go SDK Features (action)

**Purpose**: Implement and enhance Go SDK features for Stigmer workflows, agents, and skills. This rule provides a deterministic workflow for handling proto changes, regenerating code, implementing functional options, and writing comprehensive tests.

**Usage**: Invoke this rule when:
- Proto definitions change and SDK needs updates
- Adding new task types, agent features, or skill configurations
- Implementing functional options for SDK types
- Writing tests for SDK functionality

---

## Core Workflow: Proto Changes → SDK Updates

The SDK uses code generation to eliminate manual proto conversion. When protos change, follow this deterministic workflow:

### Step 1: Proto Changes
When proto definitions are added or modified:

```bash
# Proto files location
apis/ai/stigmer/agentic/workflow/v1/tasks/*.proto
apis/ai/stigmer/agentic/agent/v1/*.proto
apis/ai/stigmer/agentic/skill/v1/*.proto
```

### Step 2: Regenerate Code
Run the code generator to update SDK types:

```bash
# Generate proto stubs (if proto changed)
make protos

# Regenerate SDK code from protos
cd tools/codegen
go run . \
  --proto-path ../../apis/ai/stigmer/agentic \
  --output-dir ../../sdk/go

# The generator creates:
# - Config structs (e.g., SetTaskConfig, HttpCallTaskConfig)
# - Builder functions (functional options)
# - ToProto/FromProto conversion methods
# - Validation helpers
```

### Step 3: Implement Functional Options
For new features, add functional options to make SDK ergonomic:

```go
// sdk/go/workflow/options.go

// Timeout sets the timeout for HTTP tasks (in seconds)
func Timeout(seconds int32) TaskOption {
    return func(cfg map[string]interface{}) {
        cfg["timeout"] = seconds
    }
}

// Header adds an HTTP header
func Header(key, value string) TaskOption {
    return func(cfg map[string]interface{}) {
        if _, exists := cfg["headers"]; !exists {
            cfg["headers"] = make(map[string]string)
        }
        cfg["headers"].(map[string]string)[key] = value
    }
}
```

### Step 4: Write Tests
Create comprehensive tests for new functionality:

**A. Integration Tests** (proto roundtrip):
```go
// sdk/go/workflow/proto_integration_test.go

func TestWorkflow_ProtoRoundtrip_HttpGetTask(t *testing.T) {
    ctx := stigmer.NewContext()
    wf, _ := workflow.New(ctx,
        workflow.WithNamespace("test"),
        workflow.WithName("http-test"),
        workflow.WithVersion("1.0.0"),
    )
    
    // Create task with new options
    wf.HttpGet("fetch", "https://api.example.com",
        workflow.Header("Authorization", "Bearer token"),
        workflow.Timeout(30),
    )
    
    // Convert to proto
    proto, err := wf.ToProto()
    require.NoError(t, err)
    
    // Verify proto structure
    assert.NotNil(t, proto)
    assert.Equal(t, "workflow.stigmer.ai/v1", proto.ApiVersion)
    assert.Len(t, proto.Spec.Tasks, 1)
    
    // Verify task config contains options
    task := proto.Spec.Tasks[0]
    assert.Equal(t, "HTTP_CALL", task.Kind)
    cfg := task.Config.AsMap()
    assert.Equal(t, "GET", cfg["method"])
    assert.Equal(t, "https://api.example.com", cfg["uri"])
    assert.Equal(t, int32(30), cfg["timeout"])
}
```

**B. Unit Tests** (functional options):
```go
// sdk/go/workflow/options_test.go

func TestTimeout_SetsCorrectValue(t *testing.T) {
    cfg := make(map[string]interface{})
    opt := Timeout(30)
    opt(cfg)
    
    assert.Equal(t, int32(30), cfg["timeout"])
}

func TestHeader_AddsMultipleHeaders(t *testing.T) {
    cfg := make(map[string]interface{})
    
    Header("Auth", "Bearer token")(cfg)
    Header("Content-Type", "application/json")(cfg)
    
    headers := cfg["headers"].(map[string]string)
    assert.Equal(t, "Bearer token", headers["Auth"])
    assert.Equal(t, "application/json", headers["Content-Type"])
}
```

**C. End-to-End Tests**:
```go
// test/e2e/workflow_http_call_test.go

func TestWorkflow_HttpCall_EndToEnd(t *testing.T) {
    err := stigmer.Run(func(ctx *stigmer.Context) error {
        wf, _ := workflow.New(ctx,
            workflow.WithNamespace("e2e"),
            workflow.WithName("http-e2e"),
            workflow.WithVersion("1.0.0"),
        )
        
        wf.HttpGet("fetch", "https://httpbin.org/get",
            workflow.Timeout(30),
        )
        
        return nil
    })
    
    require.NoError(t, err)
    
    // Verify proto files generated
    assert.FileExists(t, ".stigmer/workflow-0.pb")
    assert.FileExists(t, ".stigmer/dependencies.json")
}
```

---

## Code Generation Principles

Following learnings from the SDK code generators project:

### 1. Generated Code Quality
Generated code should be indistinguishable from hand-written code:
- ✅ Proper formatting (`gofmt`, `goimports`)
- ✅ Idiomatic Go patterns
- ✅ Meaningful variable names
- ✅ Complete documentation comments
- ✅ Proper error handling

### 2. Schema is Source of Truth
- Schema defines field types, validations, documentation
- Generator reads schema, applies templates
- No "special case" hardcoding in generator
- Add to schema if behavior needs to differ

### 3. Fail Fast with Clear Errors
- Validate schema before generation
- Provide clear error messages with location
- Exit with non-zero code on errors
- Don't generate partial/broken code

### 4. Test Generated Code
- Run `go build` on generated packages
- Run `go test` on generated packages
- Include unit tests for generated helpers
- Test proto round-trip (SDK → proto → SDK)

---

## Common Patterns

### Pattern 1: Functional Options
```go
// Define option type
type TaskOption func(cfg map[string]interface{})

// Implement options
func Timeout(seconds int32) TaskOption {
    return func(cfg map[string]interface{}) {
        cfg["timeout"] = seconds
    }
}

func Retries(count int32) TaskOption {
    return func(cfg map[string]interface{}) {
        cfg["retries"] = count
    }
}

// Apply options in task builder
func (w *Workflow) HttpGet(taskID, uri string, opts ...TaskOption) *Task {
    cfg := map[string]interface{}{
        "method": "GET",
        "uri":    uri,
    }
    
    // Apply all options
    for _, opt := range opts {
        opt(cfg)
    }
    
    return w.addTask(taskID, "HTTP_CALL", cfg)
}
```

### Pattern 2: Proto Conversion
```go
// ToProto converts SDK type to proto
func (w *Workflow) ToProto() (*workflowpb.Workflow, error) {
    proto := &workflowpb.Workflow{
        ApiVersion: "workflow.stigmer.ai/v1",
        Kind:       "Workflow",
        Metadata: &apiresource.ApiResourceMetadata{
            Name:        w.name,
            Slug:        w.slug,
            Annotations: SDKAnnotations(), // Track SDK version
        },
        Spec: &workflowpb.WorkflowSpec{
            Namespace: w.namespace,
            Name:      w.name,
            Version:   w.version,
        },
    }
    
    // Convert tasks
    for _, task := range w.tasks {
        taskProto, err := taskToProto(task)
        if err != nil {
            return nil, fmt.Errorf("converting task %s: %w", task.ID, err)
        }
        proto.Spec.Tasks = append(proto.Spec.Tasks, taskProto)
    }
    
    return proto, nil
}

// Convert map[string]interface{} to structpb.Struct
func taskConfigToStruct(cfg map[string]interface{}) (*structpb.Struct, error) {
    // CRITICAL: structpb requires map[string]interface{} types
    // Convert nested maps to interface{} if needed
    return structpb.NewStruct(cfg)
}
```

### Pattern 3: SDK Annotations
```go
// Track SDK metadata in proto annotations
func SDKAnnotations() map[string]string {
    return map[string]string{
        "sdk.stigmer.ai/language": "go",
        "sdk.stigmer.ai/version":  "0.1.0",
        "sdk.stigmer.ai/timestamp": time.Now().Format(time.RFC3339),
    }
}
```

### Pattern 4: Dependency Tracking
```go
// Context automatically tracks dependencies
type Context struct {
    agents       []*agent.Agent
    skills       []*skill.Skill
    workflows    []*workflow.Workflow
    dependencies map[string][]string // Resource ID → Dependencies
}

// Register resources with dependencies
func (c *Context) RegisterWorkflow(wf *workflow.Workflow) {
    c.workflows = append(c.workflows, wf)
    
    // Extract agent dependencies from AGENT_CALL tasks
    for _, task := range wf.Tasks() {
        if task.Kind == "AGENT_CALL" {
            agentSlug := task.Config["agent_slug"].(string)
            c.dependencies[wf.Slug()] = append(
                c.dependencies[wf.Slug()], 
                "agent:"+agentSlug,
            )
        }
    }
}
```

---

## Testing Strategy

### Test Levels

**1. Unit Tests** (~50% of tests)
- Functional options
- Helper functions
- Validation logic
- Edge cases

**2. Integration Tests** (~30% of tests)
- ToProto() conversions
- Proto roundtrip (SDK → proto → SDK)
- All task types
- All configuration options

**3. End-to-End Tests** (~20% of tests)
- Complete examples
- SDK → CLI flow
- File generation
- Dependency ordering

### Test Coverage Goals
- Core SDK functionality: 85%+
- Proto conversion: 95%+
- Critical paths: 100%

---

## Common Commands

```bash
# Regenerate code from protos
make protos
cd tools/codegen && go run .

# Run all tests
go test ./sdk/go/...

# Run specific package tests
go test ./sdk/go/workflow/...

# Run with coverage
go test -cover ./sdk/go/...

# Run integration tests only
go test -tags=integration ./sdk/go/...

# Run end-to-end tests
go test ./test/e2e/...

# Format code
go fmt ./sdk/go/...

# Run linter
golangci-lint run ./sdk/go/...

# Build all packages
go build ./sdk/go/...
```

---

## Troubleshooting

### Issue 1: Generated Code Doesn't Compile

**Symptoms**: `go build` fails after code generation

**Fix**:
1. Check schema is valid JSON
2. Run `go fmt` on generated code
3. Verify imports are correct
4. Regenerate with `--force` flag

### Issue 2: Proto Conversion Fails

**Symptoms**: `proto: invalid type` or `cannot convert` errors

**Fix**:
```go
// ❌ WRONG - structpb doesn't accept map[string]string
cfg := map[string]string{"key": "value"}
structpb.NewStruct(cfg) // ERROR!

// ✅ CORRECT - Convert to map[string]interface{}
cfg := make(map[string]interface{})
cfg["key"] = "value"
structpb.NewStruct(cfg) // OK
```

### Issue 3: Context Deadlock

**Symptoms**: Tests hang with "all goroutines are asleep - deadlock!"

**Fix**:
```go
// ❌ WRONG - Calling public method while holding lock
func (c *Context) Synthesize() error {
    c.mu.Lock()
    defer c.mu.Unlock()
    deps := c.Dependencies() // Tries to acquire lock again!
}

// ✅ CORRECT - Direct field access
func (c *Context) Synthesize() error {
    c.mu.Lock()
    defer c.mu.Unlock()
    deps := c.dependencies // Direct access
}
```

### Issue 4: Missing Dependencies

**Symptoms**: Import errors or undefined types

**Fix**:
```bash
# Update go.mod with proto dependencies
go get github.com/stigmer/stigmer/apis/...
go mod tidy

# Regenerate proto stubs if needed
make protos
```

---

## File Locations

**Proto Definitions** (source):
- `apis/ai/stigmer/agentic/workflow/v1/`
- `apis/ai/stigmer/agentic/agent/v1/`
- `apis/ai/stigmer/agentic/skill/v1/`

**SDK Packages**:
- `sdk/go/workflow/` - Workflow SDK
- `sdk/go/agent/` - Agent SDK
- `sdk/go/skill/` - Skill SDK
- `sdk/go/stigmer/` - Context and orchestration

**Tests**:
- `sdk/go/workflow/proto_integration_test.go` - Workflow tests
- `sdk/go/agent/proto_integration_test.go` - Agent tests
- `sdk/go/skill/proto_integration_test.go` - Skill tests
- `test/e2e/` - End-to-end tests

**Examples**:
- `sdk/go/examples/` - SDK usage examples

**Code Generator**:
- `tools/codegen/` - Code generation tool
- `tools/codegen/templates/` - Generation templates

---

## Adding New Task Types (Example)

**Scenario**: Add a new `DATABASE_QUERY` task type

### Step 1: Define Proto
```protobuf
// apis/ai/stigmer/agentic/workflow/v1/tasks/database.proto

message DatabaseQueryTaskConfig {
  // Connection string
  string connection = 1 [(buf.validate.field).required = true];
  
  // SQL query to execute
  string query = 2 [(buf.validate.field).required = true];
  
  // Timeout in seconds
  int32 timeout = 3 [(buf.validate.field).int32.gte = 1];
}
```

### Step 2: Regenerate Code
```bash
make protos
cd tools/codegen && go run .
```

This generates:
- `sdk/go/workflow/gen/database_query_config.go`
- ToProto/FromProto methods
- Validation helpers

### Step 3: Add Functional Options
```go
// sdk/go/workflow/options.go

func Connection(conn string) TaskOption {
    return func(cfg map[string]interface{}) {
        cfg["connection"] = conn
    }
}

func Query(sql string) TaskOption {
    return func(cfg map[string]interface{}) {
        cfg["query"] = sql
    }
}
```

### Step 4: Add Builder Method
```go
// sdk/go/workflow/workflow.go

func (w *Workflow) DatabaseQuery(taskID, query string, opts ...TaskOption) *Task {
    cfg := map[string]interface{}{
        "query": query,
    }
    
    for _, opt := range opts {
        opt(cfg)
    }
    
    return w.addTask(taskID, "DATABASE_QUERY", cfg)
}
```

### Step 5: Write Tests
```go
// sdk/go/workflow/proto_integration_test.go

func TestWorkflow_DatabaseQuery(t *testing.T) {
    ctx := stigmer.NewContext()
    wf, _ := workflow.New(ctx,
        workflow.WithNamespace("test"),
        workflow.WithName("db-test"),
        workflow.WithVersion("1.0.0"),
    )
    
    wf.DatabaseQuery("query-users",
        "SELECT * FROM users WHERE active = true",
        workflow.Connection("postgres://localhost/mydb"),
        workflow.Timeout(30),
    )
    
    proto, err := wf.ToProto()
    require.NoError(t, err)
    
    task := proto.Spec.Tasks[0]
    assert.Equal(t, "DATABASE_QUERY", task.Kind)
    
    cfg := task.Config.AsMap()
    assert.Equal(t, "SELECT * FROM users WHERE active = true", cfg["query"])
    assert.Equal(t, "postgres://localhost/mydb", cfg["connection"])
    assert.Equal(t, int32(30), cfg["timeout"])
}
```

### Step 6: Create Example
```go
// sdk/go/examples/20_database_query.go

func main() {
    stigmer.Run(func(ctx *stigmer.Context) error {
        wf, _ := workflow.New(ctx,
            workflow.WithNamespace("examples"),
            workflow.WithName("database-example"),
            workflow.WithVersion("1.0.0"),
        )
        
        wf.DatabaseQuery("fetch-users",
            "SELECT * FROM users WHERE status = 'active'",
            workflow.Connection("postgres://localhost/mydb"),
            workflow.Timeout(30),
        )
        
        return nil
    })
}
```

**Total Time**: ~5 minutes (down from 2-3 hours manual implementation)

---

## Quality Checklist

Before completing any SDK feature implementation:

- [ ] Proto definitions updated and validated (`buf lint`)
- [ ] Code regenerated from protos (`make protos && go run tools/codegen`)
- [ ] Generated code compiles (`go build ./sdk/go/...`)
- [ ] Functional options implemented for new features
- [ ] Unit tests written and passing
- [ ] Integration tests written and passing
- [ ] End-to-end test added to `test/e2e/`
- [ ] Example created in `sdk/go/examples/`
- [ ] Code formatted (`go fmt ./sdk/go/...`)
- [ ] Linter passes (`golangci-lint run`)
- [ ] Documentation updated (if public API changed)

---

## Related Documentation

- **Project Summary**: `/Users/suresh/scm/github.com/stigmer/stigmer/_projects/2026-01/20260122.01.sdk-code-generators-go/FINAL-SUMMARY.md`
- **Code Generation Principles**: `/Users/suresh/scm/github.com/stigmer/stigmer/_projects/2026-01/20260122.01.sdk-code-generators-go/coding-guidelines/go-codegen-principles.md`
- **Design Decisions**: `/Users/suresh/scm/github.com/stigmer/stigmer/_projects/2026-01/20260122.01.sdk-code-generators-go/design-decisions/`

---

## Success Metrics

**Before Code Generation**:
- Adding new task type: ~2-3 hours
- Proto conversion bugs: Frequent
- Test coverage: ~60%
- Manual code: 500+ lines per task type

**After Code Generation**:
- Adding new task type: ~5 minutes
- Proto conversion bugs: None (generated)
- Test coverage: 85%+
- Manual code: 0 lines (all generated)

---

*This rule is production-ready and based on real implementation experience from the SDK code generators project.*
