# Rule: Improve Go SDK Rule (action)

## Purpose

Autonomously improve the `implement-go-sdk-features.mdc` rule based on lessons learned during Go SDK implementation. Updates patterns, adds missing documentation, and refines guidance to prevent future issues.

## When This Rule is Invoked

This rule is automatically triggered by `@complete-stigmer-work.mdc` when:
1. Go SDK files were modified (`sdk/go/**/*.go`)
2. New Go patterns were discovered or issues were solved
3. Genuine learning occurred (not routine work)

It can also be manually invoked when:
- You notice the rule has incorrect/outdated Go guidance
- You want to add a new Go pattern discovered during work
- Documentation is missing for a common Go task

## What This Rule Does

1. **Analyzes Recent Work**: Reviews conversation history and git changes
2. **Identifies Go-Specific Learnings**: Extracts new patterns, fixes, or discoveries
3. **Updates Documentation**: 
   - Adds entries to `docs/learning-log.md`
   - Updates reference docs in `docs/`
   - Refines main rule guidance
4. **Validates Changes**: Ensures updates are accurate and helpful

## How AI Should Execute This

### Step 1: Identify Go SDK Learnings

Review the conversation for:

**Proto Converter Issues**:
- Nil pointer dereference errors
- Proto getter usage (GetSpec(), GetInstructions())
- Repeated field handling with append()
- Nested message construction
- Missing nil checks

**Agent Configuration Issues**:
- Builder pattern problems
- Functional options implementation
- Validation errors in constructors
- Struct composition issues
- Exported vs unexported fields

**Error Handling Issues**:
- Error wrapping with fmt.Errorf("%w", err)
- Custom error type creation
- Sentinel errors
- Error propagation patterns

**Testing Issues**:
- Table-driven test patterns
- Test fixture setup
- Mock interfaces
- Proto roundtrip tests
- Coverage patterns

**Go Module Issues**:
- go.mod dependency problems
- Proto stub imports
- Module path setup
- Version constraints

**Interface Design Issues**:
- Interface composition
- Method receiver choices (pointer vs value)
- Interface satisfaction patterns

### Step 2: Categorize Go Learnings

For each learning, determine:

- **Topic**: Proto Converters, Agent Config, Error Handling, Testing, etc.
- **Type**: Bug fix, new pattern, best practice, gotcha
- **Go-Specific**: Is this Go-specific or applies to other languages?
- **Impact**: Critical (blocks work), Important (saves time), Nice-to-have
- **Reusability**: Applies broadly vs specific case

### Step 3: Update Documentation

#### Update `docs/learning-log.md`

Add entry under appropriate topic:

```markdown
## [Topic Name]

### [Date] - [Brief Title]

**Problem**: [What went wrong or what needed solving in Go]

**Root Cause**: [Why it happened - Go-specific context]

**Solution**: [How to fix it - Go code]

**Prevention**: [How to avoid in future]

**Cross-Reference**: [Link to Python SDK if applicable]

**Example**:
```go
// Go code example showing the fix
```
```

#### Update Reference Docs

If the learning affects a specific doc:
- Create or update `docs/proto-converters.md` for proto issues
- Create or update `docs/agent-configuration.md` for config issues
- Create or update `docs/testing-patterns.md` for test issues
- Create or update `docs/error-handling.md` for error issues

#### Update Main Rule

If patterns in `implement-stigmer-sdk-features.mdc` need refinement:
- Add new Go examples to relevant sections
- Update troubleshooting guide
- Add common pitfalls
- Refine implementation guidance

### Step 4: Add Cross-Language References

If the learning has a Python SDK equivalent:

```markdown
**Cross-Language Note**: 
- **Python approach**: Uses `.extend()` for repeated fields (see Python SDK learning log)
- **Go approach**: Uses `append()` with slice expansion
- **Conceptual similarity**: Both add items to repeated proto fields
- **Syntax difference**: Go uses variadic syntax with `...`
```

### Step 5: Validate Changes

Before finalizing:

- [ ] Learning is genuinely new (not already documented)
- [ ] Solution is tested and works in Go
- [ ] Documentation is clear and actionable
- [ ] Go code examples are correct and idiomatic
- [ ] Links between docs are correct
- [ ] Cross-language references are accurate

## Improvement Criteria

### Trigger Improvement If:

âœ… **New Error Patterns**:
- Fixed nil pointer dereference error
- Solved proto conversion issue
- Discovered missing validation

âœ… **New Go Patterns**:
- Created builder pattern
- Implemented functional options
- Added interface design
- Enhanced error wrapping

âœ… **Go Module Issues**:
- Solved import problems
- Fixed dependency issues
- Discovered module path patterns

âœ… **Testing Discoveries**:
- Created table-driven test pattern
- Improved test fixtures
- Enhanced coverage approach

### Skip Improvement If:

âŒ **Routine Application**:
- Used existing patterns correctly
- No issues encountered
- Straightforward implementation

âŒ **Trivial Changes**:
- Typo fixes
- Comment updates
- Minor refactoring

âŒ **Already Documented**:
- Pattern exists in learning log
- Solution in reference docs
- No new discovery

## Example Improvement

### Scenario: Proto Nil Pointer Dereference

**Learning Discovered**:
- Accessing proto nested messages without nil check causes panic
- Must use Get methods (GetSpec(), GetInstructions())
- Proto getters return zero values safely

**Documentation Updates**:

1. **Add to `docs/learning-log.md`**:
```markdown
### 2026-01-13 - Proto Nil Pointer Safety

**Problem**: `panic: runtime error: invalid memory address or nil pointer dereference` when accessing proto fields

**Root Cause**: Proto nested messages can be nil. Direct field access (`proto.Spec.Instructions`) panics if Spec is nil.

**Solution**: Always use proto Get methods which handle nil safely:

```go
// âŒ WRONG - Can panic
instructions := proto.Spec.Instructions

// âœ… CORRECT - Safe with nil check
spec := proto.GetSpec()
if spec == nil {
	return fmt.Errorf("spec is nil")
}
instructions := spec.GetInstructions()

// âœ… ALSO CORRECT - Direct getter (returns zero value if nil)
instructions := proto.GetSpec().GetInstructions()  // Returns "" if spec is nil
```

**Prevention**: 
- Always use Get methods for proto field access
- Add nil checks for nested messages
- Use proto getters in converters

**Cross-Reference**: Python doesn't have this issue - proto fields are always initialized
```

2. **Update `implement-stigmer-sdk-features.mdc`**:

Add to Proto Converters section:
```go
// IMPORTANT: Use Get methods for safe proto access
spec := proto.GetSpec()  // Returns nil if not set
if spec == nil {
	return fmt.Errorf("spec is required")
}
instructions := spec.GetInstructions()  // Safe - returns "" if not set
```

## Output Format

After making improvements, summarize:

```
ðŸ“š Stigmer Go SDK Rule Improvements

Updated Documentation:
âœ… docs/learning-log.md - Added [X] new entries
âœ… docs/[topic].md - Updated [specific section]
âœ… implement-stigmer-sdk-features.mdc - Enhanced [area]

Key Learnings Captured:
â€¢ [Learning 1]: [Brief description with Go specifics]
â€¢ [Learning 2]: [Brief description with Go specifics]
â€¢ [Learning 3]: [Brief description with Go specifics]

Prevention Added:
â€¢ [Pitfall 1]: [How to avoid in Go]
â€¢ [Pitfall 2]: [How to avoid in Go]

Cross-Language References:
â€¢ [Pattern 1]: Python uses X, Go uses Y (see both logs)
```

## Evaluation Questions for AI

When `@complete-stigmer-work` evaluates if this rule should be invoked, ask:

**Go SDK Work Detection**:
1. Did I modify files in `sdk/go/**/*.go`?
2. Did I modify Go SDK test files in `sdk/go/**/*_test.go`?
3. Did I work on Go SDK features (agent, skill, environment, etc.)?

**Go-Specific Learning Detection** (if Go files changed):
1. Did I fix a proto conversion error (nil pointers, getters)?
2. Did I discover a validation pattern worth capturing?
3. Did I solve a struct/interface implementation problem?
4. Did I create a new builder pattern or functional option?
5. Did I fix Go module or dependency issues?
6. Did I enhance error handling with Go error wrapping?
7. Did I discover testing patterns (table-driven tests)?
8. Did I solve a concurrency or context management issue?

**If YES to any learning question** â†’ Trigger this improvement rule

## Integration with Orchestrator

This rule is invoked by `@sdk/_rules/improve-this-rule.mdc` (orchestrator) when:
- Orchestrator detects Go SDK work
- Orchestrator evaluates learning as valuable
- Orchestrator delegates to this Go-specific improvement rule

Flow:
```
@complete-stigmer-work
  â””â”€> Detects SDK work
      â””â”€> Invokes @sdk/_rules/improve-this-rule.mdc (orchestrator)
          â””â”€> Orchestrator detects Go work
              â””â”€> Delegates to @sdk/go/.../improve-this-rule.mdc (this rule)
                  â””â”€> Updates Go SDK docs
```

## Related Rules

- `@implement-go-sdk-features` - Main Go SDK rule being improved
- `@sdk/_rules/improve-this-rule.mdc` - Orchestrator that invokes this rule
- `@sdk/python/_rules/.../improve-python-sdk-rule.mdc` - Python SDK equivalent
- `@complete-stigmer-work` - Triggers improvement flow

---

**Remember**: This rule improves Go-specific SDK patterns. Python-specific patterns go to Python SDK improvement rule. The orchestrator coordinates both.
