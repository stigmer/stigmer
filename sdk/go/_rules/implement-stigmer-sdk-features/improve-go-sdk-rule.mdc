# Rule: Improve Go SDK Rule (action)

**Purpose**: Autonomously improve the `implement-go-sdk-features.mdc` rule based on lessons learned during Go SDK implementation and code generation work.

**Usage**: This rule is invoked when:
- New patterns emerge from SDK implementation work
- Code generation templates need improvements
- Test patterns evolve
- Proto conversion issues are discovered and solved

---

## What This Rule Does

1. **Analyzes Recent Work**: Reviews SDK implementations and code generation improvements
2. **Identifies Learnings**: Extracts new patterns, fixes, or discoveries
3. **Updates Rule**: Enhances the main rule with better patterns and examples
4. **Validates Changes**: Ensures updates are accurate and helpful

---

## When to Invoke

### Trigger Improvement If:

✅ **Code Generation Improvements**:
- Discovered better template patterns
- Improved schema extraction from protos
- Enhanced generated code quality
- Fixed code generation bugs

✅ **SDK Pattern Improvements**:
- Created better functional options
- Improved builder patterns
- Enhanced error handling
- Better validation approaches

✅ **Testing Improvements**:
- New test patterns (unit, integration, e2e)
- Better proto roundtrip testing
- Improved test coverage strategies
- Fixed flaky tests

✅ **Proto Conversion Issues**:
- Solved structpb type conversion problems
- Fixed nested proto handling
- Improved nil pointer safety
- Better repeated field handling

### Skip Improvement If:

❌ **Routine Work**:
- Used existing patterns correctly
- No issues encountered
- Straightforward implementation

❌ **Trivial Changes**:
- Typo fixes
- Comment updates
- Minor refactoring

---

## Improvement Areas

### 1. Code Generation Patterns

**What to capture**:
- Template improvements
- Schema format enhancements
- Better proto parsing
- Improved code formatting

**Example entry**:
```markdown
### Pattern: Generate Validation Helpers

When generating config structs, also generate validation:

```go
// Generated validation method
func (c *SetTaskConfig) Validate() error {
    if len(c.Variables) == 0 {
        return fmt.Errorf("variables cannot be empty")
    }
    return nil
}
```

**Benefits**:
- Catches errors early
- Consistent validation across task types
- Auto-generated from proto constraints
```

### 2. Functional Options Patterns

**What to capture**:
- New option types
- Chainable option patterns
- Type-safe option implementations
- Option composition

**Example entry**:
```markdown
### Pattern: Nested Options

For complex configurations, use nested options:

```go
func HttpAuth(opts ...AuthOption) TaskOption {
    return func(cfg map[string]interface{}) {
        auth := make(map[string]interface{})
        for _, opt := range opts {
            opt(auth)
        }
        cfg["auth"] = auth
    }
}

func BearerToken(token string) AuthOption {
    return func(auth map[string]interface{}) {
        auth["type"] = "bearer"
        auth["token"] = token
    }
}

// Usage
wf.HttpGet("task", uri,
    workflow.HttpAuth(
        workflow.BearerToken("abc123"),
    ),
)
```
```

### 3. Testing Strategies

**What to capture**:
- Test organization patterns
- Coverage strategies
- Roundtrip test improvements
- E2E test patterns

**Example entry**:
```markdown
### Pattern: Roundtrip Tests for All Task Types

Create consistent roundtrip tests:

```go
func TestAllTaskTypes_ProtoRoundtrip(t *testing.T) {
    tests := []struct {
        name string
        task func(*workflow.Workflow)
    }{
        {"HttpGet", func(wf *workflow.Workflow) {
            wf.HttpGet("task", "https://api.example.com")
        }},
        {"Set", func(wf *workflow.Workflow) {
            wf.Set("task", workflow.SetVar("key", "value"))
        }},
        // ... all 13 task types
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            ctx := stigmer.NewContext()
            wf, _ := workflow.New(ctx,
                workflow.WithNamespace("test"),
                workflow.WithName("test"),
                workflow.WithVersion("1.0.0"),
            )
            
            tt.task(wf)
            
            proto, err := wf.ToProto()
            require.NoError(t, err)
            assert.NotNil(t, proto)
        })
    }
}
```

**Benefits**:
- Tests all task types consistently
- Easy to add new task types
- Catches proto conversion bugs early
```

### 4. Proto Conversion Patterns

**What to capture**:
- structpb conversion issues
- Nil pointer safety
- Repeated field handling
- Nested proto construction

**Example entry**:
```markdown
### Issue: structpb Type Requirements

**Problem**: `structpb.NewStruct()` requires `map[string]interface{}`, not `map[string]string`

**Solution**:
```go
// Convert map[string]string to map[string]interface{}
func convertHeaders(headers map[string]string) map[string]interface{} {
    result := make(map[string]interface{})
    for k, v := range headers {
        result[k] = v
    }
    return result
}

// Use in proto conversion
cfg := make(map[string]interface{})
cfg["headers"] = convertHeaders(task.Headers)
```

**Prevention**: Always use `map[string]interface{}` for structpb configs
```

### 5. Dependency Tracking Patterns

**What to capture**:
- Dependency graph improvements
- Circular dependency detection
- Topological sort enhancements
- External reference handling

**Example entry**:
```markdown
### Pattern: Extract Dependencies from Configs

Auto-extract agent dependencies from AGENT_CALL tasks:

```go
func extractAgentDependencies(task *Task) []string {
    if task.Kind != "AGENT_CALL" {
        return nil
    }
    
    agentSlug, ok := task.Config["agent_slug"].(string)
    if !ok {
        return nil
    }
    
    return []string{"agent:" + agentSlug}
}
```

**Benefits**:
- No manual dependency tracking
- Auto-builds dependency graph
- Ensures correct creation order
```

---

## How to Update the Rule

### Step 1: Identify Learning Category

Determine which section of `implement-go-sdk-features.mdc` to update:
- **Core Workflow** - Proto changes → Code generation → Implementation → Testing
- **Code Generation Principles** - Template patterns, schema design
- **Common Patterns** - Functional options, proto conversion, annotations
- **Testing Strategy** - Unit, integration, e2e tests
- **Troubleshooting** - Common issues and fixes

### Step 2: Add Concrete Examples

When adding patterns, include:
- ✅ Working Go code examples
- ✅ Before/after comparisons
- ✅ Benefits and trade-offs
- ✅ Prevention strategies

Avoid:
- ❌ Vague descriptions
- ❌ Incomplete code snippets
- ❌ Untested examples
- ❌ Language-agnostic advice (be Go-specific)

### Step 3: Update Troubleshooting Section

If you solved a bug or issue:
1. Add to Troubleshooting section
2. Include symptoms, root cause, and fix
3. Show working code
4. Explain prevention

**Format**:
```markdown
### Issue N: [Brief Title]

**Symptoms**: [What the error looks like]

**Root Cause**: [Why it happens]

**Fix**:
```go
// ❌ WRONG
[broken code]

// ✅ CORRECT
[working code]
```

**Prevention**: [How to avoid this in future]
```

### Step 4: Keep Examples Minimal but Complete

Examples should be:
- Short enough to read quickly (< 30 lines)
- Complete enough to understand context
- Runnable (or clearly marked as pseudocode)
- Idiomatic Go

### Step 5: Cross-Reference Project Documentation

Link to detailed documentation in the SDK code generators project:
```markdown
**See also**: 
- Code generation principles: `_projects/2026-01/20260122.01.sdk-code-generators-go/coding-guidelines/go-codegen-principles.md`
- Final summary: `_projects/2026-01/20260122.01.sdk-code-generators-go/FINAL-SUMMARY.md`
```

---

## Quality Checklist

Before finalizing improvements:

- [ ] Learning is genuinely new (not already documented)
- [ ] Code examples are tested and work
- [ ] Patterns are Go-idiomatic
- [ ] Documentation is clear and actionable
- [ ] Examples are minimal but complete
- [ ] Troubleshooting includes prevention
- [ ] Cross-references are accurate

---

## Execution Flow

```mermaid
graph TB
    A[SDK Work Completed] --> B{New Patterns<br/>Discovered?}
    B -->|Yes| C[Analyze Learnings]
    B -->|No| D[Skip Improvement]
    
    C --> E[Categorize by Type]
    E --> F{Update Area}
    
    F -->|Code Gen| G[Update Code Generation Section]
    F -->|Patterns| H[Update Common Patterns Section]
    F -->|Testing| I[Update Testing Strategy Section]
    F -->|Troubleshooting| J[Add to Troubleshooting Section]
    
    G --> K[Validate Changes]
    H --> K
    I --> K
    J --> K
    
    K --> L{Changes Valid?}
    L -->|Yes| M[Update Rule]
    L -->|No| N[Refine Examples]
    N --> K
    
    M --> O[Done]
```

---

## Example Improvement Flow

### Scenario: Discovered Better Functional Option Pattern

**Learning**: Options can return errors for validation

**Before** (in rule):
```go
func Timeout(seconds int32) TaskOption {
    return func(cfg map[string]interface{}) {
        cfg["timeout"] = seconds
    }
}
```

**After** (improved):
```go
// Update rule to show error-returning options
func Timeout(seconds int32) TaskOption {
    return func(cfg map[string]interface{}) error {
        if seconds < 1 {
            return fmt.Errorf("timeout must be >= 1 second, got %d", seconds)
        }
        cfg["timeout"] = seconds
        return nil
    }
}

// Update builder to handle errors
func (w *Workflow) HttpGet(taskID, uri string, opts ...TaskOption) (*Task, error) {
    cfg := map[string]interface{}{
        "method": "GET",
        "uri":    uri,
    }
    
    for _, opt := range opts {
        if err := opt(cfg); err != nil {
            return nil, fmt.Errorf("applying option: %w", err)
        }
    }
    
    return w.addTask(taskID, "HTTP_CALL", cfg), nil
}
```

**Add to rule**:
- Update "Functional Options" pattern section
- Add to "Validation" subsection
- Include example in "Common Patterns"
- Update troubleshooting if error handling was an issue

---

## Output Format

After making improvements, summarize:

```
✅ Go SDK Rule Improvements

Updated Sections:
• Code Generation Principles - Added template validation pattern
• Common Patterns - Enhanced functional options with error handling
• Testing Strategy - Added roundtrip test pattern for all task types
• Troubleshooting - Added structpb type conversion issue

Key Patterns Added:
• Error-returning functional options for validation
• Consistent roundtrip testing for all task types
• structpb type conversion helpers
• Dependency extraction from task configs

Prevention Strategies:
• Validate option inputs early
• Use map[string]interface{} for structpb
• Test all task types consistently
• Extract dependencies automatically
```

---

## Related Documentation

- **Main Rule**: `implement-go-sdk-features.mdc` (the rule being improved)
- **Project Summary**: `/_projects/2026-01/20260122.01.sdk-code-generators-go/FINAL-SUMMARY.md`
- **Code Gen Principles**: `/_projects/2026-01/20260122.01.sdk-code-generators-go/coding-guidelines/go-codegen-principles.md`
- **Design Decisions**: `/_projects/2026-01/20260122.01.sdk-code-generators-go/design-decisions/`

---

*This rule continuously improves the Go SDK implementation guide based on real-world experience.*
