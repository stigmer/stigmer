// Code generated by stigmer-codegen. DO NOT EDIT.
// Source: types.go
// Generated: 2026-01-23T22:24:13+05:30

package gen

import (
	"google.golang.org/protobuf/types/known/structpb"
)

// Generic reference to any API resource by scope, org, and name.
//
//	Used across resources to reference other resources (e.g., Environment, Agent, etc.)
type ApiResourceReference struct {
	// Owner scope of the referenced resource
	Scope string `json:"scope,omitempty"`
	// Organization ID (required if scope = organization)
	Org  string `json:"org,omitempty"`
	Kind string `json:"kind,omitempty"`
	// Resource slug (user-friendly name, not ID)
	Slug string `json:"slug,omitempty"`
}

// FromProto converts google.protobuf.Struct to ApiResourceReference.
func (c *ApiResourceReference) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["scope"]; ok {
		c.Scope = val.GetStringValue()
	}

	if val, ok := fields["org"]; ok {
		c.Org = val.GetStringValue()
	}

	if val, ok := fields["kind"]; ok {
		c.Kind = val.GetStringValue()
	}

	if val, ok := fields["slug"]; ok {
		c.Slug = val.GetStringValue()
	}

	return nil
}

// DockerServer defines an MCP server that runs in a Docker container.
type DockerServer struct {
	// Docker image name and tag.  Example: "ghcr.io/org/mcp-server:latest"
	Image string `json:"image,omitempty"`
	// Container command arguments (optional).  Overrides the default CMD in the Docker image.
	Args []string `json:"args,omitempty"`
	// Environment variable placeholders (same as StdioServer).  Example: {"GITHUB_TOKEN": "${GITHUB_TOKEN}"}
	EnvPlaceholders map[string]string `json:"envPlaceholders,omitempty"`
	// Volume mounts for the container (optional).
	Volumes []*VolumeMount `json:"volumes,omitempty"`
	// Docker network to attach the container to (optional, default: "bridge").
	Network string `json:"network,omitempty"`
	// Port mappings for the container (optional).
	Ports []*PortMapping `json:"ports,omitempty"`
	// Container name (optional, auto-generated if not provided).
	ContainerName string `json:"containerName,omitempty"`
}

// FromProto converts google.protobuf.Struct to DockerServer.
func (c *DockerServer) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["image"]; ok {
		c.Image = val.GetStringValue()
	}

	if val, ok := fields["args"]; ok {
		// TODO: Implement FromProto for array field Args
		_ = val // suppress unused variable warning
	}

	if val, ok := fields["envPlaceholders"]; ok {
		c.EnvPlaceholders = make(map[string]string)
		for k, v := range val.GetStructValue().GetFields() {
			c.EnvPlaceholders[k] = v.GetStringValue()
		}
	}

	if val, ok := fields["volumes"]; ok {
		// TODO: Implement FromProto for array field Volumes
		_ = val // suppress unused variable warning
	}

	if val, ok := fields["network"]; ok {
		c.Network = val.GetStringValue()
	}

	if val, ok := fields["ports"]; ok {
		// TODO: Implement FromProto for array field Ports
		_ = val // suppress unused variable warning
	}

	if val, ok := fields["containerName"]; ok {
		c.ContainerName = val.GetStringValue()
	}

	return nil
}

// EnvironmentSpec defines a collection of configuration and secrets.
//
//	Created before AgentInstance or WorkflowInstance, referenced during instance creation.
type EnvironmentSpec struct {
	// Human-readable description of this environment.  Example: "Production AWS credentials for deployment"
	Description string `json:"description,omitempty"`
	// Key-value pairs containing both configuration and secrets.  Each value includes a flag indicating whether it's a secret.  Example: {"AWS_REGION": {value: "us-west-2", is_secret: false},            "AWS_ACCESS_KEY_ID": {value: "AKIA...", is_secret: true}}
	Data map[string]*EnvironmentValue `json:"data,omitempty"`
}

// FromProto converts google.protobuf.Struct to EnvironmentSpec.
func (c *EnvironmentSpec) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["description"]; ok {
		c.Description = val.GetStringValue()
	}

	if val, ok := fields["data"]; ok {
		// TODO: Implement FromProto for map field Data
		_ = val // suppress unused variable warning
	}

	return nil
}

// EnvironmentValue represents a single configuration or secret value.
type EnvironmentValue struct {
	// The actual value.  - If is_secret=true: This value is encrypted at rest and redacted in logs  - If is_secret=false: This value is stored as plaintext
	Value string `json:"value,omitempty"`
	// Whether this value should be treated as a secret.  When true:  - Value is encrypted at rest  - Value is redacted in logs  - Value requires special permissions to read  When false:  - Value is stored as plaintext  - Value is visible in audit logs
	IsSecret bool `json:"isSecret,omitempty"`
	// Optional description for documentation.  Example: "AWS access key for S3 bucket access"
	Description string `json:"description,omitempty"`
}

// FromProto converts google.protobuf.Struct to EnvironmentValue.
func (c *EnvironmentValue) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["value"]; ok {
		c.Value = val.GetStringValue()
	}

	if val, ok := fields["isSecret"]; ok {
		c.IsSecret = val.GetBoolValue()
	}

	if val, ok := fields["description"]; ok {
		c.Description = val.GetStringValue()
	}

	return nil
}

// HttpServer defines an MCP server accessible via HTTP + SSE.
//
//	Used for remote/managed MCP services.
type HttpServer struct {
	// Base URL of the MCP server.  Example: "http://localhost:3000/mcp" or "https://mcp.example.com"
	Url string `json:"url,omitempty"`
	// HTTP headers for authentication/configuration.  Example: {"Authorization": "Bearer ${API_TOKEN}"}  Placeholders like ${API_TOKEN} reference secrets in ConfigSchema.
	Headers map[string]string `json:"headers,omitempty"`
	// Query parameters for the MCP endpoint (optional).  Example: {"version": "v1", "region": "${AWS_REGION}"}
	QueryParams map[string]string `json:"queryParams,omitempty"`
	// Timeout for HTTP requests in seconds (default: 30).
	TimeoutSeconds int32 `json:"timeoutSeconds,omitempty"`
}

// FromProto converts google.protobuf.Struct to HttpServer.
func (c *HttpServer) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["url"]; ok {
		c.Url = val.GetStringValue()
	}

	if val, ok := fields["headers"]; ok {
		c.Headers = make(map[string]string)
		for k, v := range val.GetStructValue().GetFields() {
			c.Headers[k] = v.GetStringValue()
		}
	}

	if val, ok := fields["queryParams"]; ok {
		c.QueryParams = make(map[string]string)
		for k, v := range val.GetStructValue().GetFields() {
			c.QueryParams[k] = v.GetStringValue()
		}
	}

	if val, ok := fields["timeoutSeconds"]; ok {
		c.TimeoutSeconds = int32(val.GetNumberValue())
	}

	return nil
}

// McpServerDefinition defines an MCP server without configuration.
//
//	Configuration with secrets happens at AgentInstance level.
//
//	Supports three types of MCP servers:
//	1. **stdio**: Subprocess-based servers (most common)
//	   - Example: npx @modelcontextprotocol/server-github
//	   - Use when: Running Node.js, Python, or other CLI-based MCP servers
//	   - Communication: stdin/stdout
//
//	2. **http**: HTTP + SSE servers (for remote/managed services)
//	   - Example: https://mcp.example.com/github
//	   - Use when: Connecting to remote MCP services, managed infrastructure
//	   - Communication: HTTP requests + Server-Sent Events
//
//	3. **docker**: Containerized MCP servers
//	   - Example: ghcr.io/org/custom-mcp:latest
//	   - Use when: Running custom/isolated MCP servers, need volume mounts
//	   - Communication: stdio (via Docker exec) or HTTP (via port mapping)
type McpServerDefinition struct {
	// Name of the MCP server (e.g., "github", "aws", "slack").
	Name string `json:"name,omitempty"`
	// stdio-based server (subprocess with stdin/stdout communication).
	Stdio *StdioServer `json:"stdio,omitempty"`
	// HTTP-based server (HTTP + Server-Sent Events communication).
	Http *HttpServer `json:"http,omitempty"`
	// Docker-based server (containerized MCP server).
	Docker *DockerServer `json:"docker,omitempty"`
	// Tool names to enable from this server (empty = all tools).
	EnabledTools []string `json:"enabledTools,omitempty"`
}

// FromProto converts google.protobuf.Struct to McpServerDefinition.
func (c *McpServerDefinition) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["name"]; ok {
		c.Name = val.GetStringValue()
	}

	if val, ok := fields["stdio"]; ok {
		c.Stdio = &StdioServer{}
		if err := c.Stdio.FromProto(val.GetStructValue()); err != nil {
			return err
		}
	}

	if val, ok := fields["http"]; ok {
		c.Http = &HttpServer{}
		if err := c.Http.FromProto(val.GetStructValue()); err != nil {
			return err
		}
	}

	if val, ok := fields["docker"]; ok {
		c.Docker = &DockerServer{}
		if err := c.Docker.FromProto(val.GetStructValue()); err != nil {
			return err
		}
	}

	if val, ok := fields["enabledTools"]; ok {
		// TODO: Implement FromProto for array field EnabledTools
		_ = val // suppress unused variable warning
	}

	return nil
}

// McpToolSelection defines which tools from an MCP server are enabled.
type McpToolSelection struct {
	// Tool names to enable from the MCP server (empty = all tools).
	EnabledTools []string `json:"enabledTools,omitempty"`
}

// FromProto converts google.protobuf.Struct to McpToolSelection.
func (c *McpToolSelection) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["enabledTools"]; ok {
		// TODO: Implement FromProto for array field EnabledTools
		_ = val // suppress unused variable warning
	}

	return nil
}

// PortMapping defines a Docker port mapping.
type PortMapping struct {
	// Host port to bind to.
	HostPort int32 `json:"hostPort,omitempty"`
	// Container port to expose.
	ContainerPort int32 `json:"containerPort,omitempty"`
	// Protocol (default: "tcp"). Can be "tcp" or "udp".
	Protocol string `json:"protocol,omitempty"`
}

// FromProto converts google.protobuf.Struct to PortMapping.
func (c *PortMapping) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["hostPort"]; ok {
		c.HostPort = int32(val.GetNumberValue())
	}

	if val, ok := fields["containerPort"]; ok {
		c.ContainerPort = int32(val.GetNumberValue())
	}

	if val, ok := fields["protocol"]; ok {
		c.Protocol = val.GetStringValue()
	}

	return nil
}

// StdioServer defines an MCP server that runs as a subprocess.
//
//	Communication happens via stdin/stdout (most common type).
type StdioServer struct {
	// Command to run the MCP server (e.g., "npx", "python", "node").
	Command string `json:"command,omitempty"`
	// Command arguments (e.g., ["-y", "@modelcontextprotocol/server-github"]).
	Args []string `json:"args,omitempty"`
	// Environment variable placeholders (e.g., {"GITHUB_TOKEN": "${GITHUB_TOKEN}"}).  Actual values provided at AgentInstance level via ConfigSchema.  The key is the env var name that the MCP server expects.  The value is a placeholder reference like "${GITHUB_TOKEN}" that maps to  a secret or env_var defined in the Agent's ConfigSchema.
	EnvPlaceholders map[string]string `json:"envPlaceholders,omitempty"`
	// Working directory for the process (optional).
	WorkingDir string `json:"workingDir,omitempty"`
}

// FromProto converts google.protobuf.Struct to StdioServer.
func (c *StdioServer) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["command"]; ok {
		c.Command = val.GetStringValue()
	}

	if val, ok := fields["args"]; ok {
		// TODO: Implement FromProto for array field Args
		_ = val // suppress unused variable warning
	}

	if val, ok := fields["envPlaceholders"]; ok {
		c.EnvPlaceholders = make(map[string]string)
		for k, v := range val.GetStructValue().GetFields() {
			c.EnvPlaceholders[k] = v.GetStringValue()
		}
	}

	if val, ok := fields["workingDir"]; ok {
		c.WorkingDir = val.GetStringValue()
	}

	return nil
}

// SubAgent represents a sub-agent that can be delegated to.
type SubAgent struct {
	// Inline sub-agent definition.
	InlineSpec *InlineSubAgentSpec `json:"inlineSpec,omitempty"`
	// Reference to existing Agent resource.
	AgentInstanceRefs *ApiResourceReference `json:"agentInstanceRefs,omitempty"`
}

// FromProto converts google.protobuf.Struct to SubAgent.
func (c *SubAgent) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["inlineSpec"]; ok {
		c.InlineSpec = &InlineSubAgentSpec{}
		if err := c.InlineSpec.FromProto(val.GetStructValue()); err != nil {
			return err
		}
	}

	if val, ok := fields["agentInstanceRefs"]; ok {
		c.AgentInstanceRefs = &ApiResourceReference{}
		if err := c.AgentInstanceRefs.FromProto(val.GetStructValue()); err != nil {
			return err
		}
	}

	return nil
}

// VolumeMount defines a Docker volume mount.
type VolumeMount struct {
	// Host path to mount.
	HostPath string `json:"hostPath,omitempty"`
	// Container path where the volume is mounted.
	ContainerPath string `json:"containerPath,omitempty"`
	// Whether the mount is read-only (default: false).
	ReadOnly bool `json:"readOnly,omitempty"`
}

// FromProto converts google.protobuf.Struct to VolumeMount.
func (c *VolumeMount) FromProto(s *structpb.Struct) error {
	fields := s.GetFields()

	if val, ok := fields["hostPath"]; ok {
		c.HostPath = val.GetStringValue()
	}

	if val, ok := fields["containerPath"]; ok {
		c.ContainerPath = val.GetStringValue()
	}

	if val, ok := fields["readOnly"]; ok {
		c.ReadOnly = val.GetBoolValue()
	}

	return nil
}
