# Error Types in Stigmer Workflows

## Overview

This document explains how error type matching works in TRY/CATCH blocks and how to use the type-safe error handling API.

## The Problem We Solved

**Original Issue**: SDK examples used fictional error types like `"NetworkError"` and `"TimeoutError"` that didn't match the actual error types generated by the workflow-runner backend. This meant error handlers would NEVER execute.

**Root Cause**: There's an implicit contract between the SDK and backend:
- **Backend generates errors** with specific type strings (e.g., `"CallHTTP error"`)
- **SDK must use matching types** in CATCH blocks for handlers to execute
- **No documentation** existed about what error types are available

## How Error Types Work

### 1. Backend Generates Errors

When a task fails, the workflow-runner backend generates an error with a type string:

```go
// In backend: workflow-runner/pkg/zigflow/tasks/task_builder_call_http_activities.go
temporal.NewNonRetryableApplicationError(
    "CallHTTP returned 404",
    "CallHTTP error",  // ← This is the error TYPE
    err,
)
```

### 2. SDK Catches with Matching Type

Your workflow MUST use the exact same type string to catch the error:

```go
// In SDK workflow definition
workflow.WithCatchTyped(
    workflow.CatchHTTPErrors(),  // Resolves to "CallHTTP error"
    "httpErr",
    // This handler executes because types match!
)
```

### 3. Type Matching is Exact

- Case-sensitive: `"CallHTTP error"` ≠ `"callhttp error"`
- Must match exactly: `"CallHTTP error"` ≠ `"CallHTTP"`
- Wildcard `"*"` catches all errors

## Platform Error Types

These error types are generated by the Stigmer platform:

| Constant | Error Type String | Source | When Raised |
|----------|------------------|--------|-------------|
| `ErrorTypeHTTPCall` | `"CallHTTP error"` | HTTP_CALL tasks | HTTP 3xx, 4xx, 5xx responses |
| `ErrorTypeGRPCCall` | `"CallGRPC error"` | GRPC_CALL tasks | gRPC failures, proto errors |
| `ErrorTypeValidation` | `"Validation"` | Input validation | Schema validation fails |
| `ErrorTypeIfStatement` | `"If statement error"` | Conditions | Expression evaluation fails |
| `ErrorTypeCommand` | `"command"` | RUN tasks | Shell command exits non-zero |
| `ErrorTypeAny` | `"*"` | Any | Catch-all wildcard |

## Usage Patterns

### Simple Error Catching (Type-Safe)

```go
workflow.TryTask("attemptOperation",
    workflow.WithTry(
        workflow.HttpCallTask("fetch",
            workflow.WithHTTPGet(),
            workflow.WithURI("https://api.example.com/data"),
        ),
    ),
    
    // Catch HTTP errors (type-safe)
    workflow.WithCatchTyped(
        workflow.CatchHTTPErrors(),
        "httpErr",
        workflow.SetTask("handleHTTPError",
            workflow.SetString("error", "${httpErr.message}"),
        ),
    ),
)
```

### Multiple Specific Errors

```go
workflow.TryTask("attemptOperation",
    workflow.WithTry(/* ... */),
    
    // Catch HTTP errors
    workflow.WithCatchTyped(
        workflow.CatchHTTPErrors(),
        "httpErr",
        workflow.SetTask("handleHTTP", ...),
    ),
    
    // Catch gRPC errors
    workflow.WithCatchTyped(
        workflow.CatchGRPCErrors(),
        "grpcErr",
        workflow.SetTask("handleGRPC", ...),
    ),
    
    // Catch anything else
    workflow.WithCatchTyped(
        workflow.CatchAny(),
        "err",
        workflow.SetTask("handleUnknown", ...),
    ),
)
```

### Combining Multiple Error Types

```go
// Catch both HTTP and gRPC errors with one handler
workflow.WithCatchTyped(
    workflow.CatchHTTPErrors().Or(workflow.CatchGRPCErrors()),
    "networkErr",
    workflow.SetTask("handleNetworkError", ...),
)

// Or use the convenience function
workflow.WithCatchTyped(
    workflow.CatchNetworkErrors(),  // HTTP + gRPC
    "networkErr",
    workflow.SetTask("handleNetworkError", ...),
)
```

### Custom Error Types

For errors raised by your RAISE tasks:

```go
// Raise a custom error
workflow.RaiseTask("checkInventory",
    workflow.WithError("InsufficientInventory"),  // Custom error type
    workflow.WithMessage("Not enough items in stock"),
)

// Catch the custom error
workflow.WithCatchTyped(
    workflow.CatchCustom("InsufficientInventory"),
    "inventoryErr",
    workflow.SetTask("handleShortage", ...),
)
```

### Using Constants Directly (Backward Compatible)

You can still use the old API with constants for type safety:

```go
workflow.WithCatch(
    []string{workflow.ErrorTypeHTTPCall, workflow.ErrorTypeGRPCCall},
    "networkErr",
    workflow.SetTask("handleNetworkError", ...),
)
```

## Available Error Matchers

### Platform Error Matchers

- `CatchHTTPErrors()` - HTTP_CALL failures (3xx, 4xx, 5xx)
- `CatchGRPCErrors()` - GRPC_CALL failures
- `CatchValidationErrors()` - Input validation failures
- `CatchConditionErrors()` - If/when expression evaluation failures
- `CatchCommandErrors()` - RUN task (shell command) failures
- `CatchNetworkErrors()` - HTTP + gRPC (convenience)
- `CatchAny()` - Wildcard catch-all

### Custom Error Matchers

- `CatchCustom("ErrorType")` - Single custom error type
- `CatchMultiple("Type1", "Type2", ...)` - Multiple specific types

### Composition

- `.Or(matcher)` - Combine multiple matchers

## Error Type Metadata

Get information about error types:

```go
// Get metadata for an error type
info, found := workflow.GetErrorTypeInfo(workflow.ErrorTypeHTTPCall)
if found {
    fmt.Println(info.Description)
    fmt.Println(info.Examples)
}

// List all platform error types
types := workflow.ListPlatformErrorTypes()
for _, info := range types {
    fmt.Printf("%s - %s\n", info.Code, info.Description)
}

// Check if error type is platform-defined
if workflow.IsPlatformErrorType("CallHTTP error") {
    fmt.Println("Platform error type")
}
```

## Migration from Old Examples

If you're using the old error type strings from examples:

### ❌ Old (Broken)

```go
workflow.WithCatch(
    []string{"NetworkError", "TimeoutError"},  // Don't exist!
    "networkErr",
    // Never executes
)

workflow.WithCatch(
    []string{"ValidationError"},  // Wrong! Should be "Validation"
    "validationErr",
    // Never executes
)
```

### ✅ New (Fixed)

```go
workflow.WithCatchTyped(
    workflow.CatchHTTPErrors(),  // Matches "CallHTTP error"
    "httpErr",
    // Executes correctly
)

workflow.WithCatchTyped(
    workflow.CatchValidationErrors(),  // Matches "Validation"
    "validationErr",
    // Executes correctly
)
```

## Best Practices

1. **Use type-safe matchers**: Prefer `CatchHTTPErrors()` over raw strings
2. **Order matters**: First matching catch block executes, put specific errors before `CatchAny()`
3. **Use constants for custom types**: Define constants for your custom error types
4. **Document custom errors**: Add comments explaining when they're raised
5. **Test error handlers**: Ensure your catch blocks actually execute

## Why This Matters

**Wrong error types = silent failures**:
- Error handlers won't execute if types don't match
- No error is raised (catch just doesn't match)
- Workflow continues without handling the error
- Hard to debug (you don't know if it's the type or the handler logic)

**Type safety prevents runtime issues**:
- IDE autocomplete shows available error types
- Compile-time typo detection
- Refactoring updates all usages
- Self-documenting code

## Files

- `workflow/error_types.go` - Error type constants and metadata registry
- `workflow/error_matcher.go` - Type-safe error matching builders
- `workflow/error_types_test.go` - Tests verifying constants match backend
- `workflow/error_matcher_test.go` - Tests verifying matcher behavior
- `examples/10_workflow_with_error_handling.go` - Complete example

## More Information

See the changelog for full implementation details:
- `stigmer/_changelog/2026-01/2026-01-15-170501-sdk-error-type-contract-fix.md`
