package workflow

// Error types generated by the Stigmer workflow runtime.
//
// These constants represent the actual error types that can be caught in TRY/CATCH blocks.
// They match the error types generated by the workflow-runner backend when tasks fail.
//
// IMPORTANT: These are NOT arbitrary strings - they must match the error types
// defined in the backend workflow runner. Do not change these values without
// coordinating with the backend team.
//
// Contract: SDK ←→ Workflow Runner Backend
// The SDK must use these exact error type strings to catch errors generated by the platform.

// Platform Error Types
//
// These error types are generated by the Stigmer platform when tasks execute.
const (
	// ErrorTypeHTTPCall is raised when HTTP_CALL tasks fail.
	// Covers 3xx redirects, 4xx client errors, and 5xx server errors.
	//
	// Source: HTTP_CALL tasks
	// When raised:
	//   - 3xx: Redirect encountered (non-retryable)
	//   - 4xx: Client error like 404, 400, 401, 403 (non-retryable)
	//   - 5xx: Server error like 500, 502, 503 (retryable)
	//
	// Example catch block:
	//   workflow.WithCatch(
	//       []string{workflow.ErrorTypeHTTPCall},
	//       "httpErr",
	//       // Handle HTTP failures
	//   )
	ErrorTypeHTTPCall = "CallHTTP error"

	// ErrorTypeGRPCCall is raised when GRPC_CALL tasks fail.
	// Covers proto file loading errors, argument serialization errors, and gRPC call failures.
	//
	// Source: GRPC_CALL tasks
	// When raised:
	//   - Proto file cannot be loaded
	//   - Arguments cannot be serialized to JSON
	//   - gRPC call fails (network, unavailable, deadline exceeded, etc.)
	//
	// Example catch block:
	//   workflow.WithCatch(
	//       []string{workflow.ErrorTypeGRPCCall},
	//       "grpcErr",
	//       // Handle gRPC failures
	//   )
	ErrorTypeGRPCCall = "CallGRPC error"

	// ErrorTypeValidation is raised when workflow input validation fails.
	// This happens before workflow execution when input doesn't match the defined schema.
	//
	// Source: Workflow input validation (before execution)
	// When raised:
	//   - Input missing required fields
	//   - Input has wrong data types
	//   - Input violates schema constraints
	//
	// Example catch block:
	//   workflow.WithCatch(
	//       []string{workflow.ErrorTypeValidation},
	//       "validationErr",
	//       // Handle validation failures
	//   )
	ErrorTypeValidation = "Validation"

	// ErrorTypeIfStatement is raised when if/when conditional evaluation fails.
	// This happens when expression parsing fails or returns an invalid type.
	//
	// Source: SWITCH task condition evaluation, task if/when guards
	// When raised:
	//   - Expression syntax is invalid
	//   - Expression returns non-boolean type
	//
	// Example catch block:
	//   workflow.WithCatch(
	//       []string{workflow.ErrorTypeIfStatement},
	//       "conditionErr",
	//       // Handle condition evaluation failures
	//   )
	ErrorTypeIfStatement = "If statement error"

	// ErrorTypeCommand is raised when RUN tasks (shell commands) fail.
	// This happens when a shell command exits with non-zero status.
	//
	// Source: RUN tasks
	// When raised:
	//   - Command exits with non-zero code
	//   - Command execution fails
	//
	// Example catch block:
	//   workflow.WithCatch(
	//       []string{workflow.ErrorTypeCommand},
	//       "cmdErr",
	//       // Handle command failures
	//   )
	ErrorTypeCommand = "command"

	// ErrorTypeAny is a wildcard that catches ALL error types.
	// Use this as a fallback catch block to handle any unhandled errors.
	//
	// Source: Any task
	// When raised: Any error
	//
	// Example catch block:
	//   workflow.WithCatch(
	//       []string{workflow.ErrorTypeAny},
	//       "err",
	//       // Handle all other errors
	//   )
	ErrorTypeAny = "*"
)

// User-Defined Error Types
//
// In addition to platform error types, users can define custom error types using RAISE tasks.
// These custom error types are user-defined strings that can be caught in CATCH blocks.
//
// Example:
//
//	// Raise a custom error
//	workflow.RaiseTask("checkInventory",
//	    workflow.WithError("InsufficientInventory"),  // Custom error type
//	    workflow.WithMessage("Not enough items in stock"),
//	)
//
//	// Catch the custom error
//	workflow.WithCatch(
//	    []string{"InsufficientInventory"},  // Matches the custom error type
//	    "inventoryErr",
//	    // Handle inventory shortage
//	)
//
// Custom error types follow these conventions:
//   - Use PascalCase (e.g., "InsufficientInventory", "PaymentDeclined")
//   - Be descriptive and domain-specific
//   - Avoid generic names like "Error" or "Failure"
//   - Use consistent naming across your workflows

// ErrorTypeInfo provides metadata about a platform error type.
// This is used for documentation, IDE support, and runtime validation.
type ErrorTypeInfo struct {
	// Code is the error type string (e.g., "CallHTTP error")
	Code string

	// Category groups related error types (e.g., "Network", "Validation")
	Category string

	// Source indicates which task type generates this error
	Source string

	// Retryable indicates if errors of this type are retryable by default
	// Note: Actual retryability can be configured per-task using retry policies
	Retryable bool

	// Description explains when this error occurs
	Description string

	// Examples provides common scenarios that trigger this error
	Examples []string
}

// ErrorRegistry contains metadata for all platform error types.
// This registry is used for:
//   - Documentation generation
//   - IDE autocomplete and hover tooltips
//   - Runtime validation (warning about unknown error types)
//   - CLI help commands
var ErrorRegistry = map[string]ErrorTypeInfo{
	ErrorTypeHTTPCall: {
		Code:      ErrorTypeHTTPCall,
		Category:  "Network",
		Source:    "HTTP_CALL tasks",
		Retryable: false, // 4xx=non-retryable, 5xx=retryable (same type)
		Description: "HTTP call failed with 3xx redirect, 4xx client error, or 5xx server error. " +
			"3xx and 4xx are non-retryable (requires code fix), 5xx are retryable (transient server issue).",
		Examples: []string{
			"404 Not Found - endpoint doesn't exist",
			"401 Unauthorized - invalid credentials",
			"500 Internal Server Error - server failure",
			"503 Service Unavailable - service overloaded",
			"Connection refused - server not reachable",
			"Timeout - request took too long",
		},
	},

	ErrorTypeGRPCCall: {
		Code:      ErrorTypeGRPCCall,
		Category:  "Network",
		Source:    "GRPC_CALL tasks",
		Retryable: false,
		Description: "gRPC call failed due to proto file loading error, argument serialization error, " +
			"or gRPC service unavailability.",
		Examples: []string{
			"Proto file not found",
			"Cannot parse proto schema",
			"Arguments don't match proto schema",
			"gRPC service unavailable",
			"gRPC deadline exceeded",
		},
	},

	ErrorTypeValidation: {
		Code:      ErrorTypeValidation,
		Category:  "Data",
		Source:    "Workflow input validation",
		Retryable: false,
		Description: "Workflow input validation failed against JSON schema. " +
			"This error occurs before workflow execution starts.",
		Examples: []string{
			"Missing required field 'userId'",
			"Field 'age' must be a number",
			"Email format is invalid",
			"Value exceeds maximum length",
		},
	},

	ErrorTypeIfStatement: {
		Code:      ErrorTypeIfStatement,
		Category:  "Expression",
		Source:    "SWITCH task conditions, if/when guards",
		Retryable: false,
		Description: "Conditional expression evaluation failed due to syntax error " +
			"or type mismatch (non-boolean result).",
		Examples: []string{
			"Expression syntax error",
			"Undefined variable in expression",
			"Expression returned non-boolean type",
		},
	},

	ErrorTypeCommand: {
		Code:      ErrorTypeCommand,
		Category:  "Execution",
		Source:    "RUN tasks",
		Retryable: true,
		Description: "Shell command execution failed with non-zero exit code.",
		Examples: []string{
			"Command exited with code 1",
			"Script execution failed",
			"Command not found",
		},
	},

	ErrorTypeAny: {
		Code:        ErrorTypeAny,
		Category:    "Wildcard",
		Source:      "Any task",
		Retryable:   false, // Depends on the actual error
		Description: "Wildcard that matches ALL error types. Use as a catch-all fallback.",
		Examples: []string{
			"Catches any error not handled by previous catch blocks",
		},
	},
}

// GetErrorTypeInfo returns metadata for a given error type code.
// Returns (info, true) if the error type is a known platform type.
// Returns (zero, false) for user-defined error types or unknown types.
func GetErrorTypeInfo(code string) (ErrorTypeInfo, bool) {
	info, ok := ErrorRegistry[code]
	return info, ok
}

// ListPlatformErrorTypes returns all registered platform error types.
// This excludes user-defined error types and the wildcard "*".
func ListPlatformErrorTypes() []ErrorTypeInfo {
	types := make([]ErrorTypeInfo, 0, len(ErrorRegistry))
	for _, info := range ErrorRegistry {
		if info.Code != ErrorTypeAny {
			types = append(types, info)
		}
	}
	return types
}

// IsPlatformErrorType returns true if the given code is a known platform error type.
func IsPlatformErrorType(code string) bool {
	_, ok := ErrorRegistry[code]
	return ok
}
