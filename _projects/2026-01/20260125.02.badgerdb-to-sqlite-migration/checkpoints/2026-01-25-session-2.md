# Session Notes: 2026-01-25 (Session 2)

## Session Focus
SQLite Store Architecture Redesign - Evolving from BadgerDB key-value patterns to proper relational design with a dedicated audit table.

## Accomplishments

### Schema Migration System
- Added `schema_version` table for tracking migration versions
- Implemented `migrateToV1` (initial schema) and `migrateToV2` (audit table)
- Migration runs atomically within transactions
- Existing `skill_audit/*` prefixed records automatically migrated to new table

### New Audit Table Design
Created dedicated `resource_audit` table with:
- `id INTEGER PRIMARY KEY AUTOINCREMENT` - Simple unique ID
- `kind TEXT NOT NULL` - Resource kind
- `resource_id TEXT NOT NULL` - References parent resource
- `data BLOB NOT NULL` - Protobuf-serialized snapshot
- `archived_at TEXT NOT NULL` - Timestamp for ordering
- `version_hash TEXT` - Indexed for hash lookups
- `tag TEXT` - Indexed for tag lookups

### Indexes Added
- `idx_audit_resource(kind, resource_id)` - List all audits for a resource
- `idx_audit_hash(kind, resource_id, version_hash)` - Hash lookups
- `idx_audit_tag(kind, resource_id, tag, archived_at DESC)` - Tag lookups with recency

### Interface Evolution
Added 5 new methods to `store.Store` interface:
- `SaveAudit` - Archive a resource snapshot
- `GetAuditByHash` - Retrieve by exact hash
- `GetAuditByTag` - Retrieve most recent by tag
- `ListAuditHistory` - Get all versions for a resource
- `DeleteAuditByResourceId` - Explicit cleanup

Added `ErrAuditNotFound` sentinel error.
Deprecated `DeleteResourcesByIdPrefix` with documentation.

### Controller Updates
- `push.go`: Uses `SaveAudit()` with extracted hash/tag
- `load_skill_by_reference.go`: Uses indexed queries instead of full scan
- `delete.go`: Uses `DeleteAuditByResourceId()`

## Decisions Made

### Why Separate Audit Table?
The original design stored audit records in the same `resources` table with prefixed IDs like `skill_audit/<id>/<timestamp>`. This was a key-value store pattern from BadgerDB that doesn't leverage SQLite's relational capabilities.

Problems with old approach:
- `ListResources` returned both live and audit records, requiring app-level filtering
- No indexes on audit-specific fields (hash, tag)
- Full table scans for version lookups
- No referential integrity

### Why Extract version_hash and tag?
These fields are frequently queried and benefit from indexes:
- Hash lookups for exact version retrieval
- Tag lookups with recency ordering

The proto data is preserved as BLOB for full restoration.

### Foreign Key Decision
Did NOT add foreign key constraint because:
- Migrated records might have orphaned parents
- SQLite doesn't support adding FK to existing tables easily
- Explicit `DeleteAuditByResourceId` provides cleanup

Could be added in future migration if needed.

## Key Code Changes

### backend/libs/go/store/sqlite/store.go
- Added schema version tracking system (lines 23-32)
- Added migration functions: `runMigrations`, `migrateToV1`, `migrateToV2`
- Added `migrateAuditRecords` for legacy data migration
- Implemented all 5 audit methods
- Enabled `PRAGMA foreign_keys=ON`

### backend/libs/go/store/interface.go
- Added `ErrAuditNotFound` sentinel error
- Added audit method signatures with comprehensive documentation
- Marked `DeleteResourcesByIdPrefix` as deprecated

### backend/services/stigmer-server/pkg/domain/skill/controller/load_skill_by_reference.go
- Replaced O(n) full table scan with O(log n) indexed queries
- Removed prefix-based filtering logic
- Uses `GetAuditByHash` or `GetAuditByTag` based on version format

## Learnings

### Reference Implementation
stigmer-cloud's `SkillAuditRepo` (Java/MongoDB) follows the same pattern:
- Separate `skill_audit` collection
- `skillId` field referencing parent
- `archivedAt` timestamp
- Indexed queries by hash and tag

This validated the architectural direction.

### SQLite Index Design
For tag queries with recency:
```sql
CREATE INDEX idx_audit_tag ON resource_audit(kind, resource_id, tag, archived_at DESC);
```

The `DESC` ordering in the index allows `ORDER BY archived_at DESC LIMIT 1` to use the index efficiently.

## Open Questions
- Should we add foreign key constraint in future migration?
- Should other resources (agents, workflows) also use audit storage?
- Consider retention policy for old audit records?

## Next Session Plan
1. Run full test suite to verify changes
2. Commit the architecture changes
3. Test end-to-end skill workflows (push, get-by-reference, delete)
4. Consider follow-up PR for foreign key constraint
