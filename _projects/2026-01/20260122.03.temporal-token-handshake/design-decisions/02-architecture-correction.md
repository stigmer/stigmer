# Architecture Correction: Callback Token Placement

**Date**: 2026-01-22  
**Status**: Correction Required

---

## Issue Identified

Initial implementation added `callback_token` to the wrong location:

❌ **Wrong**: Added to `WorkflowExecuteInput` in `workflowrunner/v1/io.proto` (gRPC interface)  
✅ **Correct**: Should be in `WorkflowExecutionStatus` (system-managed state)

---

## Why the Correction is Needed

### 1. Spec/Status Separation Pattern

Stigmer follows a strict separation:
- **Spec**: User-provided inputs (immutable after creation)
- **Status**: System-managed state (continuously updated during execution)

The `callback_token`:
- Is **system-generated** by Temporal when activity starts
- Is **not user-provided**
- Is **runtime state**, not configuration

Therefore, it belongs in **Status**, not Spec/Input.

### 2. Two Separate Execution Paths

**Path 1: Temporal Workflow** (production):
```
ExecuteWorkflowActivity (Go)
  → temporalClient.ExecuteWorkflow()
  → ExecuteServerlessWorkflow (Temporal workflow)
  → Uses: TemporalWorkflowInput struct
```

**Path 2: Direct gRPC** (testing/direct calls):
```
External Client
  → WorkflowRunnerServiceController.ExecuteAsync (gRPC)
  → Uses: WorkflowExecuteInput proto
```

The Temporal path does **NOT** use the gRPC proto interface!

### 3. Consistency with temporal_workflow_id

`WorkflowExecutionStatus` already has `temporal_workflow_id` (line 352):

```protobuf
message WorkflowExecutionStatus {
  // ... existing fields ...
  
  // Temporal workflow ID (if using Temporal as execution engine).
  string temporal_workflow_id = 7;
}
```

The `callback_token` is similar - it's Temporal-specific runtime state.

---

## Corrected Implementation

### 1. WorkflowExecutionStatus (Proto)

**File**: `apis/ai/stigmer/agentic/workflowexecution/v1/api.proto`

**Add field after `temporal_workflow_id`:**

```protobuf
message WorkflowExecutionStatus {
  // ... existing fields (1-7) ...
  
  // Temporal workflow ID (if using Temporal as execution engine).
  string temporal_workflow_id = 7;
  
  // Temporal callback token for async activity completion.
  //
  // When a WorkflowExecution is triggered from a Temporal activity (e.g., from another
  // workflow or orchestrator), the calling activity passes its task token here.
  // The workflow-runner is responsible for completing the external activity when the
  // workflow finishes.
  //
  // ## Token Handshake Pattern
  //
  // 1. External workflow calls ExecuteWorkflowActivity
  // 2. Activity extracts task token: activity.GetInfo(ctx).TaskToken
  // 3. Activity stores token in WorkflowExecution.status.callback_token (via updateStatus)
  // 4. Activity returns activity.ErrResultPending (activity paused)
  // 5. ExecuteServerlessWorkflow executes (minutes/hours)
  // 6. On completion: workflow-runner calls ActivityCompletionClient.complete(token, result)
  // 7. External activity resumes with result
  //
  // ## Why in Status (not Spec)
  //
  // - System-generated: Token is created by Temporal, not provided by user
  // - Runtime state: Token is part of execution lifecycle, not configuration
  // - Ephemeral: Token is only relevant during execution, not for retries
  // - Follows pattern: Similar to temporal_workflow_id (also system-generated)
  //
  // ## Backward Compatibility
  //
  // This field is optional. When empty:
  // - Workflow executes normally
  // - No external activity completion is attempted
  // - Results are returned via normal status updates
  //
  // ## Token Format
  //
  // Opaque binary value (100-200 bytes) generated by Temporal.
  // Do not modify or interpret - only pass to ActivityCompletionClient.
  //
  // ## Use Cases
  //
  // - **With token** (orchestrated): External activity waits for completion
  // - **Without token** (direct): Workflow executes independently
  //
  // ## Security
  //
  // Token grants ability to complete external activity - treat as sensitive.
  // Log as Base64 (truncated) for debugging.
  //
  // Example: <binary data, Base64 encoded: "ChxkZWZhdWx0LjAx...">
  bytes callback_token = 11;
}
```

### 2. TemporalWorkflowInput (Go Struct)

**File**: `backend/services/workflow-runner/pkg/types/progress.go`

**Add field:**

```go
// TemporalWorkflowInput is the input to the generic Temporal workflow
type TemporalWorkflowInput struct {
	// WorkflowExecutionID is the unique ID for this execution
	WorkflowExecutionID string

	// WorkflowYaml is the complete CNCF Serverless Workflow YAML
	WorkflowYaml string

	// Metadata contains workflow identification information
	Metadata *WorkflowMetadata

	// InitialData is the initial data to pass to the workflow
	InitialData map[string]any

	// EnvVars are environment variables to make available to the workflow
	EnvVars map[string]any

	// OrgId is the organization ID this workflow execution belongs to.
	// Used by activities that need organization context (e.g., agent calls).
	// Extracted from WorkflowExecution.metadata.org.
	OrgId string

	// CallbackToken is the Temporal task token for async activity completion.
	// When set, the workflow-runner will complete the external activity upon workflow finish.
	// Optional - only set when triggered from a Temporal activity.
	CallbackToken []byte
}
```

### 3. ExecuteWorkflowActivity (Go Activity)

**File**: `backend/services/workflow-runner/worker/activities/execute_workflow_activity.go`

**Changes**:

1. Extract token at activity start
2. Store token in WorkflowExecutionStatus
3. Pass token to TemporalWorkflowInput
4. Return activity.ErrResultPending

```go
func (a *ExecuteWorkflowActivityImpl) ExecuteWorkflow(
	ctx context.Context,
	execution *workflowexecutionv1.WorkflowExecution,
) (*workflowexecutionv1.WorkflowExecutionStatus, error) {
	logger := activity.GetLogger(ctx)
	
	// Extract execution ID
	executionID := execution.Metadata.Id
	
	// PHASE 2: Extract Temporal task token
	activityInfo := activity.GetInfo(ctx)
	taskToken := activityInfo.TaskToken
	
	logger.Info("ExecuteWorkflow activity started",
		"execution_id", executionID,
		"has_callback_token", len(taskToken) > 0)
	
	// PHASE 2: Store token in WorkflowExecutionStatus
	_, err := a.workflowExecutionClient.UpdateStatus(ctx, executionID, &workflowexecutionv1.WorkflowExecutionStatus{
		Phase:         workflowexecutionv1.ExecutionPhase_EXECUTION_IN_PROGRESS,
		CallbackToken: taskToken,  // NEW: Store token
	})
	if err != nil {
		logger.Warn("Failed to update status with callback token", "error", err)
	}
	
	// ... existing code: query instance, workflow, convert to YAML ...
	
	// PHASE 2: Pass token to Temporal workflow
	workflowInput := &types.TemporalWorkflowInput{
		WorkflowExecutionID: executionID,
		WorkflowYaml:        workflowYAML,
		InitialData:         map[string]interface{}{},
		EnvVars:             runtimeEnv,
		OrgId:               execution.Metadata.Org,
		CallbackToken:       taskToken,  // NEW: Pass token to inner workflow
	}
	
	// Start ExecuteServerlessWorkflow
	run, err := a.temporalClient.ExecuteWorkflow(ctx, workflowOptions, "ExecuteServerlessWorkflow", workflowInput)
	if err != nil {
		// ... error handling ...
	}
	
	// PHASE 2: If token exists, return ErrResultPending (don't wait)
	if len(taskToken) > 0 {
		logger.Info("Callback token present - returning ErrResultPending",
			"execution_id", executionID,
			"workflow_id", run.GetID())
		
		// Activity will pause here, workflow continues in background
		return nil, activity.ErrResultPending
	}
	
	// No token: wait for completion (backward compatibility)
	var workflowOutput types.TemporalWorkflowOutput
	err = run.Get(ctx, &workflowOutput)
	// ... existing completion logic ...
}
```

### 4. ExecuteServerlessWorkflow (Go Workflow)

**File**: `backend/services/workflow-runner/pkg/executor/temporal_workflow.go`

**Changes**:

1. Accept `CallbackToken` in input
2. On success/failure: Complete external activity
3. Use System Activity for completion (determinism)

```go
func ExecuteServerlessWorkflow(ctx workflow.Context, input *types.TemporalWorkflowInput) (*types.TemporalWorkflowOutput, error) {
	logger := workflow.GetLogger(ctx)
	
	// ... existing workflow execution logic ...
	
	// PHASE 2: Check if callback token exists
	hasCallback := len(input.CallbackToken) > 0
	if hasCallback {
		logger.Info("Callback token present - will complete external activity on finish",
			"execution_id", input.WorkflowExecutionID)
	}
	
	// Execute workflow tasks
	result, err := workflowFunc(ctx, input.InitialData, state)
	
	// PHASE 2: Complete external activity if token exists
	if hasCallback {
		if err != nil {
			// Workflow failed - fail external activity
			logger.Info("Workflow failed - failing external activity",
				"execution_id", input.WorkflowExecutionID,
				"error", err.Error())
			
			failErr := completeExternalActivity(ctx, input.CallbackToken, nil, err)
			if failErr != nil {
				logger.Error("Failed to complete external activity",
					"error", failErr.Error())
			}
		} else {
			// Workflow succeeded - complete external activity
			logger.Info("Workflow succeeded - completing external activity",
				"execution_id", input.WorkflowExecutionID)
			
			completeErr := completeExternalActivity(ctx, input.CallbackToken, result, nil)
			if completeErr != nil {
				logger.Error("Failed to complete external activity",
					"error", completeErr.Error())
			}
		}
	}
	
	return output, err
}

// completeExternalActivity completes the external Temporal activity
// Must use System Activity for determinism
func completeExternalActivity(ctx workflow.Context, token []byte, result interface{}, err error) error {
	// Create System Activity stub
	systemActivity := workflow.NewSystemActivityStub(ctx)
	
	if err != nil {
		// Fail external activity
		return systemActivity.FailExternalActivity(token, err)
	}
	
	// Complete external activity
	return systemActivity.CompleteExternalActivity(token, result)
}
```

### 5. System Activities (NEW)

**File**: `backend/services/workflow-runner/worker/activities/system_activities.go` (new file)

**Purpose**: Implement external activity completion

```go
package activities

import (
	"context"
	"encoding/base64"
	"fmt"

	"github.com/rs/zerolog/log"
	"go.temporal.io/sdk/activity"
	"go.temporal.io/sdk/client"
)

// SystemActivities handles system-level operations like external activity completion
type SystemActivities struct {
	temporalClient client.Client
}

// NewSystemActivities creates a new SystemActivities instance
func NewSystemActivities(temporalClient client.Client) *SystemActivities {
	return &SystemActivities{
		temporalClient: temporalClient,
	}
}

// CompleteExternalActivity completes an external Temporal activity using token
func (a *SystemActivities) CompleteExternalActivity(ctx context.Context, token []byte, result interface{}) error {
	logger := activity.GetLogger(ctx)
	
	tokenStr := base64.StdEncoding.EncodeToString(token)[:20] + "..."
	logger.Info("Completing external activity",
		"token_preview", tokenStr,
		"has_result", result != nil)
	
	completionClient := a.temporalClient.CompleteActivityByToken(token, result, nil)
	
	logger.Info("External activity completed successfully")
	return nil
}

// FailExternalActivity fails an external Temporal activity using token
func (a *SystemActivities) FailExternalActivity(ctx context.Context, token []byte, err error) error {
	logger := activity.GetLogger(ctx)
	
	tokenStr := base64.StdEncoding.EncodeToString(token)[:20] + "..."
	logger.Info("Failing external activity",
		"token_preview", tokenStr,
		"error", err.Error())
	
	completionClient := a.temporalClient.CompleteActivityByToken(token, nil, err)
	
	logger.Info("External activity failed with error")
	return nil
}
```

---

## AgentExecution Status

Need to add `callback_token` to `AgentExecutionStatus` as well if agents can be invoked via Temporal activities.

**File**: `apis/ai/stigmer/agentic/agentexecution/v1/api.proto`

**Add field:**

```protobuf
message AgentExecutionStatus {
  // ... existing fields ...
  
  // Temporal callback token for async activity completion.
  // Similar to WorkflowExecutionStatus.callback_token
  // Used when agent is invoked from a Temporal activity.
  bytes callback_token = 10;
}
```

---

## Revert Proto Change

**File**: `apis/ai/stigmer/agentic/workflowrunner/v1/io.proto`

**Action**: Remove `callback_token` from `WorkflowExecuteInput`

The gRPC interface is for direct calls only and doesn't need the token.

---

## Summary of Changes

| Location | Action | Reason |
|----------|--------|--------|
| `workflowexecution/v1/api.proto` | Add `callback_token` to Status | System-managed state |
| `agentexecution/v1/api.proto` | Add `callback_token` to Status | System-managed state |
| `workflowrunner/v1/io.proto` | **REVERT** callback_token from Input | Wrong location |
| `types/progress.go` | Add `CallbackToken` field | Temporal workflow input |
| `execute_workflow_activity.go` | Extract token, store in status, pass to workflow, return ErrResultPending | Phase 2 implementation |
| `temporal_workflow.go` | Complete external activity on finish | Phase 3 implementation |
| `system_activities.go` | **NEW** System activity for completion | Phase 4 implementation |

---

**Status**: Correction Plan Complete - Ready to Implement
