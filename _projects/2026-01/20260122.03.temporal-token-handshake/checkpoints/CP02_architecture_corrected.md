# Checkpoint 02: Architecture Corrected - callback_token in Status

**Checkpoint Date**: 2026-01-22  
**Phase**: Phase 1 - Proto Definition (Corrected)  
**Status**: ✅ CORRECTED

---

## Summary

Successfully corrected the `callback_token` placement based on user feedback. Moved token from Input/Spec (wrong) to Status (correct) following Stigmer's Spec/Status separation pattern.

---

## What Was Wrong

❌ **Initial Implementation**: Added `callback_token` to `WorkflowExecuteInput` in `workflowrunner/v1/io.proto`

**Problems**:
1. `WorkflowExecuteInput` is for the gRPC interface (not used by Temporal workflows)
2. Token is system-generated, not user-provided, so it doesn't belong in "Input/Spec"
3. Violated Stigmer's Spec/Status separation pattern

---

## What Was Corrected

✅ **Corrected Implementation**: Added `callback_token` to Status messages:
1. `WorkflowExecutionStatus` (field 11)
2. `AgentExecutionStatus` (field 10)

---

## Changes Made

### 1. Reverted Wrong Change

**File**: `apis/ai/stigmer/agentic/workflowrunner/v1/io.proto`

**Action**: Removed `callback_token` field from `WorkflowExecuteInput`

**Reason**: This gRPC interface is for direct calls only, not used by Temporal workflows

### 2. Added to WorkflowExecutionStatus

**File**: `apis/ai/stigmer/agentic/workflowexecution/v1/api.proto`

**Change**: Added field 11 to `WorkflowExecutionStatus`:

```protobuf
message WorkflowExecutionStatus {
  // ... existing fields (1-7) ...
  
  string temporal_workflow_id = 7;
  
  // Temporal callback token for async activity completion.
  // System-generated when triggered from Temporal activity.
  // Used to complete external activity when workflow finishes.
  bytes callback_token = 11;
}
```

**Generated Go Code**:
```go
type WorkflowExecutionStatus struct {
    // ... existing fields ...
    CallbackToken []byte `protobuf:"bytes,11,opt,name=callback_token,json=callbackToken,proto3" json:"callback_token,omitempty"`
}

func (x *WorkflowExecutionStatus) GetCallbackToken() []byte
```

### 3. Added to AgentExecutionStatus

**File**: `apis/ai/stigmer/agentic/agentexecution/v1/api.proto`

**Change**: Added field 10 to `AgentExecutionStatus`:

```protobuf
message AgentExecutionStatus {
  // ... existing fields (1-9) ...
  
  map<string, TodoItem> todos = 9;
  
  // Temporal callback token for async activity completion.
  // Same pattern as WorkflowExecution (field 11).
  // Used when agent invoked from Temporal activity.
  bytes callback_token = 10;
}
```

**Generated Go Code**:
```go
type AgentExecutionStatus struct {
    // ... existing fields ...
    CallbackToken []byte `protobuf:"bytes,10,opt,name=callback_token,json=callbackToken,proto3" json:"callback_token,omitempty"`
}

func (x *AgentExecutionStatus) GetCallbackToken() []byte
```

### 4. Proto Code Regenerated

**Command**: `make protos`

**Result**: ✅ Success
- Go stubs regenerated for all proto files
- Python stubs regenerated
- BUILD.bazel files updated

### 5. Build Verification

**Command**: `bazel build //apis/stubs/go/...`

**Result**: ✅ Success
- All Go proto stubs compile without errors
- No breaking changes

---

## Why This is Correct

### 1. Spec/Status Separation Pattern

Stigmer follows a strict pattern across all API resources:

**Spec (User Inputs)**:
- User-provided configuration
- Immutable after creation
- Used for retries (same spec = same execution)

**Status (System State)**:
- System-generated during execution
- Continuously updated
- Not user-controlled

The `callback_token` is:
- ✅ System-generated by Temporal
- ✅ Runtime state (not configuration)
- ✅ Ephemeral (only relevant during execution)

Therefore, it belongs in **Status**, not Spec/Input.

### 2. Consistency with temporal_workflow_id

`WorkflowExecutionStatus` already has `temporal_workflow_id` (field 7) which is also system-generated Temporal state. The `callback_token` follows the same pattern.

### 3. Two Execution Paths

**Temporal Workflow Path** (production):
- Uses `TemporalWorkflowInput` Go struct
- Does NOT use gRPC `WorkflowExecuteInput`
- Token is stored in Status, not passed in Input

**Direct gRPC Path** (testing):
- Uses `WorkflowExecuteInput` proto
- Token not needed (direct call, no orchestration)

---

## Architecture Understanding

### Flow Correction

**Old Understanding** (wrong):
```
ExecuteWorkflowActivity → gRPC.ExecuteAsync(WorkflowExecuteInput) ❌
```

**Corrected Understanding** (right):
```
ExecuteWorkflowActivity
  → temporalClient.ExecuteWorkflow(TemporalWorkflowInput) ✅
  → ExecuteServerlessWorkflow (Temporal workflow)
```

### Where Token Lives

1. **Activity Start**: Token extracted from `activity.GetInfo(ctx).TaskToken`
2. **Status Update**: Token stored in `WorkflowExecution.status.callback_token` via `updateStatus` RPC
3. **Workflow Input**: Token passed in `TemporalWorkflowInput.CallbackToken` (Go struct)
4. **Activity Pause**: Activity returns `activity.ErrResultPending`
5. **Workflow Finish**: workflow-runner completes external activity via token
6. **Activity Resume**: External activity resumes with result

---

## Next Steps

### 1. Update TemporalWorkflowInput (Go Struct)

**File**: `backend/services/workflow-runner/pkg/types/progress.go`

**Add**:
```go
type TemporalWorkflowInput struct {
    // ... existing fields ...
    CallbackToken []byte
}
```

### 2. Update ExecuteWorkflowActivity

**File**: `backend/services/workflow-runner/worker/activities/execute_workflow_activity.go`

**Changes**:
1. Extract token at activity start
2. Store token in WorkflowExecutionStatus
3. Pass token to TemporalWorkflowInput
4. Return `activity.ErrResultPending` if token exists

### 3. Update ExecuteServerlessWorkflow

**File**: `backend/services/workflow-runner/pkg/executor/temporal_workflow.go`

**Changes**:
1. Accept `CallbackToken` in input
2. On completion: complete external activity
3. Use System Activity for completion

### 4. Create SystemActivities

**File**: `backend/services/workflow-runner/worker/activities/system_activities.go` (new)

**Methods**:
- `CompleteExternalActivity(token, result)`
- `FailExternalActivity(token, error)`

---

## Lessons Learned

### 1. Understand the Architecture First

The initial mistake came from not fully understanding:
- How Temporal workflows are invoked (via Go client, not gRPC)
- Where system state should live (Status, not Spec)
- The Spec/Status separation pattern

### 2. User Feedback is Valuable

The user immediately spotted the architectural issue by asking:
- "Is the gRPC interface even used by Temporal workflows?"
- "Should the token be in Status since it's system-generated?"

This led to discovering the real execution path and correcting the implementation.

### 3. Follow Existing Patterns

`temporal_workflow_id` was already in Status (field 7), which should have been a clue that `callback_token` belongs there too (both are system-generated Temporal state).

---

## Files Modified

| File | Action | Purpose |
|------|--------|---------|
| `workflowrunner/v1/io.proto` | Reverted callback_token | Not needed in gRPC interface |
| `workflowexecution/v1/api.proto` | Added callback_token to Status (field 11) | System-managed state |
| `agentexecution/v1/api.proto` | Added callback_token to Status (field 10) | System-managed state |
| `workflowexecution/v1/api.pb.go` | Auto-generated | Go stubs |
| `agentexecution/v1/api.pb.go` | Auto-generated | Go stubs |

---

## Deliverables Checklist

Phase 1 (Corrected):

- [x] Proto files corrected with callback_token in Status (not Input)
- [x] Go proto code regenerated and compiling
- [x] Java proto code regenerated (N/A - Go-only)
- [x] Proto documentation comprehensive (60+ lines per field)
- [x] Fields are optional (backward compatible)
- [x] Documentation clearly explains token usage and placement
- [x] No breaking changes

---

## Time Spent

- Initial implementation: 1.5 hours (wrong location)
- Architecture discovery: 1 hour
- Correction and documentation: 1 hour

**Total**: ~3.5 hours

**Key Insight**: Spending time understanding architecture upfront would have saved 1.5 hours of rework.

---

**Status**: ✅ CORRECTED - Ready for Phase 2 (Go implementation)  
**Next**: Update Go structs and implement token handshake logic

---

**Checkpoint Created**: 2026-01-22  
**Lesson**: Always understand Spec/Status separation and execution paths before adding fields
