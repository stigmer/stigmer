syntax = "proto3";

package ai.stigmer.agentic.workflowexecution.v1;

import "ai/stigmer/agentic/workflowexecution/v1/api.proto";
import "ai/stigmer/commons/apiresource/io.proto";
import "ai/stigmer/commons/apiresource/rpc_service_options.proto";
import "ai/stigmer/iam/iampolicy/v1/rpcauthorization/method_options.proto";
import "buf/validate/validate.proto";

// WorkflowExecutionCommandController handles write operations (Create, Update, Delete) for WorkflowExecution resources.
//
// This service follows the Command-Query Separation (CQS) pattern:
// - CommandController: Write operations (create, update, delete)
// - QueryController: Read operations (get, list, search)
//
// Authorization:
// All RPCs use custom authorization logic implemented in middleware.
// Custom authorization is needed because:
// - create: Must verify user has "execute" permission on the referenced WorkflowInstance
// - update: Only the workflow runner (system) can update execution status, not users
//
// Service Options:
// - api_resource_kind: workflow_execution - Links this service to the WorkflowExecution resource
service WorkflowExecutionCommandController {
  option (ai.stigmer.commons.apiresource.api_resource_kind) = workflow_execution;

  // Create and trigger a new workflow execution.
  //
  // This RPC creates a WorkflowExecution resource and immediately triggers it for execution.
  // The workflow execution engine (Temporal) picks up the execution and begins processing tasks.
  //
  // Input Validation:
  // - metadata.owner_scope must be ORGANIZATION or IDENTITY_ACCOUNT (not PLATFORM)
  // - spec.workflow_instance_id is required and must reference an existing WorkflowInstance
  // - api_version must be exactly "agentic.stigmer.ai/v1"
  // - kind must be exactly "WorkflowExecution"
  //
  // Authorization:
  // Custom authorization verifies:
  // 1. User has "execute" permission on the referenced WorkflowInstance
  // 2. User has access to all referenced Environments (from WorkflowInstance)
  // 3. User has access to all referenced Secrets (from runtime_env secret_refs)
  //
  // Execution Flow:
  // 1. Validate input (proto validation + business rules)
  // 2. Check authorization (user can execute WorkflowInstance)
  // 3. Create WorkflowExecution resource in database
  // 4. Set initial status.phase = EXECUTION_PENDING
  // 5. Trigger workflow in execution engine (Temporal)
  // 6. Return WorkflowExecution with status.phase = EXECUTION_PENDING or EXECUTION_IN_PROGRESS
  //
  // Status After Create:
  // - status.phase: EXECUTION_PENDING (or EXECUTION_IN_PROGRESS if already picked up)
  // - status.audit.created_at: Current timestamp
  // - status.audit.created_by: Authenticated user ID
  // - status.started_at: Not set yet (set when phase transitions to IN_PROGRESS)
  //
  // Use Cases:
  //
  // 1. API-Triggered Execution:
  // - User calls API to execute a workflow
  // - Input: WorkflowExecution with spec.workflow_instance_id and spec.trigger_message
  // - Output: WorkflowExecution with generated ID and PENDING status
  //
  // 2. Webhook-Triggered Execution:
  // - External system (Stripe, GitHub, etc.) sends webhook
  // - Webhook handler creates WorkflowExecution with webhook payload in spec.trigger_message
  // - spec.trigger_metadata captures webhook source, event type, timestamp
  //
  // 3. Scheduled Execution:
  // - Scheduler service creates WorkflowExecution at scheduled time
  // - spec.trigger_metadata includes schedule ID and cron expression
  //
  // 4. UI-Triggered Execution:
  // - User clicks "Execute" button in web console
  // - UI creates WorkflowExecution with user-provided inputs
  //
  // 5. Workflow Chaining (Workflow A triggers Workflow B):
  // - Workflow A completes, creates WorkflowExecution for Workflow B
  // - spec.trigger_message contains output from Workflow A
  // - spec.trigger_metadata includes parent workflow execution ID
  //
  // Error Cases:
  //
  // - INVALID_ARGUMENT:
  //   - workflow_instance_id is missing or invalid
  //   - owner_scope is PLATFORM (not allowed)
  //   - api_version or kind is incorrect
  //
  // - PERMISSION_DENIED:
  //   - User doesn't have "execute" permission on WorkflowInstance
  //   - User doesn't have access to referenced Environments
  //   - User doesn't have access to referenced Secrets
  //
  // - NOT_FOUND:
  //   - Referenced WorkflowInstance doesn't exist
  //   - Referenced Environment doesn't exist
  //   - Referenced Secret doesn't exist
  //
  // - FAILED_PRECONDITION:
  //   - WorkflowInstance is in invalid state (e.g., archived, disabled)
  //   - Too many concurrent executions (quota exceeded)
  //
  // Example Request:
  // {
  //   "api_version": "agentic.stigmer.ai/v1",
  //   "kind": "WorkflowExecution",
  //   "metadata": {
  //     "name": "customer-onboarding-20250111-143022",
  //     "owner_scope": 2  // ORGANIZATION
  //   },
  //   "spec": {
  //     "workflow_instance_id": "wfi-customer-onboarding-prod",
  //     "trigger_message": "New signup: john.doe@example.com",
  //     "trigger_metadata": {
  //       "source": "api",
  //       "caller_id": "usr-jane-admin",
  //       "timestamp": "2025-01-11T14:30:22Z"
  //     },
  //     "runtime_env": {
  //       "CUSTOMER_EMAIL": { "value": "john.doe@example.com" }
  //     }
  //   }
  // }
  //
  // Example Response:
  // {
  //   "api_version": "agentic.stigmer.ai/v1",
  //   "kind": "WorkflowExecution",
  //   "metadata": {
  //     "id": "wfx-abc123xyz456",  // Auto-generated
  //     "name": "customer-onboarding-20250111-143022",
  //     "owner_scope": 2
  //   },
  //   "spec": { ... },  // Same as request
  //   "status": {
  //     "phase": 1,  // EXECUTION_PENDING
  //     "audit": {
  //       "created_at": "2025-01-11T14:30:22Z",
  //       "created_by": "usr-jane-admin"
  //     }
  //   }
  // }
  rpc create(WorkflowExecution) returns (WorkflowExecution);

  // Update execution with full state.
  // Used by users to update execution configuration (spec fields).
  // No individual field updates - always provide complete state.
  rpc update(WorkflowExecution) returns (WorkflowExecution) {
    option (ai.stigmer.iam.iampolicy.v1.rpcauthorization.config).resource_kind = workflow_execution;
    option (ai.stigmer.iam.iampolicy.v1.rpcauthorization.config).permission = can_edit;
    option (ai.stigmer.iam.iampolicy.v1.rpcauthorization.config).field_path = "metadata.id";
    option (ai.stigmer.iam.iampolicy.v1.rpcauthorization.config).error_msg = "unauthorized to update workflow execution";
  }

  // Update execution status during workflow execution.
  // Used by workflow-runner to send progressive status updates (messages, task states, phase, etc.)
  // This RPC is optimized for frequent status updates and merges status fields with existing state.
  //
  // This RPC is used by the workflow execution engine (Temporal) to update the status
  // of a running workflow execution. Users cannot call this RPC directly.
  //
  // What Can Be Updated:
  // - status.phase (PENDING → IN_PROGRESS → COMPLETED/FAILED/CANCELLED)
  // - status.tasks (update task statuses, outputs, errors)
  // - status.output (set final workflow output when COMPLETED)
  // - status.error (set error message when FAILED)
  // - status.started_at (set when execution starts)
  // - status.completed_at (set when execution finishes)
  //
  // What Cannot Be Updated:
  // - spec.* (user inputs are immutable after creation)
  // - metadata.id (resource ID is immutable)
  // - status.audit.created_at (creation timestamp is immutable)
  //
  // Authorization:
  // Custom authorization verifies:
  // 1. Caller is the workflow runner service (system identity, not a user)
  // 2. Only status fields are being modified (spec and metadata unchanged)
  //
  // Update Flow:
  // 1. Workflow runner executes a task
  // 2. Task completes/fails
  // 3. Workflow runner calls updateStatus() with:
  //    - Updated status.tasks (new task status, output/error)
  //    - Updated status.phase (if all tasks done)
  // 4. Backend validates and persists update
  // 5. Backend broadcasts update via WebSocket (for real-time UI updates)
  //
  // Use Cases:
  //
  // 1. Task Started:
  // - Workflow runner updates status.tasks[i].status = IN_PROGRESS
  //
  // 2. Task Completed:
  // - Workflow runner updates status.tasks[i].status = COMPLETED
  // - Workflow runner sets status.tasks[i].output
  //
  // 3. Task Failed:
  // - Workflow runner updates status.tasks[i].status = FAILED
  // - Workflow runner sets status.tasks[i].error
  // - Workflow runner updates status.phase = EXECUTION_FAILED
  // - Workflow runner sets status.error
  // - Workflow runner sets status.completed_at
  //
  // 4. Workflow Completed:
  // - Workflow runner updates status.phase = EXECUTION_COMPLETED
  // - Workflow runner sets status.output
  // - Workflow runner sets status.completed_at
  //
  // 5. Workflow Cancelled:
  // - Workflow runner receives cancellation signal
  // - Workflow runner updates status.phase = EXECUTION_CANCELLED
  // - Workflow runner sets status.completed_at
  //
  // Error Cases:
  //
  // - PERMISSION_DENIED:
  //   - Caller is not the workflow runner service (users cannot update status)
  //
  // - INVALID_ARGUMENT:
  //   - Trying to modify spec or metadata (only status can be updated)
  //   - Invalid phase transition (e.g., COMPLETED → IN_PROGRESS)
  //
  // - NOT_FOUND:
  //   - WorkflowExecution with given ID doesn't exist
  //
  // Example Request (Task Completed):
  // {
  //   "metadata": {
  //     "id": "wfx-abc123xyz456"
  //   },
  //   "status": {
  //     "phase": 2,  // EXECUTION_IN_PROGRESS
  //     "completed_tasks": 1,
  //     "tasks": [
  //       {
  //         "task_id": "task-1",
  //         "task_name": "validate_email",
  //         "status": 3,  // WORKFLOW_TASK_COMPLETED
  //         "output": { "valid": true },
  //         "completed_at": "2025-01-11T14:30:27Z"
  //       },
  //       {
  //         "task_id": "task-2",
  //         "task_name": "create_account",
  //         "status": 2,  // WORKFLOW_TASK_IN_PROGRESS
  //         "timestamp": "2025-01-11T14:30:27Z"
  //       }
  //     ]
  //   }
  // }
  rpc updateStatus(WorkflowExecutionUpdateStatusInput) returns (WorkflowExecution) {
    option (ai.stigmer.iam.iampolicy.v1.rpcauthorization.config).resource_kind = workflow_execution;
    option (ai.stigmer.iam.iampolicy.v1.rpcauthorization.config).permission = can_edit;
    option (ai.stigmer.iam.iampolicy.v1.rpcauthorization.config).field_path = "execution_id";
    option (ai.stigmer.iam.iampolicy.v1.rpcauthorization.config).error_msg = "unauthorized to update workflow execution status";
  }

  // Delete an execution.
  rpc delete(ai.stigmer.commons.apiresource.ApiResourceId) returns (WorkflowExecution) {
    option (ai.stigmer.iam.iampolicy.v1.rpcauthorization.config).resource_kind = workflow_execution;
    option (ai.stigmer.iam.iampolicy.v1.rpcauthorization.config).permission = can_edit;
    option (ai.stigmer.iam.iampolicy.v1.rpcauthorization.config).field_path = "value";
    option (ai.stigmer.iam.iampolicy.v1.rpcauthorization.config).error_msg = "unauthorized to delete workflow execution";
  }
}

// Input message for updateStatus RPC.
// Contains only the execution ID and the status fields to be updated.
// This avoids validation errors on incomplete metadata/spec fields and makes the API contract clearer.
message WorkflowExecutionUpdateStatusInput {
  // ID of the workflow execution to update (required).
  // Format: "wex_abc123xyz456"
  string execution_id = 1 [(buf.validate.field).string.min_len = 1];

  // Status fields to update.
  // The handler will merge these status fields with the existing execution's status.
  // Only the fields present in this status object will be updated.
  WorkflowExecutionStatus status = 2 [(buf.validate.field).required = true];
}
