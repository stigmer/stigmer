syntax = "proto3";

package ai.stigmer.agentic.agent.v1;

import "ai/stigmer/commons/sdk/metadata.proto";
import "buf/validate/validate.proto";

// AgentManifest is the SDK-CLI contract for agent blueprints.
//
// This manifest is the serialized representation of agent configuration
// collected by SDKs (Go, Python, TypeScript). The CLI reads this manifest
// and converts it to AgentSpec before deploying to the platform.
//
// Architecture: Synthesis Model
// 1. User writes code using SDK (Go, Python, TypeScript)
// 2. SDK collects agent configuration (skills, MCP servers, etc.)
// 3. SDK serializes to agent-manifest.pb (this proto)
// 4. CLI reads agent-manifest.pb
// 5. CLI converts to Agent (api.proto) + AgentSpec (spec.proto)
// 6. CLI deploys to Stigmer platform
//
// Why separate from AgentSpec?
// - SDK is proto-agnostic (only knows about manifest)
// - CLI handles platform proto conversion
// - SDKs can be language-idiomatic
// - Platform and SDK evolve independently
//
// Multi-Agent Support:
// - SDKs can define multiple agents in a single file
// - All agents are collected and serialized to one manifest
// - CLI deploys all agents in a batch operation
message AgentManifest {
  // Metadata about the SDK that generated this manifest.
  // Shared across all SDK manifests (agent, workflow, etc.).
  ai.stigmer.commons.sdk.SdkMetadata sdk_metadata = 1 [(buf.validate.field).required = true];

  // Agent blueprints collected by the SDK.
  // Multiple agents can be defined in a single SDK execution.
  // The CLI deploys all agents in the order they appear.
  repeated AgentBlueprint agents = 2 [(buf.validate.field).repeated.min_items = 1];
}

// AgentBlueprint represents the complete agent configuration.
// This is what the SDK collects from user code.
//
// Note: This is similar to AgentSpec but simpler and SDK-focused.
// The CLI converts AgentBlueprint → AgentSpec during deployment.
message AgentBlueprint {
  // Agent name (required, min 3 chars).
  string name = 1 [(buf.validate.field).string = {
    min_len: 3
    max_len: 100
  }];

  // Agent instructions defining behavior and personality (min 10 chars).
  string instructions = 2 [(buf.validate.field).string.min_len = 10];

  // Human-readable description for UI display.
  string description = 3;

  // Icon URL for marketplace and UI display.
  string icon_url = 4;

  // Skills that provide the agent with knowledge and capabilities.
  repeated ManifestSkill skills = 5;

  // MCP servers that provide tools for the agent.
  repeated ManifestMcpServer mcp_servers = 6;

  // Sub-agents that can be delegated to.
  repeated ManifestSubAgent sub_agents = 7;

  // Environment variables required by the agent.
  repeated ManifestEnvironmentVariable environment_variables = 8;
}

// ManifestSkill represents a skill reference or inline definition.
// Skills provide agents with knowledge and specialized capabilities.
//
// The CLI converts:
// - Platform/Org skills → ApiResourceReference in AgentSpec.skill_refs
// - Inline skills → Creates Skill resource, then ApiResourceReference
message ManifestSkill {
  // Unique ID for this skill (generated by SDK).
  string id = 1 [(buf.validate.field).required = true];

  // Skill source (platform, org, or inline).
  oneof source {
    // Reference to a platform-managed skill.
    PlatformSkillReference platform = 2;

    // Reference to an organization-managed skill.
    OrgSkillReference org = 3;

    // Inline skill definition.
    InlineSkillDefinition inline = 4;
  }
}

// PlatformSkillReference references a skill from the Stigmer platform.
message PlatformSkillReference {
  // Skill name (e.g., "coding-standards", "security-reviewer").
  string name = 1 [(buf.validate.field).required = true];
}

// OrgSkillReference references a skill from an organization's skill repository.
message OrgSkillReference {
  // Skill name.
  string name = 1 [(buf.validate.field).required = true];

  // Organization scope (e.g., "acme-corp").
  string org = 2 [(buf.validate.field).required = true];
}

// InlineSkillDefinition defines a skill directly in the agent blueprint.
// CLI will create a Skill resource from this definition.
message InlineSkillDefinition {
  // Skill name.
  string name = 1 [(buf.validate.field).required = true];

  // Skill description.
  string description = 2;

  // Markdown content defining the skill's knowledge.
  // Can be loaded from file or provided inline.
  string markdown_content = 3 [(buf.validate.field).string.min_len = 10];
}

// ManifestMcpServer represents an MCP server configuration.
// MCP (Model Context Protocol) servers provide tools for agents.
//
// The CLI converts ManifestMcpServer → McpServerDefinition in AgentSpec.
message ManifestMcpServer {
  // Server name (e.g., "github", "aws", "slack").
  string name = 1 [(buf.validate.field).required = true];

  // Tool names to enable from this server (empty = all tools).
  repeated string enabled_tools = 2;

  // Server type and transport configuration.
  oneof server_type {
    // stdio-based server (subprocess with stdin/stdout communication).
    ManifestStdioServer stdio = 3;

    // HTTP-based server (HTTP + Server-Sent Events communication).
    ManifestHttpServer http = 4;

    // Docker-based server (containerized MCP server).
    ManifestDockerServer docker = 5;
  }
}

// ManifestStdioServer defines an MCP server that runs as a subprocess.
// Communication happens via stdin/stdout (most common type).
message ManifestStdioServer {
  // Command to run the MCP server (e.g., "npx", "python", "node").
  string command = 1 [(buf.validate.field).required = true];

  // Command arguments (e.g., ["-y", "@modelcontextprotocol/server-github"]).
  repeated string args = 2;

  // Environment variable placeholders (e.g., {"GITHUB_TOKEN": "${GITHUB_TOKEN}"}).
  // The key is the env var name that the MCP server expects.
  // The value is a placeholder reference like "${GITHUB_TOKEN}".
  map<string, string> env_placeholders = 3;

  // Working directory for the process (optional).
  string working_dir = 4;
}

// ManifestHttpServer defines an MCP server accessible via HTTP + SSE.
// Used for remote/managed MCP services.
message ManifestHttpServer {
  // Base URL of the MCP server.
  string url = 1 [(buf.validate.field).required = true];

  // HTTP headers for authentication/configuration.
  // Example: {"Authorization": "Bearer ${API_TOKEN}"}
  map<string, string> headers = 2;

  // Query parameters for the MCP endpoint (optional).
  map<string, string> query_params = 3;

  // Timeout for HTTP requests in seconds (default: 30).
  int32 timeout_seconds = 4;
}

// ManifestDockerServer defines an MCP server that runs in a Docker container.
message ManifestDockerServer {
  // Docker image name and tag.
  string image = 1 [(buf.validate.field).required = true];

  // Container command arguments (optional).
  repeated string args = 2;

  // Environment variable placeholders (same as StdioServer).
  map<string, string> env_placeholders = 3;

  // Volume mounts for the container (optional).
  repeated ManifestVolumeMount volumes = 4;

  // Port mappings for the container (optional).
  repeated ManifestPortMapping ports = 5;

  // Docker network to attach the container to (optional, default: "bridge").
  string network = 6;

  // Container name (optional, auto-generated if not provided).
  string container_name = 7;
}

// ManifestVolumeMount defines a Docker volume mount.
message ManifestVolumeMount {
  // Host path to mount.
  string host_path = 1 [(buf.validate.field).required = true];

  // Container path where the volume is mounted.
  string container_path = 2 [(buf.validate.field).required = true];

  // Whether the mount is read-only (default: false).
  bool read_only = 3;
}

// ManifestPortMapping defines a Docker port mapping.
message ManifestPortMapping {
  // Host port to bind to.
  int32 host_port = 1 [(buf.validate.field).int32.gte = 1];

  // Container port to expose.
  int32 container_port = 2 [(buf.validate.field).int32.gte = 1];

  // Protocol (default: "tcp"). Can be "tcp" or "udp".
  string protocol = 3;
}

// ManifestSubAgent represents a sub-agent configuration.
// Sub-agents are specialized agents that the main agent can delegate tasks to.
//
// The CLI converts:
// - Inline sub-agents → InlineSubAgentSpec in AgentSpec.sub_agents
// - Referenced sub-agents → ApiResourceReference in AgentSpec.sub_agents
message ManifestSubAgent {
  // Sub-agent source (inline or referenced).
  oneof source {
    // Inline sub-agent definition.
    InlineSubAgentDefinition inline = 1;

    // Reference to existing AgentInstance.
    ReferencedSubAgent reference = 2;
  }
}

// InlineSubAgentDefinition defines a sub-agent directly in the agent blueprint.
message InlineSubAgentDefinition {
  // Sub-agent name.
  string name = 1 [(buf.validate.field).required = true];

  // Behavior instructions for this sub-agent.
  string instructions = 2 [(buf.validate.field).string.min_len = 10];

  // Description of what this sub-agent does.
  string description = 3;

  // MCP server names this sub-agent can use.
  repeated string mcp_server_names = 4;

  // Tool selections for each MCP server.
  repeated ManifestToolSelection tool_selections = 5;

  // Skills available to this sub-agent.
  repeated ManifestSkill skills = 6;
}

// ReferencedSubAgent references an existing AgentInstance.
message ReferencedSubAgent {
  // AgentInstance ID to reference.
  string agent_instance_id = 1 [(buf.validate.field).required = true];
}

// ManifestToolSelection defines which tools from an MCP server are enabled.
message ManifestToolSelection {
  // MCP server name.
  string mcp_server_name = 1 [(buf.validate.field).required = true];

  // Tool names to enable from this server (empty = all tools).
  repeated string tools = 2;
}

// ManifestEnvironmentVariable represents an environment variable configuration.
//
// The CLI converts ManifestEnvironmentVariable → EnvironmentSpec in AgentSpec.
message ManifestEnvironmentVariable {
  // Variable name (e.g., "GITHUB_TOKEN", "AWS_REGION").
  string name = 1 [(buf.validate.field).required = true];

  // Human-readable description of what this variable is for.
  string description = 2;

  // Whether this is a secret (should be masked in UI).
  bool is_secret = 3;

  // Default value (optional, not used for secrets).
  string default_value = 4;

  // Whether this variable is required.
  bool required = 5;
}
