syntax = "proto3";

// Package ai.stigmer.agentic.workflowrunner.v1 defines the service interface
// that all workflow execution engines must implement to integrate with Stigmer.
//
// This package belongs to the Agentic bounded context and defines the contract
// between Stigmer's workflow orchestration layer and external execution engines
// (Temporal, Airflow, custom runners, etc.).
//
// ## Architecture Overview
//
// Workflow runners are external services that execute CNCF Serverless Workflow
// definitions on behalf of Stigmer. When a WorkflowExecution is created, Stigmer:
// 1. Fetches the workflow YAML from MongoDB
// 2. Resolves environment variables and secrets
// 3. Calls the runner's execute_async RPC
// 4. Tracks progress through Temporal/flows
//
// ## Future Evolution
//
// This package will eventually contain:
// - WorkflowRunner API resource - For registering execution services
// - WorkflowRunnerCommandController - CRUD operations for runner resources
// - WorkflowRunnerQueryController - Read operations for runner resources
//
// For now, it contains only the service interface definition.
//
// ## Component Distinction
//
// - **WorkflowRunner** (future API resource) - Registered execution service metadata
// - **WorkflowRunnerCommandController** (future) - CRUD operations for runner registration
// - **WorkflowExecutionService** (this file) - Service interface that runners implement
//
// ## Execution Model
//
// All workflow execution is **asynchronous** (fire-and-forget). The execute_async
// RPC returns immediately with execution metadata. Progress tracking happens through
// Temporal workflows and is captured in WorkflowExecution.status.progress_events.
//
// Runners must NOT use gRPC streaming for progress - instead, they should:
// 1. Accept execution request
// 2. Start workflow asynchronously
// 3. Return execution ID and status URLs
// 4. Update progress via Temporal signals/activities
package ai.stigmer.agentic.workflowrunner.v1;

import "ai/stigmer/agentic/workflowrunner/v1/io.proto";
import "google/protobuf/empty.proto";

// WorkflowRunnerServiceController defines the service interface that all workflow
// execution engines must implement to integrate with Stigmer.
//
// This is the core contract enabling pluggable workflow execution backends.
// Runners can be anything from managed services (Temporal Cloud, Airflow) to
// custom in-house execution engines.
//
// ## Integration Model
//
// When registering a WorkflowRunner resource (future capability), users provide:
// - Endpoint URL implementing this service interface
// - Authentication credentials (API keys, mTLS certs)
// - Capabilities (supports pause/resume, resource limits, etc.)
//
// Stigmer validates runner health by calling a health check endpoint and routes
// workflow executions based on runner capabilities and availability.
//
// ## Execution Flow
//
// 1. User creates WorkflowExecution resource in Stigmer
// 2. Stigmer backend selects appropriate runner based on requirements
// 3. Stigmer calls runner's execute_async RPC with complete execution context
// 4. Runner starts execution and returns immediately with execution ID
// 5. Progress tracking happens through Temporal workflows/flows
// 6. Final results stored in WorkflowExecution.status
//
// ## Authorization
//
// Authorization for these RPCs is NOT handled through Stigmer's IAM policy system
// because runners are external services. Instead, runners authenticate via:
// - API keys in request headers
// - Mutual TLS certificates
// - Cloud provider IAM (for managed services)
//
// Runner endpoints should be secured and only accessible to Stigmer backend services.
service WorkflowRunnerServiceController {
  // Execute workflow asynchronously (fire-and-forget pattern).
  //
  // This is the primary RPC for workflow execution. It accepts a complete
  // execution context (workflow YAML, environment variables, metadata) and
  // starts execution asynchronously.
  //
  // ## Execution Semantics
  //
  // The runner MUST:
  // - Validate workflow YAML syntax
  // - Start execution in the background
  // - Return immediately with execution metadata
  // - Track progress independently
  // - Handle failures and retries according to workflow definition
  //
  // The runner SHOULD:
  // - Store execution state for resumability
  // - Emit progress events to Stigmer via callbacks
  // - Support graceful cancellation
  // - Enforce resource limits if specified
  //
  // ## Input Validation
  //
  // Runners should validate:
  // - workflow_execution_id is present and unique
  // - workflow_yaml is valid CNCF Serverless Workflow syntax
  // - env_vars don't contain malicious values
  // - config.max_timeout_seconds is within runner's limits
  //
  // ## Use Cases
  //
  // 1. **Deploy Infrastructure**: Workflow orchestrates Terraform/Pulumi runs
  // 2. **Data Pipeline**: Workflow coordinates ETL tasks across services
  // 3. **Multi-Agent Coordination**: Workflow executes agent collaboration tasks
  // 4. **Integration Testing**: Workflow runs end-to-end test scenarios
  // 5. **Incident Response**: Workflow automates runbook execution
  //
  // ## Error Handling
  //
  // Return gRPC errors for:
  // - INVALID_ARGUMENT: Malformed workflow YAML or missing required fields
  // - RESOURCE_EXHAUSTED: Runner at capacity, cannot accept new executions
  // - UNAVAILABLE: Runner temporarily unavailable (maintenance, overload)
  // - INTERNAL: Unexpected runner failure
  //
  // Do NOT return errors for workflow execution failures (tasks failing, timeouts).
  // Those should be tracked in progress events and final status.
  //
  // ## Example
  //
  // Input:
  // ```
  // workflow_execution_id: "wex-abc123def456"
  // workflow_yaml: |
  //   name: deploy-infrastructure
  //   version: 1.0.0
  //   start: validate-config
  //   states:
  //     - name: validate-config
  //       type: operation
  //       actions:
  //         - name: check-terraform
  //           functionRef: validate-terraform
  // env_vars: {
  //   "AWS_REGION": "us-east-1",
  //   "ENVIRONMENT": "production"
  // }
  // config: {
  //   max_timeout_seconds: 3600
  //   debug_enabled: false
  // }
  // ```
  //
  // Response:
  // ```
  // workflow_execution_id: "wex-abc123def456"
  // status: "running"
  // message: "Workflow execution started successfully"
  // temporal_workflow_id: "deploy-infrastructure-20250111-104530"
  // subscribe_url: "wss://runner.example.com/ws/wex-abc123def456"
  // status_url: "https://runner.example.com/api/v1/executions/wex-abc123def456"
  // ```
  rpc executeAsync(WorkflowExecuteInput) returns (WorkflowExecuteResponse);

  // Cancel a running workflow execution.
  //
  // Requests graceful cancellation of an in-progress workflow. The runner should:
  // 1. Mark execution as cancelling
  // 2. Stop scheduling new tasks
  // 3. Wait for in-flight tasks to complete (unless force=true)
  // 4. Clean up resources (temporary files, locks, connections)
  // 5. Mark execution as cancelled
  //
  // ## Graceful vs Forced Cancellation
  //
  // - **Graceful** (force=false): Allow current tasks to complete, then stop
  // - **Forced** (force=true): Terminate immediately, may leave incomplete work
  //
  // Runners should default to graceful cancellation for data consistency.
  //
  // ## Idempotency
  //
  // Cancelling an already-cancelled or completed execution should succeed (no-op).
  // Multiple cancel requests for the same execution_id should be safe.
  //
  // ## Use Cases
  //
  // 1. User manually cancels long-running workflow via UI
  // 2. Timeout watchdog cancels stuck executions
  // 3. Cost control system cancels expensive workflows
  // 4. Deployment rollback cancels in-progress infrastructure changes
  //
  // ## Error Handling
  //
  // Return gRPC errors for:
  // - NOT_FOUND: execution_id doesn't exist
  // - FAILED_PRECONDITION: Execution already completed/failed (cannot cancel)
  //
  // Do NOT return errors if execution is already cancelled (idempotent success).
  //
  // ## Example
  //
  // Request:
  // ```
  // execution_id: "wex-abc123def456"
  // reason: "User requested cancellation via web console"
  // force: false
  // ```
  //
  // Response: Empty (success)
  rpc cancelExecution(CancelExecutionRequest) returns (google.protobuf.Empty);

  // Pause a running workflow execution.
  //
  // Suspends workflow execution while preserving state for later resumption.
  // The runner should:
  // 1. Complete currently-executing tasks
  // 2. Checkpoint workflow state (variables, task status)
  // 3. Release execution resources (workers, locks)
  // 4. Mark execution as paused
  //
  // ## State Preservation
  //
  // Runners MUST preserve:
  // - Workflow input and output variables
  // - Task completion status
  // - Execution metadata and timestamps
  // - Pending task queue
  //
  // Runners MAY release:
  // - Worker processes/threads
  // - Network connections
  // - Temporary compute resources
  //
  // ## Use Cases
  //
  // 1. Cost optimization: Pause development workflows overnight
  // 2. Manual intervention: Pause for human approval before proceeding
  // 3. Dependency wait: Pause until external system is available
  // 4. Debugging: Pause execution to inspect state
  //
  // ## Runner Capability
  //
  // Not all runners support pause/resume (e.g., serverless functions).
  // Runners should return UNIMPLEMENTED if pause is not supported.
  //
  // ## Error Handling
  //
  // Return gRPC errors for:
  // - NOT_FOUND: execution_id doesn't exist
  // - FAILED_PRECONDITION: Execution not in running state
  // - UNIMPLEMENTED: Runner doesn't support pause/resume
  //
  // ## Example
  //
  // Request:
  // ```
  // execution_id: "wex-abc123def456"
  // reason: "Pausing for manual approval of infrastructure changes"
  // ```
  //
  // Response: Empty (success)
  rpc pauseExecution(PauseExecutionRequest) returns (google.protobuf.Empty);

  // Resume a paused workflow execution.
  //
  // Restores workflow execution from paused state. The runner should:
  // 1. Restore workflow state from checkpoint
  // 2. Allocate execution resources (workers, connections)
  // 3. Resume from the next pending task
  // 4. Mark execution as running
  //
  // ## State Restoration
  //
  // Runners MUST restore:
  // - All workflow variables and task state
  // - Execution position (which task to execute next)
  // - Original execution configuration and timeouts
  //
  // ## Idempotency
  //
  // Resuming an already-running execution should succeed (no-op).
  // Multiple resume requests should be safe.
  //
  // ## Use Cases
  //
  // 1. Resume overnight-paused development workflows
  // 2. Continue after manual approval granted
  // 3. Resume after dependency becomes available
  // 4. Continue after debugging session
  //
  // ## Error Handling
  //
  // Return gRPC errors for:
  // - NOT_FOUND: execution_id doesn't exist
  // - FAILED_PRECONDITION: Execution not in paused state
  // - UNIMPLEMENTED: Runner doesn't support pause/resume
  //
  // ## Example
  //
  // Request:
  // ```
  // execution_id: "wex-abc123def456"
  // reason: "Manual approval granted, resuming deployment"
  // ```
  //
  // Response: Empty (success)
  rpc resumeExecution(ResumeExecutionRequest) returns (google.protobuf.Empty);
}
