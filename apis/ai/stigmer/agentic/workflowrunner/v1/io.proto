syntax = "proto3";

// Package ai.stigmer.agentic.workflowrunner.v1 contains input/output messages
// for the workflow execution service interface.
//
// These messages define the data contracts between Stigmer's workflow orchestration
// layer and workflow-runner service. They are used throughout the workflow execution
// lifecycle: initiation, progress tracking, and control.
//
// ## Message Categories
//
// - **Execution Input**: WorkflowExecuteInput
// - **Execution Output**: WorkflowExecuteResponse, WorkflowProgressEvent
// - **Lifecycle Control**: CancelExecutionRequest, PauseExecutionRequest, ResumeExecutionRequest
// - **Error Reporting**: ErrorDetails
//
// ## Design Philosophy (Agent-Runner Pattern)
//
// Follows the same pattern as agent-runner for consistency:
// - **Temporal workflow** passes execution_id to runner
// - **Runner queries** Stigmer service to fetch WorkflowExecution details
// - **Runner converts** WorkflowSpec proto to YAML using converter
// - **Progressive updates** sent via gRPC during execution
//
// This pattern ensures:
// - Single source of truth (MongoDB)
// - Fresh data at execution time
// - Simple Temporal interface
// - Real-time status updates
package ai.stigmer.agentic.workflowrunner.v1;

import "buf/validate/validate.proto";

// WorkflowExecuteInput is the execution request passed to workflow-runner.
//
// Following the agent-runner pattern, this message contains only the execution ID.
// The runner queries Stigmer service to fetch the complete WorkflowExecution details,
// ensuring fresh data and single source of truth.
//
// ## Execution Flow (Polyglot Temporal Workflow)
//
// 1. **Stigmer service** creates WorkflowExecution in MongoDB
// 2. **Stigmer service** starts Temporal workflow with execution_id
// 3. **Temporal workflow** (Java) calls workflow-runner activity
// 4. **workflow-runner** (Go activity):
//    - Queries WorkflowExecution from Stigmer via gRPC
//    - Fetches WorkflowInstance and Workflow
//    - Converts WorkflowSpec proto → YAML (using Phase 2 converter)
//    - Executes via Zigflow
//    - Sends progressive status updates via gRPC
// 5. **Temporal workflow** receives final status (observability)
//
// ## Why This Pattern?
//
// ✅ **Consistent with agent-runner** - Same architecture
// ✅ **Single source of truth** - Always fresh from MongoDB
// ✅ **Simple interface** - Just pass execution_id
// ✅ **Progressive updates** - Real-time status via gRPC
// ✅ **Type-safe** - Uses proto → YAML converter
//
// ## Backward Compatibility
//
// The `workflow_yaml` field remains for direct testing/debugging.
// In production, runner uses execution_id to query everything.
message WorkflowExecuteInput {
  // Workflow execution ID to execute.
  //
  // Format: 'wfx-{ulid}' (e.g., 'wfx-01jbrxe9m7q8zn5v3c2k4g6w8t')
  // Generated by Stigmer backend when WorkflowExecution resource is created.
  //
  // ## What Happens Next
  //
  // 1. Runner queries WorkflowExecution from Stigmer service (gRPC)
  // 2. Runner extracts workflow_instance_id from WorkflowExecution.spec
  // 3. Runner queries WorkflowInstance to get workflow_id and environment_ids
  // 4. Runner queries Workflow to get WorkflowSpec (structured proto)
  // 5. Runner converts WorkflowSpec → YAML using proto_to_yaml converter
  // 6. Runner executes workflow via Zigflow
  // 7. Runner sends progressive status updates to Stigmer via gRPC
  //
  // ## Correlation
  //
  // This ID is used for:
  // - Querying WorkflowExecution from Stigmer
  // - Sending status updates during execution
  // - Log aggregation and debugging
  // - Temporal workflow observability
  //
  // Example: "wfx-01jbrxe9m7q8zn5v3c2k4g6w8t"
  string workflow_execution_id = 1 [(buf.validate.field).required = true];

  // Optional: Direct workflow YAML (for testing/debugging only).
  //
  // **Production use**: Leave empty, runner queries from Stigmer
  // **Testing use**: Provide YAML directly to bypass Stigmer query
  //
  // When empty, runner:
  // 1. Queries WorkflowExecution(execution_id) from Stigmer
  // 2. Fetches WorkflowInstance and Workflow
  // 3. Converts Workflow.spec → YAML
  //
  // When provided, runner uses this YAML directly (skip query).
  //
  // This is useful for:
  // - gRPC testing without full Stigmer setup
  // - Local development and debugging
  // - Golden tests with known YAML inputs
  //
  // Example:
  // ```yaml
  // document:
  //   dsl: "1.0.0"
  //   namespace: "test"
  //   name: "simple-workflow"
  //   version: "1.0.0"
  // do:
  //   - set:
  //       message: "Hello World"
  //     as: ${.}
  // ```
  string workflow_yaml = 2;
}

// WorkflowExecuteResponse confirms that workflow execution has started.
//
// This is the immediate response from the execute_async RPC. It provides
// metadata for tracking execution progress and accessing real-time status.
//
// ## Execution Lifecycle
//
// After receiving this response:
// 1. Stigmer stores execution metadata in WorkflowExecution resource
// 2. UI subscribes to subscribe_url for real-time updates (WebSocket/SSE)
// 3. Backend polls status_url periodically for final results
// 4. Progress events flow through Temporal workflows
//
// ## Response Time
//
// Runners SHOULD return this response within 1-2 seconds. The execute_async
// pattern means execution continues in the background after returning.
message WorkflowExecuteResponse {
  // Unique identifier for the workflow execution.
  //
  // Format: 'wex-{ulid}' (e.g., 'wex-01jbrxe9m7q8zn5v3c2k4g6w8t')
  //
  // This is the **same ID** from WorkflowExecuteInput.workflow_execution_id.
  // Runners MUST echo this ID back for correlation.
  //
  // Example: "wex-01jbrxe9m7q8zn5v3c2k4g6w8t"
  string workflow_execution_id = 1;

  // Initial execution status.
  //
  // Common initial status values:
  // - **pending**: Queued for execution, not started yet
  // - **running**: Execution started immediately
  //
  // Runners should return "running" if execution starts synchronously,
  // or "pending" if execution is queued (e.g., waiting for worker availability).
  //
  // Example: "running"
  string status = 2;

  // Human-readable message about execution initiation.
  //
  // This message confirms to users that execution started successfully.
  // It should be concise and user-friendly.
  //
  // Examples:
  // - "Workflow execution started successfully"
  // - "Execution queued, waiting for available worker"
  // - "Starting Terraform deployment workflow"
  //
  // Example: "Workflow execution started successfully"
  string message = 3;

  // Temporal workflow ID (runner-specific identifier).
  //
  // If the runner uses Temporal as its execution engine, this is the
  // Temporal workflow ID assigned to this execution.
  //
  // Format: Runner-specific (e.g., 'deploy-infrastructure-20250111-104530')
  //
  // ## Use Cases
  //
  // - Debugging: Look up execution in Temporal UI
  // - Direct control: Cancel/pause via Temporal CLI
  // - Metrics: Correlate Temporal metrics with Stigmer executions
  //
  // ## Other Runners
  //
  // Non-Temporal runners can use this field for their own execution IDs:
  // - Airflow: DAG run ID
  // - Custom: Internal execution reference
  //
  // Leave empty if not applicable.
  //
  // Example: "deploy-infrastructure-20250111-104530"
  string temporal_workflow_id = 4;

  // URL to subscribe to real-time progress updates (WebSocket or SSE).
  //
  // This URL provides a **streaming connection** for real-time progress events.
  // Clients can connect to receive WorkflowProgressEvent messages as they occur.
  //
  // ## Protocol
  //
  // Supported protocols:
  // - **WebSocket**: `wss://runner.example.com/ws/executions/{execution_id}`
  // - **Server-Sent Events (SSE)**: `https://runner.example.com/stream/executions/{execution_id}`
  //
  // ## Authentication
  //
  // URL may include authentication token:
  // - Query parameter: `wss://...?token=abc123`
  // - Header-based: Stigmer includes auth header when connecting
  //
  // ## Event Format
  //
  // Each event is a serialized WorkflowProgressEvent (JSON or protobuf).
  //
  // ## Connection Lifecycle
  //
  // - Client connects to URL
  // - Runner streams events until workflow completes
  // - Connection closes when workflow reaches terminal state (completed/failed/cancelled)
  //
  // ## Optional
  //
  // Not all runners support real-time streaming. Leave empty if not supported.
  //
  // Example: "wss://runner.example.com/ws/executions/wex-01jbrxe9m7q8zn5v3c2k4g6w8t"
  string subscribe_url = 5;

  // URL to poll execution status.
  //
  // This URL provides **point-in-time status** for the execution.
  // Clients can poll periodically to check completion status and results.
  //
  // ## HTTP Method
  //
  // GET request returns current execution status (JSON or protobuf).
  //
  // ## Response Format
  //
  // ```json
  // {
  //   "execution_id": "wex-01jbrxe9m7q8zn5v3c2k4g6w8t",
  //   "status": "running",
  //   "progress": 67,
  //   "message": "Deploying infrastructure...",
  //   "started_at": "2025-01-11T10:00:00Z",
  //   "updated_at": "2025-01-11T10:15:30Z"
  // }
  // ```
  //
  // ## Polling Strategy
  //
  // Stigmer backend polls with exponential backoff:
  // - Initial: Every 5 seconds
  // - After 1 minute: Every 15 seconds
  // - After 5 minutes: Every 60 seconds
  //
  // ## Authentication
  //
  // URL may require authentication (API key, OAuth token).
  //
  // ## Required
  //
  // All runners MUST provide this URL for status polling.
  //
  // Example: "https://runner.example.com/api/v1/executions/wex-01jbrxe9m7q8zn5v3c2k4g6w8t/status"
  string status_url = 6;
}

// CancelExecutionRequest requests cancellation of a running workflow execution.
//
// Cancellation is **best-effort** - runners should attempt graceful shutdown
// but may need to forcefully terminate if cleanup takes too long.
//
// ## Idempotency
//
// Cancelling an already-cancelled or completed execution is a **no-op** (succeeds silently).
// This makes it safe to retry cancel requests without side effects.
//
// ## Audit Trail
//
// Runners should log cancellation events including:
// - Who requested cancellation (inferred from auth context)
// - When cancellation was requested
// - Cancellation reason (from this request)
// - Whether force=true was used
//
// This audit information helps with debugging and compliance.
message CancelExecutionRequest {
  // Workflow execution ID to cancel.
  //
  // Format: 'wex-{ulid}' (e.g., 'wex-01jbrxe9m7q8zn5v3c2k4g6w8t')
  //
  // This is the same ID returned in WorkflowExecuteResponse.
  //
  // ## Error Cases
  //
  // Return gRPC errors for:
  // - **NOT_FOUND**: execution_id doesn't exist
  // - **FAILED_PRECONDITION**: Execution already completed/failed (cannot cancel)
  //
  // Return success (Empty) for:
  // - Already-cancelled executions (idempotent)
  //
  // Example: "wex-01jbrxe9m7q8zn5v3c2k4g6w8t"
  string execution_id = 1 [(buf.validate.field).required = true];

  // Human-readable reason for cancellation.
  //
  // This reason is recorded in audit logs and execution history.
  // It helps answer: "Why was this execution cancelled?"
  //
  // Common reasons:
  // - **User-initiated**: "User clicked cancel button in web console"
  // - **Timeout watchdog**: "Execution exceeded organization timeout policy"
  // - **Cost control**: "Execution cost exceeded budget threshold"
  // - **Deployment rollback**: "Cancelling in-progress deployment due to errors"
  // - **System maintenance**: "Draining runner for planned maintenance"
  //
  // ## Best Practices
  //
  // - Be specific (include who/what/why)
  // - Include context for debugging
  // - Avoid sensitive information
  //
  // Example: "User alice@acmecorp.com cancelled via web console"
  string reason = 2;

  // Force immediate termination without graceful cleanup.
  //
  // ## Graceful Cancellation (force=false, default)
  //
  // Runner should:
  // 1. Stop scheduling new tasks
  // 2. Wait for in-flight tasks to complete (with timeout)
  // 3. Clean up resources (close connections, delete temp files)
  // 4. Mark execution as cancelled
  //
  // Graceful timeout: 30 seconds (configurable per runner)
  //
  // ## Forced Cancellation (force=true)
  //
  // Runner should:
  // 1. Immediately terminate all tasks (SIGKILL)
  // 2. Skip cleanup (may leave incomplete work)
  // 3. Mark execution as cancelled
  //
  // ## When to Use Force
  //
  // - Stuck executions (graceful cancel hangs)
  // - Emergency situations (security incident, resource leak)
  // - Time-critical cancellations
  //
  // ## Trade-offs
  //
  // - **Graceful**: Safe, consistent state, slower
  // - **Forced**: Fast, may leave incomplete work, less safe
  //
  // Default: false (prefer graceful)
  //
  // Example: false (graceful cancellation)
  bool force = 3;
}

// PauseExecutionRequest requests suspension of a running workflow execution.
//
// Pausing preserves execution state for later resumption. This is useful for:
// - Cost optimization (pause overnight, resume in morning)
// - Manual intervention (pause for human approval)
// - Dependency waiting (pause until external system available)
// - Debugging (pause to inspect state)
//
// ## Runner Capability
//
// Not all runners support pause/resume:
// - ✅ **Supported**: Temporal, Airflow, custom state-based runners
// - ❌ **Not supported**: Serverless functions, stateless runners
//
// Runners without pause support should return gRPC error: **UNIMPLEMENTED**
//
// ## State Checkpoint
//
// Runners MUST checkpoint execution state including:
// - Workflow input and output variables
// - Task completion status and results
// - Current execution position (next task to execute)
// - Execution metadata and timestamps
//
// Runners MAY release:
// - Worker processes/threads
// - Network connections
// - Temporary compute resources
//
// ## Idempotency
//
// Pausing an already-paused execution is a **no-op** (succeeds silently).
message PauseExecutionRequest {
  // Workflow execution ID to pause.
  //
  // Format: 'wex-{ulid}' (e.g., 'wex-01jbrxe9m7q8zn5v3c2k4g6w8t')
  //
  // ## Error Cases
  //
  // Return gRPC errors for:
  // - **NOT_FOUND**: execution_id doesn't exist
  // - **FAILED_PRECONDITION**: Execution not in running state (already paused, completed, or failed)
  // - **UNIMPLEMENTED**: Runner doesn't support pause/resume
  //
  // Return success (Empty) for:
  // - Already-paused executions (idempotent)
  //
  // Example: "wex-01jbrxe9m7q8zn5v3c2k4g6w8t"
  string execution_id = 1 [(buf.validate.field).required = true];

  // Human-readable reason for pausing.
  //
  // This reason is recorded in audit logs and execution history.
  // It helps answer: "Why was this execution paused?"
  //
  // Common reasons:
  // - **Cost optimization**: "Pausing overnight to save compute costs"
  // - **Manual approval**: "Pausing for security team approval before production deployment"
  // - **Dependency wait**: "Pausing until database migration completes"
  // - **Debugging**: "Pausing to inspect intermediate state and logs"
  // - **Scheduled maintenance**: "Pausing before runner maintenance window"
  //
  // ## Best Practices
  //
  // - Be specific about pause reason
  // - Include expected resume condition if applicable
  // - Avoid sensitive information
  //
  // Examples:
  // - "Pausing overnight (8pm-8am) to reduce development costs"
  // - "Waiting for manual approval from security team before proceeding"
  string reason = 2;
}

// ResumeExecutionRequest requests continuation of a paused workflow execution.
//
// Resuming restores workflow state from checkpoint and continues execution
// from where it was paused.
//
// ## State Restoration
//
// Runners MUST restore:
// - All workflow variables and task state
// - Execution position (which task to execute next)
// - Original execution configuration (timeouts, resource limits)
// - Execution metadata and timestamps
//
// ## Execution Continuation
//
// After resume:
// 1. Execution picks up from the **next pending task**
// 2. Already-completed tasks are NOT re-executed
// 3. Timeouts continue from paused state (don't reset)
//
// ## Idempotency
//
// Resuming an already-running execution is a **no-op** (succeeds silently).
//
// ## Runner Capability
//
// Runners without pause/resume support should return: **UNIMPLEMENTED**
message ResumeExecutionRequest {
  // Workflow execution ID to resume.
  //
  // Format: 'wex-{ulid}' (e.g., 'wex-01jbrxe9m7q8zn5v3c2k4g6w8t')
  //
  // ## Error Cases
  //
  // Return gRPC errors for:
  // - **NOT_FOUND**: execution_id doesn't exist
  // - **FAILED_PRECONDITION**: Execution not in paused state (already running, completed, or failed)
  // - **UNIMPLEMENTED**: Runner doesn't support pause/resume
  //
  // Return success (Empty) for:
  // - Already-running executions (idempotent)
  //
  // Example: "wex-01jbrxe9m7q8zn5v3c2k4g6w8t"
  string execution_id = 1 [(buf.validate.field).required = true];

  // Human-readable reason for resuming.
  //
  // This reason is recorded in audit logs and execution history.
  // It helps answer: "Why was this execution resumed?"
  //
  // Common reasons:
  // - **Scheduled resume**: "Resuming after overnight pause (8am)"
  // - **Approval granted**: "Security team approved production deployment, resuming"
  // - **Dependency ready**: "Database migration completed, resuming workflow"
  // - **Debugging complete**: "Inspection complete, resuming execution"
  // - **Maintenance complete**: "Runner maintenance finished, resuming workflows"
  //
  // ## Best Practices
  //
  // - Reference the original pause reason if applicable
  // - Include who/what triggered the resume
  // - Avoid sensitive information
  //
  // Examples:
  // - "Resuming after overnight pause (8am scheduled resume)"
  // - "Manual approval granted by security-team@acmecorp.com"
  string reason = 2;
}
