syntax = "proto3";

package ai.stigmer.agentic.workflowexecution.v1;

// ExecutionPhase defines the lifecycle phase of a workflow execution.
//
// Workflow executions progress through distinct phases from creation to completion.
// Phases are used for:
// - UI status indicators (progress bars, badges, icons)
// - Filtering and querying executions (show only in-progress, show only failed)
// - Alerting and notifications (notify on failure, notify on completion)
// - Retry and recovery logic (retry failed executions)
// - Resource cleanup (delete completed executions after retention period)
//
// Phase Transitions:
//
// Normal flow:
// EXECUTION_PENDING → EXECUTION_IN_PROGRESS → EXECUTION_COMPLETED
//
// Failure flow:
// EXECUTION_PENDING → EXECUTION_IN_PROGRESS → EXECUTION_FAILED
//
// Cancellation flow:
// EXECUTION_PENDING → EXECUTION_CANCELLED
// EXECUTION_IN_PROGRESS → EXECUTION_CANCELLED
//
// Terminal States:
// - EXECUTION_COMPLETED: Workflow finished successfully
// - EXECUTION_FAILED: Workflow encountered an error
// - EXECUTION_CANCELLED: Workflow was stopped by user or system
//
// Once a workflow reaches a terminal state, it cannot transition to another phase.
enum ExecutionPhase {
  // Unspecified phase (invalid, should never be used).
  // Exists only for proto3 zero-value semantics.
  EXECUTION_PHASE_UNSPECIFIED = 0;

  // Execution created, waiting to start.
  //
  // The WorkflowExecution resource has been created but the workflow runner
  // (Temporal) has not yet picked it up for execution.
  //
  // Typical duration: < 1 second (unless workflow runner is overloaded)
  //
  // Next phases: EXECUTION_IN_PROGRESS, EXECUTION_CANCELLED
  EXECUTION_PENDING = 1;

  // Execution is actively running tasks.
  //
  // The workflow runner is processing tasks in the workflow definition.
  // Tasks may be executing sequentially, in parallel, or conditionally.
  //
  // While in this phase:
  // - tasks[] list is populated and updated as tasks progress
  // - Each task transitions through PENDING → IN_PROGRESS → COMPLETED/FAILED
  // - UI polls or receives WebSocket updates to show real-time progress
  //
  // Typical duration: Seconds to hours (depends on workflow complexity)
  //
  // Next phases: EXECUTION_COMPLETED, EXECUTION_FAILED, EXECUTION_CANCELLED
  EXECUTION_IN_PROGRESS = 2;

  // Execution completed successfully.
  //
  // All tasks in the workflow executed successfully.
  // The workflow produced a final output (if defined).
  //
  // Terminal state - execution will not change phases again.
  //
  // When this phase is reached:
  // - completed_at timestamp is set
  // - output field is populated (if workflow produces output)
  // - All tasks have status WORKFLOW_TASK_COMPLETED or WORKFLOW_TASK_SKIPPED
  //
  // Use Cases:
  // - Display success badge in UI
  // - Trigger downstream workflows (workflow chaining)
  // - Archive execution results
  // - Delete execution after retention period (e.g., 30 days)
  EXECUTION_COMPLETED = 3;

  // Execution failed with an error.
  //
  // One or more tasks failed, or the workflow encountered an unrecoverable error.
  //
  // Terminal state - execution will not change phases again.
  //
  // When this phase is reached:
  // - completed_at timestamp is set
  // - error field is populated with failure description
  // - At least one task has status WORKFLOW_TASK_FAILED
  //
  // Use Cases:
  // - Display error badge in UI
  // - Send failure alerts/notifications
  // - Trigger retry logic (if configured)
  // - Debug failed workflows (inspect tasks[], error messages)
  //
  // Common Failure Causes:
  // - Task timeout (task took longer than max allowed time)
  // - API call failed (external service returned error)
  // - Agent invocation failed (agent execution error)
  // - Validation error (invalid task input or output)
  // - Resource exhausted (quota exceeded, rate limited)
  EXECUTION_FAILED = 4;

  // Execution was cancelled by user or system.
  //
  // The workflow was explicitly stopped before completion.
  // Cancellation can happen in PENDING or IN_PROGRESS phases.
  //
  // Terminal state - execution will not change phases again.
  //
  // When this phase is reached:
  // - completed_at timestamp is set
  // - In-progress tasks are stopped (status changes to WORKFLOW_TASK_FAILED or remains IN_PROGRESS)
  // - Pending tasks remain in WORKFLOW_TASK_PENDING state
  //
  // Use Cases:
  // - User manually cancels execution from UI
  // - System cancels due to timeout (workflow-level timeout, not task-level)
  // - System cancels due to resource constraints (too many concurrent executions)
  // - Emergency stop for misbehaving workflows
  //
  // Cancellation vs Failure:
  // - Cancelled: User or system intentionally stopped the workflow
  // - Failed: Workflow encountered an error during execution
  EXECUTION_CANCELLED = 5;
}

// WorkflowTaskType defines the type of workflow task.
//
// Tasks are the atomic units of work within a workflow. Each task type has:
// - Specific input/output schema expectations
// - Specific execution behavior
// - Specific error handling and retry policies
//
// Task types enable workflows to orchestrate diverse operations:
// - Invoke AI agents with prompts
// - Call external APIs (REST, GraphQL, gRPC)
// - Wait for human approvals
// - Execute conditional branching
// - Run tasks in parallel
// - Transform data between tasks
// - Execute custom plugin logic
enum WorkflowTaskType {
  // Unspecified task type (invalid, should never be used).
  // Exists only for proto3 zero-value semantics.
  WORKFLOW_TASK_TYPE_UNSPECIFIED = 0;

  // Invoke an AI agent with a prompt.
  //
  // This task type calls an AgentInstance and waits for the agent execution to complete.
  //
  // Input Schema:
  // {
  //   "agent_instance_id": "agi-customer-support",
  //   "prompt": "Analyze this feedback: {{workflow.input.feedback}}",
  //   "max_tokens": 500,
  //   "temperature": 0.7
  // }
  //
  // Output Schema:
  // {
  //   "agent_execution_id": "agx-abc123",
  //   "response": "The customer feedback indicates...",
  //   "metadata": { "tokens_used": 450, "model": "gpt-4" }
  // }
  //
  // Use Cases:
  // - Content generation (write email, generate report)
  // - Data analysis (analyze customer feedback, classify support tickets)
  // - Decision making (should we approve this request?)
  // - Code generation (generate deployment script)
  //
  // Error Cases:
  // - Agent execution timeout
  // - Agent execution failed (prompt too long, API error)
  // - Agent not found (invalid agent_instance_id)
  WORKFLOW_TASK_AGENT_INVOCATION = 1;

  // Wait for human approval before proceeding.
  //
  // This task pauses the workflow and waits for one or more users to approve or reject.
  //
  // Input Schema:
  // {
  //   "approvers": ["usr-admin-1", "usr-admin-2"],
  //   "message": "Approve account creation for {{workflow.input.email}}?",
  //   "timeout_hours": 24,
  //   "require_all_approvers": false
  // }
  //
  // Output Schema:
  // {
  //   "approved": true,
  //   "approved_by": "usr-admin-1",
  //   "approved_at": "2025-01-11T15:22:33Z",
  //   "comment": "Looks good, approved"
  // }
  //
  // Use Cases:
  // - Manual approval gates (approve deployment, approve budget)
  // - Compliance workflows (legal review, security review)
  // - Escalation workflows (escalate to manager if amount > $10,000)
  //
  // Error Cases:
  // - Timeout (no approval received within timeout_hours)
  // - Rejected (approver explicitly rejected)
  // - Approver not found (invalid user ID)
  WORKFLOW_TASK_APPROVAL = 2;

  // Make an HTTP or gRPC API call to an external service.
  //
  // This task sends a request to an external API and captures the response.
  //
  // Input Schema:
  // {
  //   "method": "POST",
  //   "url": "https://api.stripe.com/v1/customers",
  //   "headers": {
  //     "Authorization": "Bearer {{env.STRIPE_API_KEY}}",
  //     "Content-Type": "application/json"
  //   },
  //   "body": {
  //     "email": "{{workflow.input.email}}",
  //     "name": "{{workflow.input.name}}"
  //   },
  //   "timeout_seconds": 30
  // }
  //
  // Output Schema:
  // {
  //   "status_code": 200,
  //   "headers": { "x-request-id": "req-xyz789" },
  //   "body": {
  //     "id": "cus-abc123",
  //     "email": "customer@example.com",
  //     "created": 1704988800
  //   }
  // }
  //
  // Use Cases:
  // - Create resources in external systems (create Stripe customer, create GitHub issue)
  // - Fetch data from APIs (get weather data, get stock prices)
  // - Send notifications (Slack, email, SMS)
  // - Trigger webhooks (notify external systems of workflow completion)
  //
  // Error Cases:
  // - Network error (connection timeout, DNS failure)
  // - HTTP error (4xx, 5xx status codes)
  // - Timeout (API took longer than timeout_seconds)
  // - Invalid response (malformed JSON, unexpected schema)
  WORKFLOW_TASK_API_CALL = 3;

  // Evaluate a condition and branch to different paths.
  //
  // This task evaluates a boolean expression and determines which tasks to execute next.
  //
  // Input Schema:
  // {
  //   "condition": "{{tasks.validate_email.output.valid}} == true",
  //   "if_true": ["task-create-account", "task-send-welcome"],
  //   "if_false": ["task-send-error-email"]
  // }
  //
  // Output Schema:
  // {
  //   "condition_result": true,
  //   "executed_branch": "if_true",
  //   "executed_tasks": ["task-create-account", "task-send-welcome"]
  // }
  //
  // Use Cases:
  // - Branching logic (if email is valid, create account; else send error)
  // - Feature flags (if beta_enabled, execute beta_tasks; else execute stable_tasks)
  // - Environment-specific behavior (if env == prod, use prod_config; else use dev_config)
  //
  // Error Cases:
  // - Invalid expression (syntax error in condition)
  // - Missing variables (referenced variable doesn't exist)
  WORKFLOW_TASK_CONDITIONAL = 4;

  // Execute multiple sub-tasks concurrently.
  //
  // This task spawns multiple tasks that run in parallel and waits for all to complete.
  //
  // Input Schema:
  // {
  //   "tasks": [
  //     { "task_id": "send-email", "task_type": "api_call", "input": {...} },
  //     { "task_id": "send-sms", "task_type": "api_call", "input": {...} },
  //     { "task_id": "send-slack", "task_type": "api_call", "input": {...} }
  //   ],
  //   "wait_for_all": true,
  //   "fail_on_any_failure": false
  // }
  //
  // Output Schema:
  // {
  //   "total_tasks": 3,
  //   "successful_tasks": 2,
  //   "failed_tasks": 1,
  //   "results": [
  //     { "task_id": "send-email", "status": "completed", "output": {...} },
  //     { "task_id": "send-sms", "status": "failed", "error": "..." },
  //     { "task_id": "send-slack", "status": "completed", "output": {...} }
  //   ]
  // }
  //
  // Use Cases:
  // - Fan-out operations (send notifications to multiple channels)
  // - Parallel data processing (process multiple files concurrently)
  // - Multi-region deployments (deploy to US, EU, APAC in parallel)
  //
  // Error Cases:
  // - One or more sub-tasks failed (if fail_on_any_failure is true)
  // - Timeout (sub-tasks took longer than allowed)
  WORKFLOW_TASK_PARALLEL = 5;

  // Transform data between tasks.
  //
  // This task applies transformations to data (map, filter, aggregate, format).
  //
  // Input Schema:
  // {
  //   "expression": "{{tasks.fetch_customers.output.customers | map('email')}}",
  //   "output_variable": "customer_emails"
  // }
  //
  // Output Schema:
  // {
  //   "result": ["customer1@example.com", "customer2@example.com", "customer3@example.com"]
  // }
  //
  // Use Cases:
  // - Data extraction (extract email addresses from customer objects)
  // - Data formatting (convert timestamps to different formats)
  // - Data aggregation (sum order totals, calculate averages)
  // - Data filtering (filter customers by region)
  //
  // Error Cases:
  // - Invalid expression (syntax error)
  // - Type mismatch (trying to apply number operation to string)
  WORKFLOW_TASK_TRANSFORM = 6;

  // Execute custom task logic defined by plugins.
  //
  // This task type allows extending workflows with custom business logic
  // that doesn't fit into other task types.
  //
  // Input Schema: Plugin-specific (defined by the custom plugin)
  // Output Schema: Plugin-specific (defined by the custom plugin)
  //
  // Use Cases:
  // - Domain-specific operations (calculate shipping costs, validate addresses)
  // - Integration with proprietary systems (legacy database queries)
  // - Complex business rules (pricing calculations, eligibility checks)
  //
  // Error Cases: Plugin-specific
  WORKFLOW_TASK_CUSTOM = 7;
}

// WorkflowTaskStatus defines the execution status of a workflow task.
//
// Tasks progress through statuses as the workflow executes.
// Task statuses are used for:
// - UI task lists (show checkmarks, spinners, error icons)
// - Progress calculation (completed_tasks / total_tasks)
// - Debugging failed workflows (which task failed, what was the error)
// - Retry logic (retry failed tasks)
//
// Status Transitions:
//
// Normal flow:
// WORKFLOW_TASK_PENDING → WORKFLOW_TASK_IN_PROGRESS → WORKFLOW_TASK_COMPLETED
//
// Failure flow:
// WORKFLOW_TASK_PENDING → WORKFLOW_TASK_IN_PROGRESS → WORKFLOW_TASK_FAILED
//
// Skip flow (conditional):
// WORKFLOW_TASK_PENDING → WORKFLOW_TASK_SKIPPED
enum WorkflowTaskStatus {
  // Unspecified status (invalid, should never be used).
  // Exists only for proto3 zero-value semantics.
  WORKFLOW_TASK_STATUS_UNSPECIFIED = 0;

  // Task is waiting to execute.
  //
  // The task has been created but has not started executing yet.
  // This happens when:
  // - Task dependencies have not completed (waiting for previous tasks)
  // - Workflow is in EXECUTION_PENDING phase (not started yet)
  // - Task is queued behind other tasks (sequential execution)
  //
  // While in this status:
  // - started_at and completed_at are not set
  // - input is populated (task knows what it will execute)
  // - output is not populated (task hasn't executed yet)
  //
  // Next statuses: WORKFLOW_TASK_IN_PROGRESS, WORKFLOW_TASK_SKIPPED
  WORKFLOW_TASK_PENDING = 1;

  // Task is currently executing.
  //
  // The workflow runner is actively processing this task.
  // The task is performing its specific operation:
  // - Calling an API
  // - Invoking an agent
  // - Waiting for approval
  // - Transforming data
  //
  // While in this status:
  // - started_at is set
  // - completed_at is not set
  // - output is not populated yet (waiting for task to finish)
  //
  // Typical duration: Milliseconds to hours (depends on task type)
  // - API calls: < 10 seconds
  // - Agent invocations: 10-60 seconds
  // - Approvals: Hours to days
  //
  // Next statuses: WORKFLOW_TASK_COMPLETED, WORKFLOW_TASK_FAILED
  WORKFLOW_TASK_IN_PROGRESS = 2;

  // Task finished successfully.
  //
  // The task executed its operation and produced a successful result.
  //
  // When this status is reached:
  // - completed_at is set
  // - output is populated with task results
  // - error is not set
  //
  // Next statuses: None (terminal state for this task)
  WORKFLOW_TASK_COMPLETED = 3;

  // Task failed during execution.
  //
  // The task encountered an error and could not complete successfully.
  //
  // When this status is reached:
  // - completed_at is set
  // - error is populated with failure description
  // - output is not populated (task didn't produce valid output)
  //
  // Common Failure Causes by Task Type:
  //
  // WORKFLOW_TASK_API_CALL:
  // - Network timeout
  // - HTTP 4xx/5xx errors
  // - Invalid response format
  //
  // WORKFLOW_TASK_AGENT_INVOCATION:
  // - Agent execution timeout
  // - Agent execution error
  // - Prompt too long (exceeds token limit)
  //
  // WORKFLOW_TASK_APPROVAL:
  // - Timeout (no approval within timeout_hours)
  // - Explicit rejection
  //
  // WORKFLOW_TASK_TRANSFORM:
  // - Invalid expression syntax
  // - Type mismatch
  //
  // Impact:
  // - If task fails, workflow phase changes to EXECUTION_FAILED (unless error handling is configured)
  // - Failed tasks can be retried (if retry policy is configured)
  //
  // Next statuses: None (terminal state for this task)
  WORKFLOW_TASK_FAILED = 4;

  // Task was skipped due to conditional logic.
  //
  // The task was not executed because a conditional task determined it should be skipped.
  //
  // When this status is reached:
  // - started_at is not set (task never started)
  // - completed_at may be set (time when skip was determined)
  // - output is not populated (task didn't execute)
  // - error is not set (skip is not an error)
  //
  // Example:
  // Conditional task: if email_valid == false, skip "create_account" task
  //
  // Impact:
  // - Skipped tasks don't cause workflow failure
  // - Skipped tasks count toward completed_tasks (for progress calculation)
  //
  // Next statuses: None (terminal state for this task)
  WORKFLOW_TASK_SKIPPED = 5;
}
