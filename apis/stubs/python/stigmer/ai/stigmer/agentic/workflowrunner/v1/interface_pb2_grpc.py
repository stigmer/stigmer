# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from ai.stigmer.agentic.workflowrunner.v1 import io_pb2 as ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2
from google.protobuf import empty_pb2 as google_dot_protobuf_dot_empty__pb2


class WorkflowRunnerServiceControllerStub(object):
    """WorkflowRunnerServiceController defines the service interface that all workflow
    execution engines must implement to integrate with Stigmer.

    This is the core contract enabling pluggable workflow execution backends.
    Runners can be anything from managed services (Temporal Cloud, Airflow) to
    custom in-house execution engines.

    ## Integration Model

    When registering a WorkflowRunner resource (future capability), users provide:
    - Endpoint URL implementing this service interface
    - Authentication credentials (API keys, mTLS certs)
    - Capabilities (supports pause/resume, resource limits, etc.)

    Stigmer validates runner health by calling a health check endpoint and routes
    workflow executions based on runner capabilities and availability.

    ## Execution Flow

    1. User creates WorkflowExecution resource in Stigmer
    2. Stigmer backend selects appropriate runner based on requirements
    3. Stigmer calls runner's execute_async RPC with complete execution context
    4. Runner starts execution and returns immediately with execution ID
    5. Progress tracking happens through Temporal workflows/flows
    6. Final results stored in WorkflowExecution.status

    ## Authorization

    Authorization for these RPCs is NOT handled through Stigmer's IAM policy system
    because runners are external services. Instead, runners authenticate via:
    - API keys in request headers
    - Mutual TLS certificates
    - Cloud provider IAM (for managed services)

    Runner endpoints should be secured and only accessible to Stigmer backend services.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.executeAsync = channel.unary_unary(
                '/ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController/executeAsync',
                request_serializer=ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.WorkflowExecuteInput.SerializeToString,
                response_deserializer=ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.WorkflowExecuteResponse.FromString,
                _registered_method=True)
        self.cancelExecution = channel.unary_unary(
                '/ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController/cancelExecution',
                request_serializer=ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.CancelExecutionRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                _registered_method=True)
        self.pauseExecution = channel.unary_unary(
                '/ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController/pauseExecution',
                request_serializer=ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.PauseExecutionRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                _registered_method=True)
        self.resumeExecution = channel.unary_unary(
                '/ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController/resumeExecution',
                request_serializer=ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.ResumeExecutionRequest.SerializeToString,
                response_deserializer=google_dot_protobuf_dot_empty__pb2.Empty.FromString,
                _registered_method=True)


class WorkflowRunnerServiceControllerServicer(object):
    """WorkflowRunnerServiceController defines the service interface that all workflow
    execution engines must implement to integrate with Stigmer.

    This is the core contract enabling pluggable workflow execution backends.
    Runners can be anything from managed services (Temporal Cloud, Airflow) to
    custom in-house execution engines.

    ## Integration Model

    When registering a WorkflowRunner resource (future capability), users provide:
    - Endpoint URL implementing this service interface
    - Authentication credentials (API keys, mTLS certs)
    - Capabilities (supports pause/resume, resource limits, etc.)

    Stigmer validates runner health by calling a health check endpoint and routes
    workflow executions based on runner capabilities and availability.

    ## Execution Flow

    1. User creates WorkflowExecution resource in Stigmer
    2. Stigmer backend selects appropriate runner based on requirements
    3. Stigmer calls runner's execute_async RPC with complete execution context
    4. Runner starts execution and returns immediately with execution ID
    5. Progress tracking happens through Temporal workflows/flows
    6. Final results stored in WorkflowExecution.status

    ## Authorization

    Authorization for these RPCs is NOT handled through Stigmer's IAM policy system
    because runners are external services. Instead, runners authenticate via:
    - API keys in request headers
    - Mutual TLS certificates
    - Cloud provider IAM (for managed services)

    Runner endpoints should be secured and only accessible to Stigmer backend services.
    """

    def executeAsync(self, request, context):
        """Execute workflow asynchronously (fire-and-forget pattern).

        This is the primary RPC for workflow execution. It accepts a complete
        execution context (workflow YAML, environment variables, metadata) and
        starts execution asynchronously.

        ## Execution Semantics

        The runner MUST:
        - Validate workflow YAML syntax
        - Start execution in the background
        - Return immediately with execution metadata
        - Track progress independently
        - Handle failures and retries according to workflow definition

        The runner SHOULD:
        - Store execution state for resumability
        - Emit progress events to Stigmer via callbacks
        - Support graceful cancellation
        - Enforce resource limits if specified

        ## Input Validation

        Runners should validate:
        - workflow_execution_id is present and unique
        - workflow_yaml is valid CNCF Serverless Workflow syntax
        - env_vars don't contain malicious values
        - config.max_timeout_seconds is within runner's limits

        ## Use Cases

        1. **Deploy Infrastructure**: Workflow orchestrates Terraform/Pulumi runs
        2. **Data Pipeline**: Workflow coordinates ETL tasks across services
        3. **Multi-Agent Coordination**: Workflow executes agent collaboration tasks
        4. **Integration Testing**: Workflow runs end-to-end test scenarios
        5. **Incident Response**: Workflow automates runbook execution

        ## Error Handling

        Return gRPC errors for:
        - INVALID_ARGUMENT: Malformed workflow YAML or missing required fields
        - RESOURCE_EXHAUSTED: Runner at capacity, cannot accept new executions
        - UNAVAILABLE: Runner temporarily unavailable (maintenance, overload)
        - INTERNAL: Unexpected runner failure

        Do NOT return errors for workflow execution failures (tasks failing, timeouts).
        Those should be tracked in progress events and final status.

        ## Example

        Input:
        ```
        workflow_execution_id: "wex-abc123def456"
        workflow_yaml: |
        name: deploy-infrastructure
        version: 1.0.0
        start: validate-config
        states:
        - name: validate-config
        type: operation
        actions:
        - name: check-terraform
        functionRef: validate-terraform
        env_vars: {
        "AWS_REGION": "us-east-1",
        "ENVIRONMENT": "production"
        }
        config: {
        max_timeout_seconds: 3600
        debug_enabled: false
        }
        ```

        Response:
        ```
        workflow_execution_id: "wex-abc123def456"
        status: "running"
        message: "Workflow execution started successfully"
        temporal_workflow_id: "deploy-infrastructure-20250111-104530"
        subscribe_url: "wss://runner.example.com/ws/wex-abc123def456"
        status_url: "https://runner.example.com/api/v1/executions/wex-abc123def456"
        ```
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def cancelExecution(self, request, context):
        """Cancel a running workflow execution.

        Requests graceful cancellation of an in-progress workflow. The runner should:
        1. Mark execution as cancelling
        2. Stop scheduling new tasks
        3. Wait for in-flight tasks to complete (unless force=true)
        4. Clean up resources (temporary files, locks, connections)
        5. Mark execution as cancelled

        ## Graceful vs Forced Cancellation

        - **Graceful** (force=false): Allow current tasks to complete, then stop
        - **Forced** (force=true): Terminate immediately, may leave incomplete work

        Runners should default to graceful cancellation for data consistency.

        ## Idempotency

        Cancelling an already-cancelled or completed execution should succeed (no-op).
        Multiple cancel requests for the same execution_id should be safe.

        ## Use Cases

        1. User manually cancels long-running workflow via UI
        2. Timeout watchdog cancels stuck executions
        3. Cost control system cancels expensive workflows
        4. Deployment rollback cancels in-progress infrastructure changes

        ## Error Handling

        Return gRPC errors for:
        - NOT_FOUND: execution_id doesn't exist
        - FAILED_PRECONDITION: Execution already completed/failed (cannot cancel)

        Do NOT return errors if execution is already cancelled (idempotent success).

        ## Example

        Request:
        ```
        execution_id: "wex-abc123def456"
        reason: "User requested cancellation via web console"
        force: false
        ```

        Response: Empty (success)
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def pauseExecution(self, request, context):
        """Pause a running workflow execution.

        Suspends workflow execution while preserving state for later resumption.
        The runner should:
        1. Complete currently-executing tasks
        2. Checkpoint workflow state (variables, task status)
        3. Release execution resources (workers, locks)
        4. Mark execution as paused

        ## State Preservation

        Runners MUST preserve:
        - Workflow input and output variables
        - Task completion status
        - Execution metadata and timestamps
        - Pending task queue

        Runners MAY release:
        - Worker processes/threads
        - Network connections
        - Temporary compute resources

        ## Use Cases

        1. Cost optimization: Pause development workflows overnight
        2. Manual intervention: Pause for human approval before proceeding
        3. Dependency wait: Pause until external system is available
        4. Debugging: Pause execution to inspect state

        ## Runner Capability

        Not all runners support pause/resume (e.g., serverless functions).
        Runners should return UNIMPLEMENTED if pause is not supported.

        ## Error Handling

        Return gRPC errors for:
        - NOT_FOUND: execution_id doesn't exist
        - FAILED_PRECONDITION: Execution not in running state
        - UNIMPLEMENTED: Runner doesn't support pause/resume

        ## Example

        Request:
        ```
        execution_id: "wex-abc123def456"
        reason: "Pausing for manual approval of infrastructure changes"
        ```

        Response: Empty (success)
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def resumeExecution(self, request, context):
        """Resume a paused workflow execution.

        Restores workflow execution from paused state. The runner should:
        1. Restore workflow state from checkpoint
        2. Allocate execution resources (workers, connections)
        3. Resume from the next pending task
        4. Mark execution as running

        ## State Restoration

        Runners MUST restore:
        - All workflow variables and task state
        - Execution position (which task to execute next)
        - Original execution configuration and timeouts

        ## Idempotency

        Resuming an already-running execution should succeed (no-op).
        Multiple resume requests should be safe.

        ## Use Cases

        1. Resume overnight-paused development workflows
        2. Continue after manual approval granted
        3. Resume after dependency becomes available
        4. Continue after debugging session

        ## Error Handling

        Return gRPC errors for:
        - NOT_FOUND: execution_id doesn't exist
        - FAILED_PRECONDITION: Execution not in paused state
        - UNIMPLEMENTED: Runner doesn't support pause/resume

        ## Example

        Request:
        ```
        execution_id: "wex-abc123def456"
        reason: "Manual approval granted, resuming deployment"
        ```

        Response: Empty (success)
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_WorkflowRunnerServiceControllerServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'executeAsync': grpc.unary_unary_rpc_method_handler(
                    servicer.executeAsync,
                    request_deserializer=ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.WorkflowExecuteInput.FromString,
                    response_serializer=ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.WorkflowExecuteResponse.SerializeToString,
            ),
            'cancelExecution': grpc.unary_unary_rpc_method_handler(
                    servicer.cancelExecution,
                    request_deserializer=ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.CancelExecutionRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
            'pauseExecution': grpc.unary_unary_rpc_method_handler(
                    servicer.pauseExecution,
                    request_deserializer=ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.PauseExecutionRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
            'resumeExecution': grpc.unary_unary_rpc_method_handler(
                    servicer.resumeExecution,
                    request_deserializer=ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.ResumeExecutionRequest.FromString,
                    response_serializer=google_dot_protobuf_dot_empty__pb2.Empty.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class WorkflowRunnerServiceController(object):
    """WorkflowRunnerServiceController defines the service interface that all workflow
    execution engines must implement to integrate with Stigmer.

    This is the core contract enabling pluggable workflow execution backends.
    Runners can be anything from managed services (Temporal Cloud, Airflow) to
    custom in-house execution engines.

    ## Integration Model

    When registering a WorkflowRunner resource (future capability), users provide:
    - Endpoint URL implementing this service interface
    - Authentication credentials (API keys, mTLS certs)
    - Capabilities (supports pause/resume, resource limits, etc.)

    Stigmer validates runner health by calling a health check endpoint and routes
    workflow executions based on runner capabilities and availability.

    ## Execution Flow

    1. User creates WorkflowExecution resource in Stigmer
    2. Stigmer backend selects appropriate runner based on requirements
    3. Stigmer calls runner's execute_async RPC with complete execution context
    4. Runner starts execution and returns immediately with execution ID
    5. Progress tracking happens through Temporal workflows/flows
    6. Final results stored in WorkflowExecution.status

    ## Authorization

    Authorization for these RPCs is NOT handled through Stigmer's IAM policy system
    because runners are external services. Instead, runners authenticate via:
    - API keys in request headers
    - Mutual TLS certificates
    - Cloud provider IAM (for managed services)

    Runner endpoints should be secured and only accessible to Stigmer backend services.
    """

    @staticmethod
    def executeAsync(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController/executeAsync',
            ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.WorkflowExecuteInput.SerializeToString,
            ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.WorkflowExecuteResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def cancelExecution(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController/cancelExecution',
            ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.CancelExecutionRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def pauseExecution(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController/pauseExecution',
            ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.PauseExecutionRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def resumeExecution(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController/resumeExecution',
            ai_dot_stigmer_dot_agentic_dot_workflowrunner_dot_v1_dot_io__pb2.ResumeExecutionRequest.SerializeToString,
            google_dot_protobuf_dot_empty__pb2.Empty.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
