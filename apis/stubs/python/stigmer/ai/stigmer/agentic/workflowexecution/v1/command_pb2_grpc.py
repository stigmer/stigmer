# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from ai.stigmer.agentic.workflowexecution.v1 import api_pb2 as ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2
from ai.stigmer.agentic.workflowexecution.v1 import command_pb2 as ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_command__pb2
from ai.stigmer.commons.apiresource import io_pb2 as ai_dot_stigmer_dot_commons_dot_apiresource_dot_io__pb2


class WorkflowExecutionCommandControllerStub(object):
    """WorkflowExecutionCommandController handles write operations (Create, Update, Delete) for WorkflowExecution resources.

    This service follows the Command-Query Separation (CQS) pattern:
    - CommandController: Write operations (create, update, delete)
    - QueryController: Read operations (get, list, search)

    Authorization:
    All RPCs use custom authorization logic implemented in middleware.
    Custom authorization is needed because:
    - create: Must verify user has "execute" permission on the referenced WorkflowInstance
    - update: Only the workflow runner (system) can update execution status, not users

    Service Options:
    - api_resource_kind: workflow_execution - Links this service to the WorkflowExecution resource
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.create = channel.unary_unary(
                '/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController/create',
                request_serializer=ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.SerializeToString,
                response_deserializer=ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.FromString,
                _registered_method=True)
        self.update = channel.unary_unary(
                '/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController/update',
                request_serializer=ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.SerializeToString,
                response_deserializer=ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.FromString,
                _registered_method=True)
        self.updateStatus = channel.unary_unary(
                '/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController/updateStatus',
                request_serializer=ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_command__pb2.WorkflowExecutionUpdateStatusInput.SerializeToString,
                response_deserializer=ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.FromString,
                _registered_method=True)
        self.delete = channel.unary_unary(
                '/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController/delete',
                request_serializer=ai_dot_stigmer_dot_commons_dot_apiresource_dot_io__pb2.ApiResourceId.SerializeToString,
                response_deserializer=ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.FromString,
                _registered_method=True)


class WorkflowExecutionCommandControllerServicer(object):
    """WorkflowExecutionCommandController handles write operations (Create, Update, Delete) for WorkflowExecution resources.

    This service follows the Command-Query Separation (CQS) pattern:
    - CommandController: Write operations (create, update, delete)
    - QueryController: Read operations (get, list, search)

    Authorization:
    All RPCs use custom authorization logic implemented in middleware.
    Custom authorization is needed because:
    - create: Must verify user has "execute" permission on the referenced WorkflowInstance
    - update: Only the workflow runner (system) can update execution status, not users

    Service Options:
    - api_resource_kind: workflow_execution - Links this service to the WorkflowExecution resource
    """

    def create(self, request, context):
        """Create and trigger a new workflow execution.

        This RPC creates a WorkflowExecution resource and immediately triggers it for execution.
        The workflow execution engine (Temporal) picks up the execution and begins processing tasks.

        Input Validation:
        - metadata.owner_scope must be ORGANIZATION or IDENTITY_ACCOUNT (not PLATFORM)
        - spec.workflow_instance_id is required and must reference an existing WorkflowInstance
        - api_version must be exactly "agentic.stigmer.ai/v1"
        - kind must be exactly "WorkflowExecution"

        Authorization:
        Custom authorization verifies:
        1. User has "execute" permission on the referenced WorkflowInstance
        2. User has access to all referenced Environments (from WorkflowInstance)
        3. User has access to all referenced Secrets (from runtime_env secret_refs)

        Execution Flow:
        1. Validate input (proto validation + business rules)
        2. Check authorization (user can execute WorkflowInstance)
        3. Create WorkflowExecution resource in database
        4. Set initial status.phase = EXECUTION_PENDING
        5. Trigger workflow in execution engine (Temporal)
        6. Return WorkflowExecution with status.phase = EXECUTION_PENDING or EXECUTION_IN_PROGRESS

        Status After Create:
        - status.phase: EXECUTION_PENDING (or EXECUTION_IN_PROGRESS if already picked up)
        - status.audit.created_at: Current timestamp
        - status.audit.created_by: Authenticated user ID
        - status.started_at: Not set yet (set when phase transitions to IN_PROGRESS)

        Use Cases:

        1. API-Triggered Execution:
        - User calls API to execute a workflow
        - Input: WorkflowExecution with spec.workflow_instance_id and spec.trigger_message
        - Output: WorkflowExecution with generated ID and PENDING status

        2. Webhook-Triggered Execution:
        - External system (Stripe, GitHub, etc.) sends webhook
        - Webhook handler creates WorkflowExecution with webhook payload in spec.trigger_message
        - spec.trigger_metadata captures webhook source, event type, timestamp

        3. Scheduled Execution:
        - Scheduler service creates WorkflowExecution at scheduled time
        - spec.trigger_metadata includes schedule ID and cron expression

        4. UI-Triggered Execution:
        - User clicks "Execute" button in web console
        - UI creates WorkflowExecution with user-provided inputs

        5. Workflow Chaining (Workflow A triggers Workflow B):
        - Workflow A completes, creates WorkflowExecution for Workflow B
        - spec.trigger_message contains output from Workflow A
        - spec.trigger_metadata includes parent workflow execution ID

        Error Cases:

        - INVALID_ARGUMENT:
        - workflow_instance_id is missing or invalid
        - owner_scope is PLATFORM (not allowed)
        - api_version or kind is incorrect

        - PERMISSION_DENIED:
        - User doesn't have "execute" permission on WorkflowInstance
        - User doesn't have access to referenced Environments
        - User doesn't have access to referenced Secrets

        - NOT_FOUND:
        - Referenced WorkflowInstance doesn't exist
        - Referenced Environment doesn't exist
        - Referenced Secret doesn't exist

        - FAILED_PRECONDITION:
        - WorkflowInstance is in invalid state (e.g., archived, disabled)
        - Too many concurrent executions (quota exceeded)

        Example Request:
        {
        "api_version": "agentic.stigmer.ai/v1",
        "kind": "WorkflowExecution",
        "metadata": {
        "name": "customer-onboarding-20250111-143022",
        "owner_scope": 2  // ORGANIZATION
        },
        "spec": {
        "workflow_instance_id": "wfi-customer-onboarding-prod",
        "trigger_message": "New signup: john.doe@example.com",
        "trigger_metadata": {
        "source": "api",
        "caller_id": "usr-jane-admin",
        "timestamp": "2025-01-11T14:30:22Z"
        },
        "runtime_env": {
        "CUSTOMER_EMAIL": { "value": "john.doe@example.com" }
        }
        }
        }

        Example Response:
        {
        "api_version": "agentic.stigmer.ai/v1",
        "kind": "WorkflowExecution",
        "metadata": {
        "id": "wfx-abc123xyz456",  // Auto-generated
        "name": "customer-onboarding-20250111-143022",
        "owner_scope": 2
        },
        "spec": { ... },  // Same as request
        "status": {
        "phase": 1,  // EXECUTION_PENDING
        "audit": {
        "created_at": "2025-01-11T14:30:22Z",
        "created_by": "usr-jane-admin"
        }
        }
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def update(self, request, context):
        """Update execution with full state.
        Used by users to update execution configuration (spec fields).
        No individual field updates - always provide complete state.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def updateStatus(self, request, context):
        """Update execution status during workflow execution.
        Used by workflow-runner to send progressive status updates (messages, task states, phase, etc.)
        This RPC is optimized for frequent status updates and merges status fields with existing state.

        This RPC is used by the workflow execution engine (Temporal) to update the status
        of a running workflow execution. Users cannot call this RPC directly.

        What Can Be Updated:
        - status.phase (PENDING → IN_PROGRESS → COMPLETED/FAILED/CANCELLED)
        - status.tasks (update task statuses, outputs, errors)
        - status.output (set final workflow output when COMPLETED)
        - status.error (set error message when FAILED)
        - status.started_at (set when execution starts)
        - status.completed_at (set when execution finishes)

        What Cannot Be Updated:
        - spec.* (user inputs are immutable after creation)
        - metadata.id (resource ID is immutable)
        - status.audit.created_at (creation timestamp is immutable)

        Authorization:
        Custom authorization verifies:
        1. Caller is the workflow runner service (system identity, not a user)
        2. Only status fields are being modified (spec and metadata unchanged)

        Update Flow:
        1. Workflow runner executes a task
        2. Task completes/fails
        3. Workflow runner calls updateStatus() with:
        - Updated status.tasks (new task status, output/error)
        - Updated status.phase (if all tasks done)
        4. Backend validates and persists update
        5. Backend broadcasts update via WebSocket (for real-time UI updates)

        Use Cases:

        1. Task Started:
        - Workflow runner updates status.tasks[i].status = IN_PROGRESS

        2. Task Completed:
        - Workflow runner updates status.tasks[i].status = COMPLETED
        - Workflow runner sets status.tasks[i].output

        3. Task Failed:
        - Workflow runner updates status.tasks[i].status = FAILED
        - Workflow runner sets status.tasks[i].error
        - Workflow runner updates status.phase = EXECUTION_FAILED
        - Workflow runner sets status.error
        - Workflow runner sets status.completed_at

        4. Workflow Completed:
        - Workflow runner updates status.phase = EXECUTION_COMPLETED
        - Workflow runner sets status.output
        - Workflow runner sets status.completed_at

        5. Workflow Cancelled:
        - Workflow runner receives cancellation signal
        - Workflow runner updates status.phase = EXECUTION_CANCELLED
        - Workflow runner sets status.completed_at

        Error Cases:

        - PERMISSION_DENIED:
        - Caller is not the workflow runner service (users cannot update status)

        - INVALID_ARGUMENT:
        - Trying to modify spec or metadata (only status can be updated)
        - Invalid phase transition (e.g., COMPLETED → IN_PROGRESS)

        - NOT_FOUND:
        - WorkflowExecution with given ID doesn't exist

        Example Request (Task Completed):
        {
        "metadata": {
        "id": "wfx-abc123xyz456"
        },
        "status": {
        "phase": 2,  // EXECUTION_IN_PROGRESS
        "completed_tasks": 1,
        "tasks": [
        {
        "task_id": "task-1",
        "task_name": "validate_email",
        "status": 3,  // WORKFLOW_TASK_COMPLETED
        "output": { "valid": true },
        "completed_at": "2025-01-11T14:30:27Z"
        },
        {
        "task_id": "task-2",
        "task_name": "create_account",
        "status": 2,  // WORKFLOW_TASK_IN_PROGRESS
        "timestamp": "2025-01-11T14:30:27Z"
        }
        ]
        }
        }
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def delete(self, request, context):
        """Delete an execution.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_WorkflowExecutionCommandControllerServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'create': grpc.unary_unary_rpc_method_handler(
                    servicer.create,
                    request_deserializer=ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.FromString,
                    response_serializer=ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.SerializeToString,
            ),
            'update': grpc.unary_unary_rpc_method_handler(
                    servicer.update,
                    request_deserializer=ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.FromString,
                    response_serializer=ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.SerializeToString,
            ),
            'updateStatus': grpc.unary_unary_rpc_method_handler(
                    servicer.updateStatus,
                    request_deserializer=ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_command__pb2.WorkflowExecutionUpdateStatusInput.FromString,
                    response_serializer=ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.SerializeToString,
            ),
            'delete': grpc.unary_unary_rpc_method_handler(
                    servicer.delete,
                    request_deserializer=ai_dot_stigmer_dot_commons_dot_apiresource_dot_io__pb2.ApiResourceId.FromString,
                    response_serializer=ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class WorkflowExecutionCommandController(object):
    """WorkflowExecutionCommandController handles write operations (Create, Update, Delete) for WorkflowExecution resources.

    This service follows the Command-Query Separation (CQS) pattern:
    - CommandController: Write operations (create, update, delete)
    - QueryController: Read operations (get, list, search)

    Authorization:
    All RPCs use custom authorization logic implemented in middleware.
    Custom authorization is needed because:
    - create: Must verify user has "execute" permission on the referenced WorkflowInstance
    - update: Only the workflow runner (system) can update execution status, not users

    Service Options:
    - api_resource_kind: workflow_execution - Links this service to the WorkflowExecution resource
    """

    @staticmethod
    def create(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController/create',
            ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.SerializeToString,
            ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def update(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController/update',
            ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.SerializeToString,
            ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def updateStatus(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController/updateStatus',
            ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_command__pb2.WorkflowExecutionUpdateStatusInput.SerializeToString,
            ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def delete(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController/delete',
            ai_dot_stigmer_dot_commons_dot_apiresource_dot_io__pb2.ApiResourceId.SerializeToString,
            ai_dot_stigmer_dot_agentic_dot_workflowexecution_dot_v1_dot_api__pb2.WorkflowExecution.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
