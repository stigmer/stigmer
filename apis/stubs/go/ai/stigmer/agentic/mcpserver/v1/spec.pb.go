// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: ai/stigmer/agentic/mcpserver/v1/spec.proto

package mcpserverv1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	v1 "github.com/stigmer/stigmer/apis/stubs/go/ai/stigmer/agentic/environment/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// McpServerSpec defines the configuration template for an MCP server.
// This is a reusable definition that can be referenced by multiple agents.
// Actual secrets/credentials are provided at runtime via AgentInstance's environment.
//
// MCP (Model Context Protocol) servers provide tools and capabilities to AI agents.
// This spec declares the server type, connection details, and required environment variables.
type McpServerSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Human-readable description for marketplace display and documentation.
	// Should explain what this MCP server does and its primary use cases.
	// Example: "GitHub MCP server for repository operations, code search, and PR management"
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// Icon URL for UI display in marketplace and agent configuration screens.
	// Should be a publicly accessible URL to an image (SVG, PNG, or JPEG).
	// Example: "https://github.githubassets.com/favicons/favicon.svg"
	IconUrl string `protobuf:"bytes,2,opt,name=icon_url,json=iconUrl,proto3" json:"icon_url,omitempty"`
	// Categorization tags for discoverability in the marketplace.
	// Use lowercase, hyphenated tags that describe the server's domain and capabilities.
	// Examples: ["git", "vcs", "code-analysis"], ["aws", "cloud", "infrastructure"]
	Tags []string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty"`
	// Server type and transport configuration.
	// Exactly one must be specified based on how the MCP server communicates.
	//
	// Types that are valid to be assigned to ServerType:
	//
	//	*McpServerSpec_Stdio
	//	*McpServerSpec_Http
	//	*McpServerSpec_Docker
	ServerType isMcpServerSpec_ServerType `protobuf_oneof:"server_type"`
	// Default tools to enable from this MCP server.
	// Empty list means all tools are enabled by default.
	// When specified, only these tools will be available unless overridden in McpServerUsage.
	// Tool names must match exactly what the MCP server reports via tools/list.
	// Examples: ["create_pull_request", "search_code", "get_file_contents"]
	DefaultEnabledTools []string `protobuf:"bytes,7,rep,name=default_enabled_tools,json=defaultEnabledTools,proto3" json:"default_enabled_tools,omitempty"`
	// Environment specification declaring required environment variables.
	// This defines the SCHEMA of required env vars - actual values are provided
	// at runtime via AgentInstance's environment_ref.
	//
	// Use this to declare what environment variables the MCP server needs,
	// whether they are secrets (e.g., API tokens), and their descriptions.
	// Values in this spec can be empty - they serve as documentation and validation.
	//
	// Example:
	//
	//	data:
	//	  GITHUB_TOKEN:
	//	    is_secret: true
	//	    description: "GitHub personal access token with repo scope"
	//	  GITHUB_OWNER:
	//	    is_secret: false
	//	    description: "Default GitHub organization or user"
	EnvSpec       *v1.EnvironmentSpec `protobuf:"bytes,8,opt,name=env_spec,json=envSpec,proto3" json:"env_spec,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *McpServerSpec) Reset() {
	*x = McpServerSpec{}
	mi := &file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *McpServerSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*McpServerSpec) ProtoMessage() {}

func (x *McpServerSpec) ProtoReflect() protoreflect.Message {
	mi := &file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use McpServerSpec.ProtoReflect.Descriptor instead.
func (*McpServerSpec) Descriptor() ([]byte, []int) {
	return file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDescGZIP(), []int{0}
}

func (x *McpServerSpec) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *McpServerSpec) GetIconUrl() string {
	if x != nil {
		return x.IconUrl
	}
	return ""
}

func (x *McpServerSpec) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *McpServerSpec) GetServerType() isMcpServerSpec_ServerType {
	if x != nil {
		return x.ServerType
	}
	return nil
}

func (x *McpServerSpec) GetStdio() *StdioServerConfig {
	if x != nil {
		if x, ok := x.ServerType.(*McpServerSpec_Stdio); ok {
			return x.Stdio
		}
	}
	return nil
}

func (x *McpServerSpec) GetHttp() *HttpServerConfig {
	if x != nil {
		if x, ok := x.ServerType.(*McpServerSpec_Http); ok {
			return x.Http
		}
	}
	return nil
}

func (x *McpServerSpec) GetDocker() *DockerServerConfig {
	if x != nil {
		if x, ok := x.ServerType.(*McpServerSpec_Docker); ok {
			return x.Docker
		}
	}
	return nil
}

func (x *McpServerSpec) GetDefaultEnabledTools() []string {
	if x != nil {
		return x.DefaultEnabledTools
	}
	return nil
}

func (x *McpServerSpec) GetEnvSpec() *v1.EnvironmentSpec {
	if x != nil {
		return x.EnvSpec
	}
	return nil
}

type isMcpServerSpec_ServerType interface {
	isMcpServerSpec_ServerType()
}

type McpServerSpec_Stdio struct {
	// stdio-based server (subprocess with stdin/stdout communication).
	// Most common type - used for Node.js, Python, and other CLI-based MCP servers.
	Stdio *StdioServerConfig `protobuf:"bytes,4,opt,name=stdio,proto3,oneof"`
}

type McpServerSpec_Http struct {
	// HTTP-based server (HTTP + Server-Sent Events communication).
	// Used for remote/managed MCP services accessible over the network.
	Http *HttpServerConfig `protobuf:"bytes,5,opt,name=http,proto3,oneof"`
}

type McpServerSpec_Docker struct {
	// Docker-based server (containerized MCP server).
	// Used for isolated, reproducible MCP server environments.
	Docker *DockerServerConfig `protobuf:"bytes,6,opt,name=docker,proto3,oneof"`
}

func (*McpServerSpec_Stdio) isMcpServerSpec_ServerType() {}

func (*McpServerSpec_Http) isMcpServerSpec_ServerType() {}

func (*McpServerSpec_Docker) isMcpServerSpec_ServerType() {}

// StdioServerConfig defines an MCP server that runs as a subprocess.
// Communication happens via stdin/stdout using JSON-RPC messages.
//
// This is the most common MCP server type, used for:
// - Node.js servers: npx @modelcontextprotocol/server-github
// - Python servers: python -m mcp_server_sqlite
// - Go servers: ./mcp-server-binary
//
// The agent runner starts this process and communicates via stdio.
type StdioServerConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Command to execute the MCP server.
	// This is the executable name or path.
	// Examples: "npx", "python", "node", "./custom-mcp-server"
	Command string `protobuf:"bytes,1,opt,name=command,proto3" json:"command,omitempty"`
	// Arguments to pass to the command.
	// Examples:
	// - For npx: ["-y", "@modelcontextprotocol/server-github"]
	// - For python: ["-m", "mcp_server_sqlite", "--db-path", "/data/db.sqlite"]
	Args []string `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	// Working directory for the process.
	// If not specified, the process inherits the agent runner's working directory.
	// Use absolute paths or paths relative to the agent runner's context.
	WorkingDir    string `protobuf:"bytes,3,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StdioServerConfig) Reset() {
	*x = StdioServerConfig{}
	mi := &file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StdioServerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StdioServerConfig) ProtoMessage() {}

func (x *StdioServerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StdioServerConfig.ProtoReflect.Descriptor instead.
func (*StdioServerConfig) Descriptor() ([]byte, []int) {
	return file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDescGZIP(), []int{1}
}

func (x *StdioServerConfig) GetCommand() string {
	if x != nil {
		return x.Command
	}
	return ""
}

func (x *StdioServerConfig) GetArgs() []string {
	if x != nil {
		return x.Args
	}
	return nil
}

func (x *StdioServerConfig) GetWorkingDir() string {
	if x != nil {
		return x.WorkingDir
	}
	return ""
}

// HttpServerConfig defines an MCP server accessible via HTTP + Server-Sent Events.
// Used for remote/managed MCP services that expose an HTTP endpoint.
//
// Communication flow:
// 1. Agent sends JSON-RPC requests via HTTP POST
// 2. Server streams responses via Server-Sent Events (SSE)
//
// This is useful for:
// - Managed MCP services (e.g., hosted by a cloud provider)
// - MCP servers behind a reverse proxy or API gateway
// - Sharing a single MCP server instance across multiple agents
type HttpServerConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Base URL of the MCP server endpoint.
	// Must be a valid HTTP or HTTPS URL.
	// Examples:
	// - "http://localhost:3000/mcp"
	// - "https://mcp.example.com/v1"
	// - "https://api.company.com/mcp/github"
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// HTTP headers to include with every request.
	// Use for authentication, API versioning, or custom routing.
	//
	// Header values can reference environment variables using ${VAR_NAME} syntax.
	// These placeholders are resolved at runtime from AgentInstance's environment.
	//
	// Examples:
	//
	//	"Authorization": "Bearer ${API_TOKEN}"
	//	"X-API-Version": "2024-01"
	//	"X-Tenant-ID": "${TENANT_ID}"
	Headers map[string]string `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Query parameters to append to the URL.
	// Values can reference environment variables using ${VAR_NAME} syntax.
	//
	// Examples:
	//
	//	"region": "${AWS_REGION}"
	//	"version": "v1"
	QueryParams map[string]string `protobuf:"bytes,3,rep,name=query_params,json=queryParams,proto3" json:"query_params,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Timeout for HTTP requests in seconds.
	// Applies to both the initial connection and response streaming.
	// Default: 30 seconds if not specified.
	// Set higher values for MCP servers that perform long-running operations.
	TimeoutSeconds int32 `protobuf:"varint,4,opt,name=timeout_seconds,json=timeoutSeconds,proto3" json:"timeout_seconds,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *HttpServerConfig) Reset() {
	*x = HttpServerConfig{}
	mi := &file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpServerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpServerConfig) ProtoMessage() {}

func (x *HttpServerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpServerConfig.ProtoReflect.Descriptor instead.
func (*HttpServerConfig) Descriptor() ([]byte, []int) {
	return file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDescGZIP(), []int{2}
}

func (x *HttpServerConfig) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *HttpServerConfig) GetHeaders() map[string]string {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *HttpServerConfig) GetQueryParams() map[string]string {
	if x != nil {
		return x.QueryParams
	}
	return nil
}

func (x *HttpServerConfig) GetTimeoutSeconds() int32 {
	if x != nil {
		return x.TimeoutSeconds
	}
	return 0
}

// DockerServerConfig defines an MCP server that runs in a Docker container.
// Provides isolation and reproducibility for MCP server environments.
//
// Communication can happen via:
// - stdio: Container's stdin/stdout (default, similar to StdioServerConfig)
// - HTTP: Via port mapping to container's HTTP endpoint
//
// This is useful for:
// - Custom MCP servers with complex dependencies
// - Isolated execution environments
// - Consistent environments across different host systems
type DockerServerConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Docker image name and tag.
	// Can be from any registry accessible to the agent runner.
	// Examples:
	// - "ghcr.io/org/mcp-server:latest"
	// - "myregistry.com/mcp/custom-server:v1.2.3"
	// - "mcp-local-server:dev" (local image)
	Image string `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	// Command arguments to pass to the container.
	// Overrides the default CMD in the Docker image.
	// Leave empty to use the image's default command.
	Args []string `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	// Volume mounts for the container.
	// Use to provide access to host filesystem, configuration files, or data.
	Volumes []*VolumeMount `protobuf:"bytes,3,rep,name=volumes,proto3" json:"volumes,omitempty"`
	// Docker network to attach the container to.
	// Default: "bridge" (Docker's default network).
	// Use custom networks for inter-container communication.
	Network string `protobuf:"bytes,4,opt,name=network,proto3" json:"network,omitempty"`
	// Port mappings for the container.
	// Required if communicating via HTTP instead of stdio.
	// Maps host ports to container ports.
	Ports []*PortMapping `protobuf:"bytes,5,rep,name=ports,proto3" json:"ports,omitempty"`
	// Container name for identification and management.
	// If not specified, Docker generates a random name.
	// Useful for debugging and container lifecycle management.
	ContainerName string `protobuf:"bytes,6,opt,name=container_name,json=containerName,proto3" json:"container_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DockerServerConfig) Reset() {
	*x = DockerServerConfig{}
	mi := &file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DockerServerConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DockerServerConfig) ProtoMessage() {}

func (x *DockerServerConfig) ProtoReflect() protoreflect.Message {
	mi := &file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DockerServerConfig.ProtoReflect.Descriptor instead.
func (*DockerServerConfig) Descriptor() ([]byte, []int) {
	return file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDescGZIP(), []int{3}
}

func (x *DockerServerConfig) GetImage() string {
	if x != nil {
		return x.Image
	}
	return ""
}

func (x *DockerServerConfig) GetArgs() []string {
	if x != nil {
		return x.Args
	}
	return nil
}

func (x *DockerServerConfig) GetVolumes() []*VolumeMount {
	if x != nil {
		return x.Volumes
	}
	return nil
}

func (x *DockerServerConfig) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *DockerServerConfig) GetPorts() []*PortMapping {
	if x != nil {
		return x.Ports
	}
	return nil
}

func (x *DockerServerConfig) GetContainerName() string {
	if x != nil {
		return x.ContainerName
	}
	return ""
}

// VolumeMount defines a Docker volume mount configuration.
// Maps a path on the host to a path inside the container.
type VolumeMount struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Path on the host machine to mount.
	// Can be an absolute path or a named Docker volume.
	// Examples:
	// - "/home/user/data" (absolute path)
	// - "mcp-data-volume" (named volume)
	HostPath string `protobuf:"bytes,1,opt,name=host_path,json=hostPath,proto3" json:"host_path,omitempty"`
	// Path inside the container where the volume is mounted.
	// Must be an absolute path.
	// Example: "/data"
	ContainerPath string `protobuf:"bytes,2,opt,name=container_path,json=containerPath,proto3" json:"container_path,omitempty"`
	// Whether the mount should be read-only.
	// Default: false (read-write).
	// Set to true for configuration files or sensitive data that shouldn't be modified.
	ReadOnly      bool `protobuf:"varint,3,opt,name=read_only,json=readOnly,proto3" json:"read_only,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VolumeMount) Reset() {
	*x = VolumeMount{}
	mi := &file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeMount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeMount) ProtoMessage() {}

func (x *VolumeMount) ProtoReflect() protoreflect.Message {
	mi := &file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeMount.ProtoReflect.Descriptor instead.
func (*VolumeMount) Descriptor() ([]byte, []int) {
	return file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDescGZIP(), []int{4}
}

func (x *VolumeMount) GetHostPath() string {
	if x != nil {
		return x.HostPath
	}
	return ""
}

func (x *VolumeMount) GetContainerPath() string {
	if x != nil {
		return x.ContainerPath
	}
	return ""
}

func (x *VolumeMount) GetReadOnly() bool {
	if x != nil {
		return x.ReadOnly
	}
	return false
}

// PortMapping defines a Docker port mapping configuration.
// Maps a port on the host to a port inside the container.
type PortMapping struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Port on the host machine to bind.
	// Must be available and within valid port range (1-65535).
	HostPort int32 `protobuf:"varint,1,opt,name=host_port,json=hostPort,proto3" json:"host_port,omitempty"`
	// Port inside the container to expose.
	// Must match the port the MCP server listens on.
	ContainerPort int32 `protobuf:"varint,2,opt,name=container_port,json=containerPort,proto3" json:"container_port,omitempty"`
	// Network protocol for the port mapping.
	// Default: "tcp".
	// Valid values: "tcp", "udp".
	Protocol      string `protobuf:"bytes,3,opt,name=protocol,proto3" json:"protocol,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PortMapping) Reset() {
	*x = PortMapping{}
	mi := &file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PortMapping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PortMapping) ProtoMessage() {}

func (x *PortMapping) ProtoReflect() protoreflect.Message {
	mi := &file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PortMapping.ProtoReflect.Descriptor instead.
func (*PortMapping) Descriptor() ([]byte, []int) {
	return file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDescGZIP(), []int{5}
}

func (x *PortMapping) GetHostPort() int32 {
	if x != nil {
		return x.HostPort
	}
	return 0
}

func (x *PortMapping) GetContainerPort() int32 {
	if x != nil {
		return x.ContainerPort
	}
	return 0
}

func (x *PortMapping) GetProtocol() string {
	if x != nil {
		return x.Protocol
	}
	return ""
}

var File_ai_stigmer_agentic_mcpserver_v1_spec_proto protoreflect.FileDescriptor

const file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDesc = "" +
	"\n" +
	"*ai/stigmer/agentic/mcpserver/v1/spec.proto\x12\x1fai.stigmer.agentic.mcpserver.v1\x1a,ai/stigmer/agentic/environment/v1/spec.proto\x1a\x1bbuf/validate/validate.proto\"\xdd\x03\n" +
	"\rMcpServerSpec\x12 \n" +
	"\vdescription\x18\x01 \x01(\tR\vdescription\x12\x19\n" +
	"\bicon_url\x18\x02 \x01(\tR\aiconUrl\x12\x12\n" +
	"\x04tags\x18\x03 \x03(\tR\x04tags\x12J\n" +
	"\x05stdio\x18\x04 \x01(\v22.ai.stigmer.agentic.mcpserver.v1.StdioServerConfigH\x00R\x05stdio\x12G\n" +
	"\x04http\x18\x05 \x01(\v21.ai.stigmer.agentic.mcpserver.v1.HttpServerConfigH\x00R\x04http\x12M\n" +
	"\x06docker\x18\x06 \x01(\v23.ai.stigmer.agentic.mcpserver.v1.DockerServerConfigH\x00R\x06docker\x122\n" +
	"\x15default_enabled_tools\x18\a \x03(\tR\x13defaultEnabledTools\x12M\n" +
	"\benv_spec\x18\b \x01(\v22.ai.stigmer.agentic.environment.v1.EnvironmentSpecR\aenvSpecB\x14\n" +
	"\vserver_type\x12\x05\xbaH\x02\b\x01\"j\n" +
	"\x11StdioServerConfig\x12 \n" +
	"\acommand\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\acommand\x12\x12\n" +
	"\x04args\x18\x02 \x03(\tR\x04args\x12\x1f\n" +
	"\vworking_dir\x18\x03 \x01(\tR\n" +
	"workingDir\"\xa3\x03\n" +
	"\x10HttpServerConfig\x12\x1d\n" +
	"\x03url\x18\x01 \x01(\tB\v\xbaH\b\xc8\x01\x01r\x03\x88\x01\x01R\x03url\x12X\n" +
	"\aheaders\x18\x02 \x03(\v2>.ai.stigmer.agentic.mcpserver.v1.HttpServerConfig.HeadersEntryR\aheaders\x12e\n" +
	"\fquery_params\x18\x03 \x03(\v2B.ai.stigmer.agentic.mcpserver.v1.HttpServerConfig.QueryParamsEntryR\vqueryParams\x123\n" +
	"\x0ftimeout_seconds\x18\x04 \x01(\x05B\n" +
	"\xbaH\a\x1a\x05\x18\xac\x02(\x00R\x0etimeoutSeconds\x1a:\n" +
	"\fHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1a>\n" +
	"\x10QueryParamsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x97\x02\n" +
	"\x12DockerServerConfig\x12 \n" +
	"\x05image\x18\x01 \x01(\tB\n" +
	"\xbaH\a\xc8\x01\x01r\x02\x10\x01R\x05image\x12\x12\n" +
	"\x04args\x18\x02 \x03(\tR\x04args\x12F\n" +
	"\avolumes\x18\x03 \x03(\v2,.ai.stigmer.agentic.mcpserver.v1.VolumeMountR\avolumes\x12\x18\n" +
	"\anetwork\x18\x04 \x01(\tR\anetwork\x12B\n" +
	"\x05ports\x18\x05 \x03(\v2,.ai.stigmer.agentic.mcpserver.v1.PortMappingR\x05ports\x12%\n" +
	"\x0econtainer_name\x18\x06 \x01(\tR\rcontainerName\"~\n" +
	"\vVolumeMount\x12#\n" +
	"\thost_path\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\bhostPath\x12-\n" +
	"\x0econtainer_path\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\rcontainerPath\x12\x1b\n" +
	"\tread_only\x18\x03 \x01(\bR\breadOnly\"\x9a\x01\n" +
	"\vPortMapping\x12(\n" +
	"\thost_port\x18\x01 \x01(\x05B\v\xbaH\b\x1a\x06\x18\xff\xff\x03(\x01R\bhostPort\x122\n" +
	"\x0econtainer_port\x18\x02 \x01(\x05B\v\xbaH\b\x1a\x06\x18\xff\xff\x03(\x01R\rcontainerPort\x12-\n" +
	"\bprotocol\x18\x03 \x01(\tB\x11\xbaH\x0er\fR\x00R\x03tcpR\x03udpR\bprotocolB\xa7\x02\n" +
	"#com.ai.stigmer.agentic.mcpserver.v1B\tSpecProtoP\x01ZTgithub.com/stigmer/stigmer/apis/stubs/go/ai/stigmer/agentic/mcpserver/v1;mcpserverv1\xa2\x02\x04ASAM\xaa\x02\x1fAi.Stigmer.Agentic.Mcpserver.V1\xca\x02\x1fAi\\Stigmer\\Agentic\\Mcpserver\\V1\xe2\x02+Ai\\Stigmer\\Agentic\\Mcpserver\\V1\\GPBMetadata\xea\x02#Ai::Stigmer::Agentic::Mcpserver::V1b\x06proto3"

var (
	file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDescOnce sync.Once
	file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDescData []byte
)

func file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDescGZIP() []byte {
	file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDescOnce.Do(func() {
		file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDesc), len(file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDesc)))
	})
	return file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDescData
}

var file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_ai_stigmer_agentic_mcpserver_v1_spec_proto_goTypes = []any{
	(*McpServerSpec)(nil),      // 0: ai.stigmer.agentic.mcpserver.v1.McpServerSpec
	(*StdioServerConfig)(nil),  // 1: ai.stigmer.agentic.mcpserver.v1.StdioServerConfig
	(*HttpServerConfig)(nil),   // 2: ai.stigmer.agentic.mcpserver.v1.HttpServerConfig
	(*DockerServerConfig)(nil), // 3: ai.stigmer.agentic.mcpserver.v1.DockerServerConfig
	(*VolumeMount)(nil),        // 4: ai.stigmer.agentic.mcpserver.v1.VolumeMount
	(*PortMapping)(nil),        // 5: ai.stigmer.agentic.mcpserver.v1.PortMapping
	nil,                        // 6: ai.stigmer.agentic.mcpserver.v1.HttpServerConfig.HeadersEntry
	nil,                        // 7: ai.stigmer.agentic.mcpserver.v1.HttpServerConfig.QueryParamsEntry
	(*v1.EnvironmentSpec)(nil), // 8: ai.stigmer.agentic.environment.v1.EnvironmentSpec
}
var file_ai_stigmer_agentic_mcpserver_v1_spec_proto_depIdxs = []int32{
	1, // 0: ai.stigmer.agentic.mcpserver.v1.McpServerSpec.stdio:type_name -> ai.stigmer.agentic.mcpserver.v1.StdioServerConfig
	2, // 1: ai.stigmer.agentic.mcpserver.v1.McpServerSpec.http:type_name -> ai.stigmer.agentic.mcpserver.v1.HttpServerConfig
	3, // 2: ai.stigmer.agentic.mcpserver.v1.McpServerSpec.docker:type_name -> ai.stigmer.agentic.mcpserver.v1.DockerServerConfig
	8, // 3: ai.stigmer.agentic.mcpserver.v1.McpServerSpec.env_spec:type_name -> ai.stigmer.agentic.environment.v1.EnvironmentSpec
	6, // 4: ai.stigmer.agentic.mcpserver.v1.HttpServerConfig.headers:type_name -> ai.stigmer.agentic.mcpserver.v1.HttpServerConfig.HeadersEntry
	7, // 5: ai.stigmer.agentic.mcpserver.v1.HttpServerConfig.query_params:type_name -> ai.stigmer.agentic.mcpserver.v1.HttpServerConfig.QueryParamsEntry
	4, // 6: ai.stigmer.agentic.mcpserver.v1.DockerServerConfig.volumes:type_name -> ai.stigmer.agentic.mcpserver.v1.VolumeMount
	5, // 7: ai.stigmer.agentic.mcpserver.v1.DockerServerConfig.ports:type_name -> ai.stigmer.agentic.mcpserver.v1.PortMapping
	8, // [8:8] is the sub-list for method output_type
	8, // [8:8] is the sub-list for method input_type
	8, // [8:8] is the sub-list for extension type_name
	8, // [8:8] is the sub-list for extension extendee
	0, // [0:8] is the sub-list for field type_name
}

func init() { file_ai_stigmer_agentic_mcpserver_v1_spec_proto_init() }
func file_ai_stigmer_agentic_mcpserver_v1_spec_proto_init() {
	if File_ai_stigmer_agentic_mcpserver_v1_spec_proto != nil {
		return
	}
	file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes[0].OneofWrappers = []any{
		(*McpServerSpec_Stdio)(nil),
		(*McpServerSpec_Http)(nil),
		(*McpServerSpec_Docker)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDesc), len(file_ai_stigmer_agentic_mcpserver_v1_spec_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   8,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_ai_stigmer_agentic_mcpserver_v1_spec_proto_goTypes,
		DependencyIndexes: file_ai_stigmer_agentic_mcpserver_v1_spec_proto_depIdxs,
		MessageInfos:      file_ai_stigmer_agentic_mcpserver_v1_spec_proto_msgTypes,
	}.Build()
	File_ai_stigmer_agentic_mcpserver_v1_spec_proto = out.File
	file_ai_stigmer_agentic_mcpserver_v1_spec_proto_goTypes = nil
	file_ai_stigmer_agentic_mcpserver_v1_spec_proto_depIdxs = nil
}
