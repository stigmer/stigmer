// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: ai/stigmer/agentic/workflowinstance/v1/command.proto

// Package workflowinstance contains the command controller for WorkflowInstance write operations.

package workflowinstancev1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	WorkflowInstanceCommandController_Apply_FullMethodName  = "/ai.stigmer.agentic.workflowinstance.v1.WorkflowInstanceCommandController/apply"
	WorkflowInstanceCommandController_Create_FullMethodName = "/ai.stigmer.agentic.workflowinstance.v1.WorkflowInstanceCommandController/create"
	WorkflowInstanceCommandController_Update_FullMethodName = "/ai.stigmer.agentic.workflowinstance.v1.WorkflowInstanceCommandController/update"
	WorkflowInstanceCommandController_Delete_FullMethodName = "/ai.stigmer.agentic.workflowinstance.v1.WorkflowInstanceCommandController/delete"
)

// WorkflowInstanceCommandControllerClient is the client API for WorkflowInstanceCommandController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// WorkflowInstanceCommandController handles write operations (Create, Update, Delete) for WorkflowInstance resources.
//
// This service provides the CUD (Create, Update, Delete) operations following the
// Command-Query Separation pattern. All RPCs that modify state go through this controller.
//
// Authorization:
// - create: Custom authorization logic (validates workflow_id access, env_refs access)
// - update: Standard authorization (requires update permission on the instance)
// - delete: Standard authorization (requires delete permission on the instance)
//
// All operations enforce owner scope restrictions (organization or identity_account only).
type WorkflowInstanceCommandControllerClient interface {
	// Create or update a workflow instance.
	// The authorization and state-operation are determined depending on whether the workflow instance
	// is going to be created or updated which is determined as part of the request execution.
	Apply(ctx context.Context, in *WorkflowInstance, opts ...grpc.CallOption) (*WorkflowInstance, error)
	// Create a new workflow instance.
	//
	// Creates a configured deployment of a Workflow template with environment bindings.
	//
	// Input validation:
	// - metadata.owner_scope must be organization (2) or identity_account (3)
	// - spec.workflow_id must be a valid Workflow resource ID
	// - spec.env_refs must reference valid Environment resources
	//
	// Authorization:
	// Uses custom authorization logic to verify:
	// 1. User has permission to access the referenced Workflow template
	// 2. User has permission to access all referenced Environment resources
	// 3. Owner scope is valid for the user's organization/identity
	//
	// Returns:
	// The created WorkflowInstance with:
	// - Assigned resource ID (metadata.id)
	// - Created timestamp (status.audit.created_at)
	// - Initial version (status.audit.version = 1)
	//
	// Example:
	// Input: WorkflowInstance with workflow_id="wfl-123", env_refs=["env-prod"]
	// Output: WorkflowInstance with id="wfi-abc456", created_at="2025-01-11T10:00:00Z"
	Create(ctx context.Context, in *WorkflowInstance, opts ...grpc.CallOption) (*WorkflowInstance, error)
	// Update an existing workflow instance.
	//
	// Modifies the configuration of an existing WorkflowInstance.
	// You can update:
	// - spec.description (change descriptive text)
	// - spec.env_refs (add/remove/reorder environment bindings)
	// - metadata.labels, metadata.tags, metadata.annotations
	//
	// You cannot update:
	// - spec.workflow_id (must delete and recreate to change template)
	// - metadata.id (immutable resource identifier)
	// - metadata.owner_scope (immutable after creation)
	//
	// Authorization:
	// Requires "update" permission on the specific WorkflowInstance resource.
	// Field path "metadata.id" identifies which resource to authorize.
	//
	// Versioning:
	// Each update increments status.audit.version and updates status.audit.updated_at.
	//
	// Returns:
	// The updated WorkflowInstance with:
	// - Incremented version number
	// - Updated timestamp
	// - Modified spec fields
	//
	// Error: PERMISSION_DENIED if user lacks update permission
	Update(ctx context.Context, in *WorkflowInstance, opts ...grpc.CallOption) (*WorkflowInstance, error)
	// Delete a workflow instance.
	//
	// Permanently removes a WorkflowInstance resource.
	//
	// Important:
	// - Deletion is permanent and cannot be undone
	// - Does NOT delete the referenced Workflow template (templates are reusable)
	// - Does NOT delete the referenced Environment resources (environments are reusable)
	// - DOES cascade delete any dependent WorkflowExecution resources (executions belong to instance)
	//
	// Authorization:
	// Requires "delete" permission on the specific WorkflowInstance resource.
	// Field path "value" extracts the resource ID from WorkflowInstanceId wrapper.
	//
	// Use Cases:
	// - Remove deprecated instances
	// - Clean up test/dev instances
	// - Decommission old deployment configurations
	//
	// Returns:
	// The deleted WorkflowInstance (final state before deletion).
	// Useful for audit logs and confirming what was deleted.
	//
	// Error: PERMISSION_DENIED if user lacks delete permission
	// Error: NOT_FOUND if instance ID doesn't exist
	Delete(ctx context.Context, in *WorkflowInstanceId, opts ...grpc.CallOption) (*WorkflowInstance, error)
}

type workflowInstanceCommandControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkflowInstanceCommandControllerClient(cc grpc.ClientConnInterface) WorkflowInstanceCommandControllerClient {
	return &workflowInstanceCommandControllerClient{cc}
}

func (c *workflowInstanceCommandControllerClient) Apply(ctx context.Context, in *WorkflowInstance, opts ...grpc.CallOption) (*WorkflowInstance, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowInstance)
	err := c.cc.Invoke(ctx, WorkflowInstanceCommandController_Apply_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowInstanceCommandControllerClient) Create(ctx context.Context, in *WorkflowInstance, opts ...grpc.CallOption) (*WorkflowInstance, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowInstance)
	err := c.cc.Invoke(ctx, WorkflowInstanceCommandController_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowInstanceCommandControllerClient) Update(ctx context.Context, in *WorkflowInstance, opts ...grpc.CallOption) (*WorkflowInstance, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowInstance)
	err := c.cc.Invoke(ctx, WorkflowInstanceCommandController_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowInstanceCommandControllerClient) Delete(ctx context.Context, in *WorkflowInstanceId, opts ...grpc.CallOption) (*WorkflowInstance, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowInstance)
	err := c.cc.Invoke(ctx, WorkflowInstanceCommandController_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkflowInstanceCommandControllerServer is the server API for WorkflowInstanceCommandController service.
// All implementations should embed UnimplementedWorkflowInstanceCommandControllerServer
// for forward compatibility.
//
// WorkflowInstanceCommandController handles write operations (Create, Update, Delete) for WorkflowInstance resources.
//
// This service provides the CUD (Create, Update, Delete) operations following the
// Command-Query Separation pattern. All RPCs that modify state go through this controller.
//
// Authorization:
// - create: Custom authorization logic (validates workflow_id access, env_refs access)
// - update: Standard authorization (requires update permission on the instance)
// - delete: Standard authorization (requires delete permission on the instance)
//
// All operations enforce owner scope restrictions (organization or identity_account only).
type WorkflowInstanceCommandControllerServer interface {
	// Create or update a workflow instance.
	// The authorization and state-operation are determined depending on whether the workflow instance
	// is going to be created or updated which is determined as part of the request execution.
	Apply(context.Context, *WorkflowInstance) (*WorkflowInstance, error)
	// Create a new workflow instance.
	//
	// Creates a configured deployment of a Workflow template with environment bindings.
	//
	// Input validation:
	// - metadata.owner_scope must be organization (2) or identity_account (3)
	// - spec.workflow_id must be a valid Workflow resource ID
	// - spec.env_refs must reference valid Environment resources
	//
	// Authorization:
	// Uses custom authorization logic to verify:
	// 1. User has permission to access the referenced Workflow template
	// 2. User has permission to access all referenced Environment resources
	// 3. Owner scope is valid for the user's organization/identity
	//
	// Returns:
	// The created WorkflowInstance with:
	// - Assigned resource ID (metadata.id)
	// - Created timestamp (status.audit.created_at)
	// - Initial version (status.audit.version = 1)
	//
	// Example:
	// Input: WorkflowInstance with workflow_id="wfl-123", env_refs=["env-prod"]
	// Output: WorkflowInstance with id="wfi-abc456", created_at="2025-01-11T10:00:00Z"
	Create(context.Context, *WorkflowInstance) (*WorkflowInstance, error)
	// Update an existing workflow instance.
	//
	// Modifies the configuration of an existing WorkflowInstance.
	// You can update:
	// - spec.description (change descriptive text)
	// - spec.env_refs (add/remove/reorder environment bindings)
	// - metadata.labels, metadata.tags, metadata.annotations
	//
	// You cannot update:
	// - spec.workflow_id (must delete and recreate to change template)
	// - metadata.id (immutable resource identifier)
	// - metadata.owner_scope (immutable after creation)
	//
	// Authorization:
	// Requires "update" permission on the specific WorkflowInstance resource.
	// Field path "metadata.id" identifies which resource to authorize.
	//
	// Versioning:
	// Each update increments status.audit.version and updates status.audit.updated_at.
	//
	// Returns:
	// The updated WorkflowInstance with:
	// - Incremented version number
	// - Updated timestamp
	// - Modified spec fields
	//
	// Error: PERMISSION_DENIED if user lacks update permission
	Update(context.Context, *WorkflowInstance) (*WorkflowInstance, error)
	// Delete a workflow instance.
	//
	// Permanently removes a WorkflowInstance resource.
	//
	// Important:
	// - Deletion is permanent and cannot be undone
	// - Does NOT delete the referenced Workflow template (templates are reusable)
	// - Does NOT delete the referenced Environment resources (environments are reusable)
	// - DOES cascade delete any dependent WorkflowExecution resources (executions belong to instance)
	//
	// Authorization:
	// Requires "delete" permission on the specific WorkflowInstance resource.
	// Field path "value" extracts the resource ID from WorkflowInstanceId wrapper.
	//
	// Use Cases:
	// - Remove deprecated instances
	// - Clean up test/dev instances
	// - Decommission old deployment configurations
	//
	// Returns:
	// The deleted WorkflowInstance (final state before deletion).
	// Useful for audit logs and confirming what was deleted.
	//
	// Error: PERMISSION_DENIED if user lacks delete permission
	// Error: NOT_FOUND if instance ID doesn't exist
	Delete(context.Context, *WorkflowInstanceId) (*WorkflowInstance, error)
}

// UnimplementedWorkflowInstanceCommandControllerServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWorkflowInstanceCommandControllerServer struct{}

func (UnimplementedWorkflowInstanceCommandControllerServer) Apply(context.Context, *WorkflowInstance) (*WorkflowInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Apply not implemented")
}
func (UnimplementedWorkflowInstanceCommandControllerServer) Create(context.Context, *WorkflowInstance) (*WorkflowInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedWorkflowInstanceCommandControllerServer) Update(context.Context, *WorkflowInstance) (*WorkflowInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedWorkflowInstanceCommandControllerServer) Delete(context.Context, *WorkflowInstanceId) (*WorkflowInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedWorkflowInstanceCommandControllerServer) testEmbeddedByValue() {}

// UnsafeWorkflowInstanceCommandControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkflowInstanceCommandControllerServer will
// result in compilation errors.
type UnsafeWorkflowInstanceCommandControllerServer interface {
	mustEmbedUnimplementedWorkflowInstanceCommandControllerServer()
}

func RegisterWorkflowInstanceCommandControllerServer(s grpc.ServiceRegistrar, srv WorkflowInstanceCommandControllerServer) {
	// If the following call pancis, it indicates UnimplementedWorkflowInstanceCommandControllerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WorkflowInstanceCommandController_ServiceDesc, srv)
}

func _WorkflowInstanceCommandController_Apply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowInstance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowInstanceCommandControllerServer).Apply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowInstanceCommandController_Apply_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowInstanceCommandControllerServer).Apply(ctx, req.(*WorkflowInstance))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowInstanceCommandController_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowInstance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowInstanceCommandControllerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowInstanceCommandController_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowInstanceCommandControllerServer).Create(ctx, req.(*WorkflowInstance))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowInstanceCommandController_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowInstance)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowInstanceCommandControllerServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowInstanceCommandController_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowInstanceCommandControllerServer).Update(ctx, req.(*WorkflowInstance))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowInstanceCommandController_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowInstanceId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowInstanceCommandControllerServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowInstanceCommandController_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowInstanceCommandControllerServer).Delete(ctx, req.(*WorkflowInstanceId))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkflowInstanceCommandController_ServiceDesc is the grpc.ServiceDesc for WorkflowInstanceCommandController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkflowInstanceCommandController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ai.stigmer.agentic.workflowinstance.v1.WorkflowInstanceCommandController",
	HandlerType: (*WorkflowInstanceCommandControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "apply",
			Handler:    _WorkflowInstanceCommandController_Apply_Handler,
		},
		{
			MethodName: "create",
			Handler:    _WorkflowInstanceCommandController_Create_Handler,
		},
		{
			MethodName: "update",
			Handler:    _WorkflowInstanceCommandController_Update_Handler,
		},
		{
			MethodName: "delete",
			Handler:    _WorkflowInstanceCommandController_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ai/stigmer/agentic/workflowinstance/v1/command.proto",
}
