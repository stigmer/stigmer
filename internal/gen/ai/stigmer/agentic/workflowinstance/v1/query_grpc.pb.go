// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: ai/stigmer/agentic/workflowinstance/v1/query.proto

// Package workflowinstance contains the query controller for WorkflowInstance read operations.

package workflowinstancev1

import (
	context "context"
	apiresource "github.com/stigmer/stigmer/internal/gen/ai/stigmer/commons/apiresource"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	WorkflowInstanceQueryController_Get_FullMethodName            = "/ai.stigmer.agentic.workflowinstance.v1.WorkflowInstanceQueryController/get"
	WorkflowInstanceQueryController_GetByWorkflow_FullMethodName  = "/ai.stigmer.agentic.workflowinstance.v1.WorkflowInstanceQueryController/getByWorkflow"
	WorkflowInstanceQueryController_GetByReference_FullMethodName = "/ai.stigmer.agentic.workflowinstance.v1.WorkflowInstanceQueryController/getByReference"
)

// WorkflowInstanceQueryControllerClient is the client API for WorkflowInstanceQueryController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// WorkflowInstanceQueryController handles read operations (Get, List, Search) for WorkflowInstance resources.
//
// This service provides all query operations following the Command-Query Separation pattern.
// All RPCs that read state without modifying it go through this controller.
//
// Authorization:
// - get: Requires get permission on the specific instance
// - getByWorkflow: Authorization handled in handler via FGA query (returns filtered instances)
// - getByReference: Custom authorization (supports flexible reference lookup)
//
// All operations respect owner scope visibility rules (users see only their org/identity resources).
type WorkflowInstanceQueryControllerClient interface {
	// Get a single workflow instance by ID.
	//
	// Retrieves a specific WorkflowInstance using its unique resource identifier.
	//
	// Input:
	// WorkflowInstanceId with the instance ID (e.g., "wfi-abc123")
	//
	// Returns:
	// Complete WorkflowInstance resource with:
	// - api_version, kind, metadata
	// - spec (workflow_id, description, env_refs)
	// - status (audit information: created_at, updated_at, version)
	//
	// Authorization:
	// Requires "get" permission on the specific WorkflowInstance.
	// Field path "value" extracts the resource ID from WorkflowInstanceId wrapper.
	// Verifies user has access based on:
	// - Instance owner scope (organization or identity_account)
	// - User's IAM policies
	//
	// Use Cases:
	// - Retrieve instance configuration before executing
	// - View instance details in UI
	// - Fetch instance for editing/updating
	//
	// Error: PERMISSION_DENIED if user lacks get permission
	// Error: NOT_FOUND if instance ID doesn't exist
	Get(ctx context.Context, in *WorkflowInstanceId, opts ...grpc.CallOption) (*WorkflowInstance, error)
	// Get all instances of a specific workflow template.
	//
	// Retrieves all WorkflowInstance resources that reference a specific Workflow template.
	// Useful for discovering all configured deployments of a workflow.
	//
	// Example Use Case:
	// Workflow "deploy-to-cloud" (wfl-123) has instances:
	// - "prod-deploy" (wfi-abc) - Production deployment with aws-prod-env
	// - "staging-deploy" (wfi-def) - Staging deployment with aws-staging-env
	// - "dev-deploy" (wfi-ghi) - Development deployment with aws-dev-env
	//
	// Input:
	// GetWorkflowInstancesByWorkflowRequest with:
	// - workflow_id: Workflow template ID to filter by
	// - page_info: Pagination settings (page_size, page_token)
	//
	// Returns:
	// WorkflowInstanceList with:
	// - total_pages: Total number of pages available
	// - entries: Array of WorkflowInstance resources in current page
	//
	// Authorization:
	// Authorization is handled in handler via FGA query for authorized workflow_instance_ids,
	// then filtered by workflow_id. This ensures users only see instances they have access to,
	// even if the parent workflow is shared across organizations.
	//
	// Filtering:
	// Results are filtered by:
	// - User's organization/identity visibility
	// - IAM policies
	// - Owner scope rules
	//
	// Error: PERMISSION_DENIED if user lacks access to the workflow
	// Error: NOT_FOUND if workflow_id doesn't exist
	GetByWorkflow(ctx context.Context, in *GetWorkflowInstancesByWorkflowRequest, opts ...grpc.CallOption) (*WorkflowInstanceList, error)
	// Get a workflow instance by flexible reference (ID or slug).
	//
	// Retrieves a WorkflowInstance using ApiResourceReference which supports multiple lookup methods:
	// - By ID: {id: "wfi-abc123"}
	// - By slug: {slug: "prod-deploy"}
	// - By name: {name: "Production Deploy"}
	//
	// Input:
	// ApiResourceReference with one of: id, slug, or name
	//
	// Returns:
	// Complete WorkflowInstance resource matching the reference.
	//
	// Authorization:
	// Uses custom authorization logic in the handler.
	// Allows for flexible authorization based on reference type and context.
	// Typical checks:
	// - User has get permission on the resolved instance
	// - Instance owner scope matches user's organization/identity
	//
	// Use Cases:
	// - User-friendly lookups by slug instead of opaque IDs
	// - CLI commands using human-readable names
	// - API integrations using stable slugs
	//
	// Example:
	// Input: ApiResourceReference{slug: "prod-deploy"}
	// Output: WorkflowInstance with metadata.slug = "prod-deploy"
	//
	// Error: PERMISSION_DENIED if user lacks access
	// Error: NOT_FOUND if reference doesn't resolve to an instance
	GetByReference(ctx context.Context, in *apiresource.ApiResourceReference, opts ...grpc.CallOption) (*WorkflowInstance, error)
}

type workflowInstanceQueryControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkflowInstanceQueryControllerClient(cc grpc.ClientConnInterface) WorkflowInstanceQueryControllerClient {
	return &workflowInstanceQueryControllerClient{cc}
}

func (c *workflowInstanceQueryControllerClient) Get(ctx context.Context, in *WorkflowInstanceId, opts ...grpc.CallOption) (*WorkflowInstance, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowInstance)
	err := c.cc.Invoke(ctx, WorkflowInstanceQueryController_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowInstanceQueryControllerClient) GetByWorkflow(ctx context.Context, in *GetWorkflowInstancesByWorkflowRequest, opts ...grpc.CallOption) (*WorkflowInstanceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowInstanceList)
	err := c.cc.Invoke(ctx, WorkflowInstanceQueryController_GetByWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowInstanceQueryControllerClient) GetByReference(ctx context.Context, in *apiresource.ApiResourceReference, opts ...grpc.CallOption) (*WorkflowInstance, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowInstance)
	err := c.cc.Invoke(ctx, WorkflowInstanceQueryController_GetByReference_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkflowInstanceQueryControllerServer is the server API for WorkflowInstanceQueryController service.
// All implementations must embed UnimplementedWorkflowInstanceQueryControllerServer
// for forward compatibility.
//
// WorkflowInstanceQueryController handles read operations (Get, List, Search) for WorkflowInstance resources.
//
// This service provides all query operations following the Command-Query Separation pattern.
// All RPCs that read state without modifying it go through this controller.
//
// Authorization:
// - get: Requires get permission on the specific instance
// - getByWorkflow: Authorization handled in handler via FGA query (returns filtered instances)
// - getByReference: Custom authorization (supports flexible reference lookup)
//
// All operations respect owner scope visibility rules (users see only their org/identity resources).
type WorkflowInstanceQueryControllerServer interface {
	// Get a single workflow instance by ID.
	//
	// Retrieves a specific WorkflowInstance using its unique resource identifier.
	//
	// Input:
	// WorkflowInstanceId with the instance ID (e.g., "wfi-abc123")
	//
	// Returns:
	// Complete WorkflowInstance resource with:
	// - api_version, kind, metadata
	// - spec (workflow_id, description, env_refs)
	// - status (audit information: created_at, updated_at, version)
	//
	// Authorization:
	// Requires "get" permission on the specific WorkflowInstance.
	// Field path "value" extracts the resource ID from WorkflowInstanceId wrapper.
	// Verifies user has access based on:
	// - Instance owner scope (organization or identity_account)
	// - User's IAM policies
	//
	// Use Cases:
	// - Retrieve instance configuration before executing
	// - View instance details in UI
	// - Fetch instance for editing/updating
	//
	// Error: PERMISSION_DENIED if user lacks get permission
	// Error: NOT_FOUND if instance ID doesn't exist
	Get(context.Context, *WorkflowInstanceId) (*WorkflowInstance, error)
	// Get all instances of a specific workflow template.
	//
	// Retrieves all WorkflowInstance resources that reference a specific Workflow template.
	// Useful for discovering all configured deployments of a workflow.
	//
	// Example Use Case:
	// Workflow "deploy-to-cloud" (wfl-123) has instances:
	// - "prod-deploy" (wfi-abc) - Production deployment with aws-prod-env
	// - "staging-deploy" (wfi-def) - Staging deployment with aws-staging-env
	// - "dev-deploy" (wfi-ghi) - Development deployment with aws-dev-env
	//
	// Input:
	// GetWorkflowInstancesByWorkflowRequest with:
	// - workflow_id: Workflow template ID to filter by
	// - page_info: Pagination settings (page_size, page_token)
	//
	// Returns:
	// WorkflowInstanceList with:
	// - total_pages: Total number of pages available
	// - entries: Array of WorkflowInstance resources in current page
	//
	// Authorization:
	// Authorization is handled in handler via FGA query for authorized workflow_instance_ids,
	// then filtered by workflow_id. This ensures users only see instances they have access to,
	// even if the parent workflow is shared across organizations.
	//
	// Filtering:
	// Results are filtered by:
	// - User's organization/identity visibility
	// - IAM policies
	// - Owner scope rules
	//
	// Error: PERMISSION_DENIED if user lacks access to the workflow
	// Error: NOT_FOUND if workflow_id doesn't exist
	GetByWorkflow(context.Context, *GetWorkflowInstancesByWorkflowRequest) (*WorkflowInstanceList, error)
	// Get a workflow instance by flexible reference (ID or slug).
	//
	// Retrieves a WorkflowInstance using ApiResourceReference which supports multiple lookup methods:
	// - By ID: {id: "wfi-abc123"}
	// - By slug: {slug: "prod-deploy"}
	// - By name: {name: "Production Deploy"}
	//
	// Input:
	// ApiResourceReference with one of: id, slug, or name
	//
	// Returns:
	// Complete WorkflowInstance resource matching the reference.
	//
	// Authorization:
	// Uses custom authorization logic in the handler.
	// Allows for flexible authorization based on reference type and context.
	// Typical checks:
	// - User has get permission on the resolved instance
	// - Instance owner scope matches user's organization/identity
	//
	// Use Cases:
	// - User-friendly lookups by slug instead of opaque IDs
	// - CLI commands using human-readable names
	// - API integrations using stable slugs
	//
	// Example:
	// Input: ApiResourceReference{slug: "prod-deploy"}
	// Output: WorkflowInstance with metadata.slug = "prod-deploy"
	//
	// Error: PERMISSION_DENIED if user lacks access
	// Error: NOT_FOUND if reference doesn't resolve to an instance
	GetByReference(context.Context, *apiresource.ApiResourceReference) (*WorkflowInstance, error)
	mustEmbedUnimplementedWorkflowInstanceQueryControllerServer()
}

// UnimplementedWorkflowInstanceQueryControllerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWorkflowInstanceQueryControllerServer struct{}

func (UnimplementedWorkflowInstanceQueryControllerServer) Get(context.Context, *WorkflowInstanceId) (*WorkflowInstance, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedWorkflowInstanceQueryControllerServer) GetByWorkflow(context.Context, *GetWorkflowInstancesByWorkflowRequest) (*WorkflowInstanceList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetByWorkflow not implemented")
}
func (UnimplementedWorkflowInstanceQueryControllerServer) GetByReference(context.Context, *apiresource.ApiResourceReference) (*WorkflowInstance, error) {
	return nil, status.Error(codes.Unimplemented, "method GetByReference not implemented")
}
func (UnimplementedWorkflowInstanceQueryControllerServer) mustEmbedUnimplementedWorkflowInstanceQueryControllerServer() {
}
func (UnimplementedWorkflowInstanceQueryControllerServer) testEmbeddedByValue() {}

// UnsafeWorkflowInstanceQueryControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkflowInstanceQueryControllerServer will
// result in compilation errors.
type UnsafeWorkflowInstanceQueryControllerServer interface {
	mustEmbedUnimplementedWorkflowInstanceQueryControllerServer()
}

func RegisterWorkflowInstanceQueryControllerServer(s grpc.ServiceRegistrar, srv WorkflowInstanceQueryControllerServer) {
	// If the following call panics, it indicates UnimplementedWorkflowInstanceQueryControllerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WorkflowInstanceQueryController_ServiceDesc, srv)
}

func _WorkflowInstanceQueryController_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowInstanceId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowInstanceQueryControllerServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowInstanceQueryController_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowInstanceQueryControllerServer).Get(ctx, req.(*WorkflowInstanceId))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowInstanceQueryController_GetByWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWorkflowInstancesByWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowInstanceQueryControllerServer).GetByWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowInstanceQueryController_GetByWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowInstanceQueryControllerServer).GetByWorkflow(ctx, req.(*GetWorkflowInstancesByWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowInstanceQueryController_GetByReference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(apiresource.ApiResourceReference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowInstanceQueryControllerServer).GetByReference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowInstanceQueryController_GetByReference_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowInstanceQueryControllerServer).GetByReference(ctx, req.(*apiresource.ApiResourceReference))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkflowInstanceQueryController_ServiceDesc is the grpc.ServiceDesc for WorkflowInstanceQueryController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkflowInstanceQueryController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ai.stigmer.agentic.workflowinstance.v1.WorkflowInstanceQueryController",
	HandlerType: (*WorkflowInstanceQueryControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "get",
			Handler:    _WorkflowInstanceQueryController_Get_Handler,
		},
		{
			MethodName: "getByWorkflow",
			Handler:    _WorkflowInstanceQueryController_GetByWorkflow_Handler,
		},
		{
			MethodName: "getByReference",
			Handler:    _WorkflowInstanceQueryController_GetByReference_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ai/stigmer/agentic/workflowinstance/v1/query.proto",
}
