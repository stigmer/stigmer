// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: ai/stigmer/agentic/workflowexecution/v1/query.proto

package workflowexecutionv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	WorkflowExecutionQueryController_Get_FullMethodName            = "/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionQueryController/get"
	WorkflowExecutionQueryController_List_FullMethodName           = "/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionQueryController/list"
	WorkflowExecutionQueryController_ListByWorkflow_FullMethodName = "/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionQueryController/listByWorkflow"
	WorkflowExecutionQueryController_Subscribe_FullMethodName      = "/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionQueryController/subscribe"
)

// WorkflowExecutionQueryControllerClient is the client API for WorkflowExecutionQueryController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// WorkflowExecutionQueryController handles read operations (Get, List, Subscribe) for WorkflowExecution resources.
//
// This service follows the Command-Query Separation (CQS) pattern:
// - CommandController: Write operations (create, update, delete)
// - QueryController: Read operations (get, list, search, subscribe)
//
// Authorization:
// - get: Standard authorization - user must have "get" permission on the specific WorkflowExecution
// - list: Custom authorization - filters results based on user's owner scope and permissions
// - list_by_workflow: Custom authorization - verifies user has access to the Workflow/WorkflowInstance
// - subscribe: Standard authorization - user must have "get" permission to subscribe to updates
//
// Service Options:
// - api_resource_kind: workflow_execution - Links this service to the WorkflowExecution resource
type WorkflowExecutionQueryControllerClient interface {
	// Get a single workflow execution by ID.
	//
	// Retrieves the complete WorkflowExecution resource including:
	// - spec: User inputs (workflow_instance_id, trigger_message, etc.)
	// - status: Current execution state (phase, tasks, progress_events, output/error)
	// - metadata: Resource identification (id, name, labels, tags)
	//
	// Authorization:
	// Standard authorization checks that user has "get" permission on the WorkflowExecution.
	// Permission is granted if:
	// - User created the execution (metadata.audit.created_by matches user)
	// - User has organization-level "workflow_execution:get" permission
	// - User has explicit permission via IamPolicy
	//
	// Use Cases:
	//
	// 1. View Execution Details:
	// - User clicks on an execution in the UI
	// - UI calls get() to fetch full details
	// - UI displays execution status, tasks, progress, output/error
	//
	// 2. Poll for Completion:
	// - Client triggers execution via create()
	// - Client periodically calls get() to check if phase is terminal
	// - Client retrieves output when phase == EXECUTION_COMPLETED
	//
	// 3. Debug Failed Execution:
	// - User sees execution failed
	// - User calls get() to inspect status.error and status.tasks
	// - User checks status.tasks[] for task-level execution details
	//
	// 4. Retry Failed Execution:
	// - User calls get() to retrieve failed execution's spec
	// - User creates new execution with same spec values
	// - New execution retries with identical inputs
	//
	// Error Cases:
	//
	// - NOT_FOUND:
	//   - No WorkflowExecution exists with the given ID
	//
	// - PERMISSION_DENIED:
	//   - User doesn't have "get" permission on this WorkflowExecution
	//   - WorkflowExecution belongs to different organization
	//
	// Example Request:
	//
	//	{
	//	  "value": "wfx-abc123xyz456"
	//	}
	//
	// Example Response:
	//
	//	{
	//	  "api_version": "agentic.stigmer.ai/v1",
	//	  "kind": "WorkflowExecution",
	//	  "metadata": {
	//	    "id": "wfx-abc123xyz456",
	//	    "name": "customer-onboarding-20250111-143022",
	//	    "owner_scope": 2  // ORGANIZATION
	//	  },
	//	  "spec": {
	//	    "workflow_instance_id": "wfi-customer-onboarding-prod",
	//	    "trigger_message": "New signup: john.doe@example.com"
	//	  },
	//	  "status": {
	//	    "phase": 2,  // EXECUTION_IN_PROGRESS
	//	    "total_tasks": 3,
	//	    "completed_tasks": 1,
	//	    "tasks": [ ... ],
	//	    "started_at": "2025-01-11T14:30:22Z"
	//	  }
	//	}
	Get(ctx context.Context, in *WorkflowExecutionId, opts ...grpc.CallOption) (*WorkflowExecution, error)
	// List workflow executions with pagination and optional filtering.
	//
	// Returns a paginated list of WorkflowExecution resources that the user has access to.
	// Results are automatically filtered based on user's permissions and owner scope.
	//
	// Authorization:
	// Custom authorization filters results to only include executions the user can access:
	// - Organization users: Only executions in their organization
	// - Identity account users: Only their own executions
	// - Platform admins: All executions (filtered by owner_scope in request)
	//
	// Pagination:
	// - page_size: Maximum number of results to return (default: 50, max: 100)
	// - page_token: Opaque token from previous response for next page
	// - Returns total_pages count for UI pagination
	//
	// Filtering:
	// - phase: Filter by execution phase (PENDING, IN_PROGRESS, COMPLETED, FAILED, CANCELLED)
	// - tags: Filter by resource tags (AND logic - must match all tags)
	//
	// Sorting:
	// Results are sorted by created_at descending (newest first).
	//
	// Use Cases:
	//
	// 1. Execution History Dashboard:
	// - UI displays list of all recent executions
	// - User can filter by status (show only failed, show only in-progress)
	// - User can page through historical executions
	//
	// 2. Monitor Active Executions:
	// - UI calls list(phase=EXECUTION_IN_PROGRESS) to show running executions
	// - UI displays progress for each execution (completed_tasks / total_tasks)
	// - UI refreshes list periodically to show updates
	//
	// 3. Audit and Compliance:
	// - Admin lists all executions for a time period
	// - Admin filters by tags (environment, team, project)
	// - Admin exports execution history for audit logs
	//
	// 4. Debug and Troubleshooting:
	// - Developer lists failed executions (phase=EXECUTION_FAILED)
	// - Developer inspects error messages and retry patterns
	// - Developer identifies systematic failures
	//
	// Error Cases:
	//
	// - INVALID_ARGUMENT:
	//   - page_size is negative or exceeds maximum
	//   - Invalid page_token (expired, corrupted)
	//
	// Example Request (Filter for failed executions):
	//
	//	{
	//	  "page_size": 20,
	//	  "phase": 4,  // EXECUTION_FAILED
	//	  "tags": ["environment:production"]
	//	}
	//
	// Example Response:
	//
	//	{
	//	  "total_pages": 3,
	//	  "entries": [
	//	    {
	//	      "metadata": { "id": "wfx-failed-1", ... },
	//	      "status": { "phase": 4, "error": "Task failed: API timeout", ... }
	//	    },
	//	    {
	//	      "metadata": { "id": "wfx-failed-2", ... },
	//	      "status": { "phase": 4, "error": "Task failed: Rate limit", ... }
	//	    }
	//	  ]
	//	}
	List(ctx context.Context, in *ListWorkflowExecutionsRequest, opts ...grpc.CallOption) (*WorkflowExecutionList, error)
	// List all executions for a specific Workflow or WorkflowInstance.
	//
	// Returns executions filtered by a specific Workflow ID.
	// This is useful for viewing execution history of a particular workflow.
	//
	// Authorization:
	// Custom authorization verifies:
	// 1. User has access to the referenced Workflow or WorkflowInstance
	// 2. Results are filtered to only include executions user can access
	//
	// Pagination:
	// - page_size: Maximum number of results to return (default: 50, max: 100)
	// - page_token: Opaque token from previous response for next page
	//
	// Sorting:
	// Results are sorted by created_at descending (newest first).
	//
	// Use Cases:
	//
	// 1. Workflow Execution History:
	// - User views a Workflow in the UI
	// - UI calls listByWorkflow(workflow_id) to show all executions
	// - UI displays timeline of executions with success/failure indicators
	//
	// 2. Performance Analysis:
	// - Developer wants to analyze workflow performance over time
	// - Developer calls listByWorkflow() to get all executions
	// - Developer calculates average duration, success rate, failure patterns
	//
	// 3. Retry Analysis:
	// - User sees failed execution
	// - User calls listByWorkflow() to see if other executions also failed
	// - User determines if failure is systematic or one-off
	//
	// 4. Workflow Testing:
	// - Developer tests a workflow with multiple executions
	// - Developer calls listByWorkflow() to see all test runs
	// - Developer compares outputs across executions
	//
	// Error Cases:
	//
	// - INVALID_ARGUMENT:
	//   - workflow_id is empty or invalid format
	//   - page_size is negative or exceeds maximum
	//
	// - PERMISSION_DENIED:
	//   - User doesn't have access to the referenced Workflow/WorkflowInstance
	//
	// - NOT_FOUND:
	//   - No Workflow or WorkflowInstance exists with the given ID
	//
	// Example Request:
	//
	//	{
	//	  "workflow_id": "wfi-customer-onboarding-prod",
	//	  "page_size": 50
	//	}
	//
	// Example Response:
	//
	//	{
	//	  "total_pages": 5,
	//	  "entries": [
	//	    {
	//	      "metadata": { "id": "wfx-latest", "created_at": "2025-01-11T14:30:22Z" },
	//	      "status": { "phase": 3, ... }  // COMPLETED
	//	    },
	//	    {
	//	      "metadata": { "id": "wfx-previous", "created_at": "2025-01-11T10:15:00Z" },
	//	      "status": { "phase": 4, ... }  // FAILED
	//	    }
	//	  ]
	//	}
	ListByWorkflow(ctx context.Context, in *ListWorkflowExecutionsByWorkflowRequest, opts ...grpc.CallOption) (*WorkflowExecutionList, error)
	// Subscribe to real-time updates for a specific workflow execution (server streaming).
	//
	// Opens a bidirectional stream that pushes WorkflowExecution updates as they occur.
	// Client receives updates when:
	// - Execution phase changes (PENDING → IN_PROGRESS → COMPLETED)
	// - Tasks start or complete
	// - Progress events are appended
	// - Output or error fields are set
	//
	// Authorization:
	// Standard authorization checks that user has "get" permission on the WorkflowExecution.
	// This is the same permission check as get() RPC.
	//
	// Stream Lifecycle:
	// 1. Client sends SubscribeWorkflowExecutionRequest with execution_id
	// 2. Server validates authorization
	// 3. Server sends initial WorkflowExecution (current state)
	// 4. Server streams updates as execution progresses
	// 5. Server closes stream when execution reaches terminal state (COMPLETED/FAILED/CANCELLED)
	// 6. Client can close stream early (e.g., user navigates away from page)
	//
	// Update Frequency:
	// - Updates are sent immediately when execution state changes
	// - No polling necessary (server pushes updates)
	// - Typical update latency: < 100ms
	//
	// Use Cases:
	//
	// 1. Real-Time Progress Monitoring:
	// - User triggers an execution from UI
	// - UI subscribes to execution updates
	// - UI displays live progress: tasks completing, progress bar updating
	// - UI shows final output when execution completes
	//
	// 2. Long-Running Workflow Monitoring:
	// - Workflow takes hours to complete (e.g., data processing)
	// - UI subscribes and shows live progress
	// - User can leave page, come back, and reconnect to same execution
	//
	// 3. Debugging with Live Updates:
	// - Developer triggers test execution
	// - Developer subscribes to watch execution progress
	// - Developer sees exactly which task is running and when failures occur
	//
	// 4. Multi-User Collaboration:
	// - Multiple users watching same execution
	// - All users receive same updates simultaneously
	// - All users see consistent view of execution state
	//
	// Stream Message Format:
	// Each message is a complete WorkflowExecution resource with updated status.
	//
	// Error Cases:
	//
	// - NOT_FOUND:
	//   - No WorkflowExecution exists with the given ID
	//
	// - PERMISSION_DENIED:
	//   - User doesn't have "get" permission on this WorkflowExecution
	//
	// - DEADLINE_EXCEEDED:
	//   - Client timeout (client should reconnect)
	//
	// - UNAVAILABLE:
	//   - Server unavailable (client should retry with backoff)
	//
	// Example Request:
	//
	//	{
	//	  "execution_id": "wfx-abc123xyz456"
	//	}
	//
	// Example Stream (sequence of messages):
	//
	// Message 1 (initial state):
	//
	//	{
	//	  "metadata": { "id": "wfx-abc123xyz456" },
	//	  "status": {
	//	    "phase": 1,  // EXECUTION_PENDING
	//	    "total_tasks": 3,
	//	    "completed_tasks": 0
	//	  }
	//	}
	//
	// Message 2 (execution started):
	//
	//	{
	//	  "metadata": { "id": "wfx-abc123xyz456" },
	//	  "status": {
	//	    "phase": 2,  // EXECUTION_IN_PROGRESS
	//	    "started_at": "2025-01-11T14:30:22Z"
	//	  }
	//	}
	//
	// Message 3 (task 1 completed):
	//
	//	{
	//	  "metadata": { "id": "wfx-abc123xyz456" },
	//	  "status": {
	//	    "phase": 2,  // EXECUTION_IN_PROGRESS
	//	    "completed_tasks": 1,
	//	    "tasks": [
	//	      { "task_id": "task-1", "status": 3, "output": { ... } }
	//	    ]
	//	  }
	//	}
	//
	// Message 4 (execution completed):
	//
	//	{
	//	  "metadata": { "id": "wfx-abc123xyz456" },
	//	  "status": {
	//	    "phase": 3,  // EXECUTION_COMPLETED
	//	    "completed_tasks": 3,
	//	    "output": { ... },
	//	    "completed_at": "2025-01-11T14:35:47Z"
	//	  }
	//	}
	//
	// [Stream closes]
	Subscribe(ctx context.Context, in *SubscribeWorkflowExecutionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WorkflowExecution], error)
}

type workflowExecutionQueryControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkflowExecutionQueryControllerClient(cc grpc.ClientConnInterface) WorkflowExecutionQueryControllerClient {
	return &workflowExecutionQueryControllerClient{cc}
}

func (c *workflowExecutionQueryControllerClient) Get(ctx context.Context, in *WorkflowExecutionId, opts ...grpc.CallOption) (*WorkflowExecution, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowExecution)
	err := c.cc.Invoke(ctx, WorkflowExecutionQueryController_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowExecutionQueryControllerClient) List(ctx context.Context, in *ListWorkflowExecutionsRequest, opts ...grpc.CallOption) (*WorkflowExecutionList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowExecutionList)
	err := c.cc.Invoke(ctx, WorkflowExecutionQueryController_List_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowExecutionQueryControllerClient) ListByWorkflow(ctx context.Context, in *ListWorkflowExecutionsByWorkflowRequest, opts ...grpc.CallOption) (*WorkflowExecutionList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowExecutionList)
	err := c.cc.Invoke(ctx, WorkflowExecutionQueryController_ListByWorkflow_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowExecutionQueryControllerClient) Subscribe(ctx context.Context, in *SubscribeWorkflowExecutionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[WorkflowExecution], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &WorkflowExecutionQueryController_ServiceDesc.Streams[0], WorkflowExecutionQueryController_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeWorkflowExecutionRequest, WorkflowExecution]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type WorkflowExecutionQueryController_SubscribeClient = grpc.ServerStreamingClient[WorkflowExecution]

// WorkflowExecutionQueryControllerServer is the server API for WorkflowExecutionQueryController service.
// All implementations must embed UnimplementedWorkflowExecutionQueryControllerServer
// for forward compatibility.
//
// WorkflowExecutionQueryController handles read operations (Get, List, Subscribe) for WorkflowExecution resources.
//
// This service follows the Command-Query Separation (CQS) pattern:
// - CommandController: Write operations (create, update, delete)
// - QueryController: Read operations (get, list, search, subscribe)
//
// Authorization:
// - get: Standard authorization - user must have "get" permission on the specific WorkflowExecution
// - list: Custom authorization - filters results based on user's owner scope and permissions
// - list_by_workflow: Custom authorization - verifies user has access to the Workflow/WorkflowInstance
// - subscribe: Standard authorization - user must have "get" permission to subscribe to updates
//
// Service Options:
// - api_resource_kind: workflow_execution - Links this service to the WorkflowExecution resource
type WorkflowExecutionQueryControllerServer interface {
	// Get a single workflow execution by ID.
	//
	// Retrieves the complete WorkflowExecution resource including:
	// - spec: User inputs (workflow_instance_id, trigger_message, etc.)
	// - status: Current execution state (phase, tasks, progress_events, output/error)
	// - metadata: Resource identification (id, name, labels, tags)
	//
	// Authorization:
	// Standard authorization checks that user has "get" permission on the WorkflowExecution.
	// Permission is granted if:
	// - User created the execution (metadata.audit.created_by matches user)
	// - User has organization-level "workflow_execution:get" permission
	// - User has explicit permission via IamPolicy
	//
	// Use Cases:
	//
	// 1. View Execution Details:
	// - User clicks on an execution in the UI
	// - UI calls get() to fetch full details
	// - UI displays execution status, tasks, progress, output/error
	//
	// 2. Poll for Completion:
	// - Client triggers execution via create()
	// - Client periodically calls get() to check if phase is terminal
	// - Client retrieves output when phase == EXECUTION_COMPLETED
	//
	// 3. Debug Failed Execution:
	// - User sees execution failed
	// - User calls get() to inspect status.error and status.tasks
	// - User checks status.tasks[] for task-level execution details
	//
	// 4. Retry Failed Execution:
	// - User calls get() to retrieve failed execution's spec
	// - User creates new execution with same spec values
	// - New execution retries with identical inputs
	//
	// Error Cases:
	//
	// - NOT_FOUND:
	//   - No WorkflowExecution exists with the given ID
	//
	// - PERMISSION_DENIED:
	//   - User doesn't have "get" permission on this WorkflowExecution
	//   - WorkflowExecution belongs to different organization
	//
	// Example Request:
	//
	//	{
	//	  "value": "wfx-abc123xyz456"
	//	}
	//
	// Example Response:
	//
	//	{
	//	  "api_version": "agentic.stigmer.ai/v1",
	//	  "kind": "WorkflowExecution",
	//	  "metadata": {
	//	    "id": "wfx-abc123xyz456",
	//	    "name": "customer-onboarding-20250111-143022",
	//	    "owner_scope": 2  // ORGANIZATION
	//	  },
	//	  "spec": {
	//	    "workflow_instance_id": "wfi-customer-onboarding-prod",
	//	    "trigger_message": "New signup: john.doe@example.com"
	//	  },
	//	  "status": {
	//	    "phase": 2,  // EXECUTION_IN_PROGRESS
	//	    "total_tasks": 3,
	//	    "completed_tasks": 1,
	//	    "tasks": [ ... ],
	//	    "started_at": "2025-01-11T14:30:22Z"
	//	  }
	//	}
	Get(context.Context, *WorkflowExecutionId) (*WorkflowExecution, error)
	// List workflow executions with pagination and optional filtering.
	//
	// Returns a paginated list of WorkflowExecution resources that the user has access to.
	// Results are automatically filtered based on user's permissions and owner scope.
	//
	// Authorization:
	// Custom authorization filters results to only include executions the user can access:
	// - Organization users: Only executions in their organization
	// - Identity account users: Only their own executions
	// - Platform admins: All executions (filtered by owner_scope in request)
	//
	// Pagination:
	// - page_size: Maximum number of results to return (default: 50, max: 100)
	// - page_token: Opaque token from previous response for next page
	// - Returns total_pages count for UI pagination
	//
	// Filtering:
	// - phase: Filter by execution phase (PENDING, IN_PROGRESS, COMPLETED, FAILED, CANCELLED)
	// - tags: Filter by resource tags (AND logic - must match all tags)
	//
	// Sorting:
	// Results are sorted by created_at descending (newest first).
	//
	// Use Cases:
	//
	// 1. Execution History Dashboard:
	// - UI displays list of all recent executions
	// - User can filter by status (show only failed, show only in-progress)
	// - User can page through historical executions
	//
	// 2. Monitor Active Executions:
	// - UI calls list(phase=EXECUTION_IN_PROGRESS) to show running executions
	// - UI displays progress for each execution (completed_tasks / total_tasks)
	// - UI refreshes list periodically to show updates
	//
	// 3. Audit and Compliance:
	// - Admin lists all executions for a time period
	// - Admin filters by tags (environment, team, project)
	// - Admin exports execution history for audit logs
	//
	// 4. Debug and Troubleshooting:
	// - Developer lists failed executions (phase=EXECUTION_FAILED)
	// - Developer inspects error messages and retry patterns
	// - Developer identifies systematic failures
	//
	// Error Cases:
	//
	// - INVALID_ARGUMENT:
	//   - page_size is negative or exceeds maximum
	//   - Invalid page_token (expired, corrupted)
	//
	// Example Request (Filter for failed executions):
	//
	//	{
	//	  "page_size": 20,
	//	  "phase": 4,  // EXECUTION_FAILED
	//	  "tags": ["environment:production"]
	//	}
	//
	// Example Response:
	//
	//	{
	//	  "total_pages": 3,
	//	  "entries": [
	//	    {
	//	      "metadata": { "id": "wfx-failed-1", ... },
	//	      "status": { "phase": 4, "error": "Task failed: API timeout", ... }
	//	    },
	//	    {
	//	      "metadata": { "id": "wfx-failed-2", ... },
	//	      "status": { "phase": 4, "error": "Task failed: Rate limit", ... }
	//	    }
	//	  ]
	//	}
	List(context.Context, *ListWorkflowExecutionsRequest) (*WorkflowExecutionList, error)
	// List all executions for a specific Workflow or WorkflowInstance.
	//
	// Returns executions filtered by a specific Workflow ID.
	// This is useful for viewing execution history of a particular workflow.
	//
	// Authorization:
	// Custom authorization verifies:
	// 1. User has access to the referenced Workflow or WorkflowInstance
	// 2. Results are filtered to only include executions user can access
	//
	// Pagination:
	// - page_size: Maximum number of results to return (default: 50, max: 100)
	// - page_token: Opaque token from previous response for next page
	//
	// Sorting:
	// Results are sorted by created_at descending (newest first).
	//
	// Use Cases:
	//
	// 1. Workflow Execution History:
	// - User views a Workflow in the UI
	// - UI calls listByWorkflow(workflow_id) to show all executions
	// - UI displays timeline of executions with success/failure indicators
	//
	// 2. Performance Analysis:
	// - Developer wants to analyze workflow performance over time
	// - Developer calls listByWorkflow() to get all executions
	// - Developer calculates average duration, success rate, failure patterns
	//
	// 3. Retry Analysis:
	// - User sees failed execution
	// - User calls listByWorkflow() to see if other executions also failed
	// - User determines if failure is systematic or one-off
	//
	// 4. Workflow Testing:
	// - Developer tests a workflow with multiple executions
	// - Developer calls listByWorkflow() to see all test runs
	// - Developer compares outputs across executions
	//
	// Error Cases:
	//
	// - INVALID_ARGUMENT:
	//   - workflow_id is empty or invalid format
	//   - page_size is negative or exceeds maximum
	//
	// - PERMISSION_DENIED:
	//   - User doesn't have access to the referenced Workflow/WorkflowInstance
	//
	// - NOT_FOUND:
	//   - No Workflow or WorkflowInstance exists with the given ID
	//
	// Example Request:
	//
	//	{
	//	  "workflow_id": "wfi-customer-onboarding-prod",
	//	  "page_size": 50
	//	}
	//
	// Example Response:
	//
	//	{
	//	  "total_pages": 5,
	//	  "entries": [
	//	    {
	//	      "metadata": { "id": "wfx-latest", "created_at": "2025-01-11T14:30:22Z" },
	//	      "status": { "phase": 3, ... }  // COMPLETED
	//	    },
	//	    {
	//	      "metadata": { "id": "wfx-previous", "created_at": "2025-01-11T10:15:00Z" },
	//	      "status": { "phase": 4, ... }  // FAILED
	//	    }
	//	  ]
	//	}
	ListByWorkflow(context.Context, *ListWorkflowExecutionsByWorkflowRequest) (*WorkflowExecutionList, error)
	// Subscribe to real-time updates for a specific workflow execution (server streaming).
	//
	// Opens a bidirectional stream that pushes WorkflowExecution updates as they occur.
	// Client receives updates when:
	// - Execution phase changes (PENDING → IN_PROGRESS → COMPLETED)
	// - Tasks start or complete
	// - Progress events are appended
	// - Output or error fields are set
	//
	// Authorization:
	// Standard authorization checks that user has "get" permission on the WorkflowExecution.
	// This is the same permission check as get() RPC.
	//
	// Stream Lifecycle:
	// 1. Client sends SubscribeWorkflowExecutionRequest with execution_id
	// 2. Server validates authorization
	// 3. Server sends initial WorkflowExecution (current state)
	// 4. Server streams updates as execution progresses
	// 5. Server closes stream when execution reaches terminal state (COMPLETED/FAILED/CANCELLED)
	// 6. Client can close stream early (e.g., user navigates away from page)
	//
	// Update Frequency:
	// - Updates are sent immediately when execution state changes
	// - No polling necessary (server pushes updates)
	// - Typical update latency: < 100ms
	//
	// Use Cases:
	//
	// 1. Real-Time Progress Monitoring:
	// - User triggers an execution from UI
	// - UI subscribes to execution updates
	// - UI displays live progress: tasks completing, progress bar updating
	// - UI shows final output when execution completes
	//
	// 2. Long-Running Workflow Monitoring:
	// - Workflow takes hours to complete (e.g., data processing)
	// - UI subscribes and shows live progress
	// - User can leave page, come back, and reconnect to same execution
	//
	// 3. Debugging with Live Updates:
	// - Developer triggers test execution
	// - Developer subscribes to watch execution progress
	// - Developer sees exactly which task is running and when failures occur
	//
	// 4. Multi-User Collaboration:
	// - Multiple users watching same execution
	// - All users receive same updates simultaneously
	// - All users see consistent view of execution state
	//
	// Stream Message Format:
	// Each message is a complete WorkflowExecution resource with updated status.
	//
	// Error Cases:
	//
	// - NOT_FOUND:
	//   - No WorkflowExecution exists with the given ID
	//
	// - PERMISSION_DENIED:
	//   - User doesn't have "get" permission on this WorkflowExecution
	//
	// - DEADLINE_EXCEEDED:
	//   - Client timeout (client should reconnect)
	//
	// - UNAVAILABLE:
	//   - Server unavailable (client should retry with backoff)
	//
	// Example Request:
	//
	//	{
	//	  "execution_id": "wfx-abc123xyz456"
	//	}
	//
	// Example Stream (sequence of messages):
	//
	// Message 1 (initial state):
	//
	//	{
	//	  "metadata": { "id": "wfx-abc123xyz456" },
	//	  "status": {
	//	    "phase": 1,  // EXECUTION_PENDING
	//	    "total_tasks": 3,
	//	    "completed_tasks": 0
	//	  }
	//	}
	//
	// Message 2 (execution started):
	//
	//	{
	//	  "metadata": { "id": "wfx-abc123xyz456" },
	//	  "status": {
	//	    "phase": 2,  // EXECUTION_IN_PROGRESS
	//	    "started_at": "2025-01-11T14:30:22Z"
	//	  }
	//	}
	//
	// Message 3 (task 1 completed):
	//
	//	{
	//	  "metadata": { "id": "wfx-abc123xyz456" },
	//	  "status": {
	//	    "phase": 2,  // EXECUTION_IN_PROGRESS
	//	    "completed_tasks": 1,
	//	    "tasks": [
	//	      { "task_id": "task-1", "status": 3, "output": { ... } }
	//	    ]
	//	  }
	//	}
	//
	// Message 4 (execution completed):
	//
	//	{
	//	  "metadata": { "id": "wfx-abc123xyz456" },
	//	  "status": {
	//	    "phase": 3,  // EXECUTION_COMPLETED
	//	    "completed_tasks": 3,
	//	    "output": { ... },
	//	    "completed_at": "2025-01-11T14:35:47Z"
	//	  }
	//	}
	//
	// [Stream closes]
	Subscribe(*SubscribeWorkflowExecutionRequest, grpc.ServerStreamingServer[WorkflowExecution]) error
	mustEmbedUnimplementedWorkflowExecutionQueryControllerServer()
}

// UnimplementedWorkflowExecutionQueryControllerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWorkflowExecutionQueryControllerServer struct{}

func (UnimplementedWorkflowExecutionQueryControllerServer) Get(context.Context, *WorkflowExecutionId) (*WorkflowExecution, error) {
	return nil, status.Error(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedWorkflowExecutionQueryControllerServer) List(context.Context, *ListWorkflowExecutionsRequest) (*WorkflowExecutionList, error) {
	return nil, status.Error(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedWorkflowExecutionQueryControllerServer) ListByWorkflow(context.Context, *ListWorkflowExecutionsByWorkflowRequest) (*WorkflowExecutionList, error) {
	return nil, status.Error(codes.Unimplemented, "method ListByWorkflow not implemented")
}
func (UnimplementedWorkflowExecutionQueryControllerServer) Subscribe(*SubscribeWorkflowExecutionRequest, grpc.ServerStreamingServer[WorkflowExecution]) error {
	return status.Error(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedWorkflowExecutionQueryControllerServer) mustEmbedUnimplementedWorkflowExecutionQueryControllerServer() {
}
func (UnimplementedWorkflowExecutionQueryControllerServer) testEmbeddedByValue() {}

// UnsafeWorkflowExecutionQueryControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkflowExecutionQueryControllerServer will
// result in compilation errors.
type UnsafeWorkflowExecutionQueryControllerServer interface {
	mustEmbedUnimplementedWorkflowExecutionQueryControllerServer()
}

func RegisterWorkflowExecutionQueryControllerServer(s grpc.ServiceRegistrar, srv WorkflowExecutionQueryControllerServer) {
	// If the following call panics, it indicates UnimplementedWorkflowExecutionQueryControllerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WorkflowExecutionQueryController_ServiceDesc, srv)
}

func _WorkflowExecutionQueryController_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowExecutionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowExecutionQueryControllerServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowExecutionQueryController_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowExecutionQueryControllerServer).Get(ctx, req.(*WorkflowExecutionId))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowExecutionQueryController_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkflowExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowExecutionQueryControllerServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowExecutionQueryController_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowExecutionQueryControllerServer).List(ctx, req.(*ListWorkflowExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowExecutionQueryController_ListByWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWorkflowExecutionsByWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowExecutionQueryControllerServer).ListByWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowExecutionQueryController_ListByWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowExecutionQueryControllerServer).ListByWorkflow(ctx, req.(*ListWorkflowExecutionsByWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowExecutionQueryController_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeWorkflowExecutionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(WorkflowExecutionQueryControllerServer).Subscribe(m, &grpc.GenericServerStream[SubscribeWorkflowExecutionRequest, WorkflowExecution]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type WorkflowExecutionQueryController_SubscribeServer = grpc.ServerStreamingServer[WorkflowExecution]

// WorkflowExecutionQueryController_ServiceDesc is the grpc.ServiceDesc for WorkflowExecutionQueryController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkflowExecutionQueryController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionQueryController",
	HandlerType: (*WorkflowExecutionQueryControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "get",
			Handler:    _WorkflowExecutionQueryController_Get_Handler,
		},
		{
			MethodName: "list",
			Handler:    _WorkflowExecutionQueryController_List_Handler,
		},
		{
			MethodName: "listByWorkflow",
			Handler:    _WorkflowExecutionQueryController_ListByWorkflow_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "subscribe",
			Handler:       _WorkflowExecutionQueryController_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ai/stigmer/agentic/workflowexecution/v1/query.proto",
}
