// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: ai/stigmer/agentic/workflowexecution/v1/command.proto

package workflowexecutionv1

import (
	context "context"
	apiresource "github.com/stigmer/stigmer/internal/gen/ai/stigmer/commons/apiresource"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	WorkflowExecutionCommandController_Create_FullMethodName       = "/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController/create"
	WorkflowExecutionCommandController_Update_FullMethodName       = "/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController/update"
	WorkflowExecutionCommandController_UpdateStatus_FullMethodName = "/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController/updateStatus"
	WorkflowExecutionCommandController_Delete_FullMethodName       = "/ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController/delete"
)

// WorkflowExecutionCommandControllerClient is the client API for WorkflowExecutionCommandController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// WorkflowExecutionCommandController handles write operations (Create, Update, Delete) for WorkflowExecution resources.
//
// This service follows the Command-Query Separation (CQS) pattern:
// - CommandController: Write operations (create, update, delete)
// - QueryController: Read operations (get, list, search)
//
// Authorization:
// All RPCs use custom authorization logic implemented in middleware.
// Custom authorization is needed because:
// - create: Must verify user has "execute" permission on the referenced WorkflowInstance
// - update: Only the workflow runner (system) can update execution status, not users
//
// Service Options:
// - api_resource_kind: workflow_execution - Links this service to the WorkflowExecution resource
type WorkflowExecutionCommandControllerClient interface {
	// Create and trigger a new workflow execution.
	//
	// This RPC creates a WorkflowExecution resource and immediately triggers it for execution.
	// The workflow execution engine (Temporal) picks up the execution and begins processing tasks.
	//
	// Input Validation:
	// - metadata.owner_scope must be ORGANIZATION or IDENTITY_ACCOUNT (not PLATFORM)
	// - spec.workflow_instance_id is required and must reference an existing WorkflowInstance
	// - api_version must be exactly "agentic.stigmer.ai/v1"
	// - kind must be exactly "WorkflowExecution"
	//
	// Authorization:
	// Custom authorization verifies:
	// 1. User has "execute" permission on the referenced WorkflowInstance
	// 2. User has access to all referenced Environments (from WorkflowInstance)
	// 3. User has access to all referenced Secrets (from runtime_env secret_refs)
	//
	// Execution Flow:
	// 1. Validate input (proto validation + business rules)
	// 2. Check authorization (user can execute WorkflowInstance)
	// 3. Create WorkflowExecution resource in database
	// 4. Set initial status.phase = EXECUTION_PENDING
	// 5. Trigger workflow in execution engine (Temporal)
	// 6. Return WorkflowExecution with status.phase = EXECUTION_PENDING or EXECUTION_IN_PROGRESS
	//
	// Status After Create:
	// - status.phase: EXECUTION_PENDING (or EXECUTION_IN_PROGRESS if already picked up)
	// - status.audit.created_at: Current timestamp
	// - status.audit.created_by: Authenticated user ID
	// - status.started_at: Not set yet (set when phase transitions to IN_PROGRESS)
	//
	// Use Cases:
	//
	// 1. API-Triggered Execution:
	// - User calls API to execute a workflow
	// - Input: WorkflowExecution with spec.workflow_instance_id and spec.trigger_message
	// - Output: WorkflowExecution with generated ID and PENDING status
	//
	// 2. Webhook-Triggered Execution:
	// - External system (Stripe, GitHub, etc.) sends webhook
	// - Webhook handler creates WorkflowExecution with webhook payload in spec.trigger_message
	// - spec.trigger_metadata captures webhook source, event type, timestamp
	//
	// 3. Scheduled Execution:
	// - Scheduler service creates WorkflowExecution at scheduled time
	// - spec.trigger_metadata includes schedule ID and cron expression
	//
	// 4. UI-Triggered Execution:
	// - User clicks "Execute" button in web console
	// - UI creates WorkflowExecution with user-provided inputs
	//
	// 5. Workflow Chaining (Workflow A triggers Workflow B):
	// - Workflow A completes, creates WorkflowExecution for Workflow B
	// - spec.trigger_message contains output from Workflow A
	// - spec.trigger_metadata includes parent workflow execution ID
	//
	// Error Cases:
	//
	// - INVALID_ARGUMENT:
	//   - workflow_instance_id is missing or invalid
	//   - owner_scope is PLATFORM (not allowed)
	//   - api_version or kind is incorrect
	//
	// - PERMISSION_DENIED:
	//   - User doesn't have "execute" permission on WorkflowInstance
	//   - User doesn't have access to referenced Environments
	//   - User doesn't have access to referenced Secrets
	//
	// - NOT_FOUND:
	//   - Referenced WorkflowInstance doesn't exist
	//   - Referenced Environment doesn't exist
	//   - Referenced Secret doesn't exist
	//
	// - FAILED_PRECONDITION:
	//   - WorkflowInstance is in invalid state (e.g., archived, disabled)
	//   - Too many concurrent executions (quota exceeded)
	//
	// Example Request:
	//
	//	{
	//	  "api_version": "agentic.stigmer.ai/v1",
	//	  "kind": "WorkflowExecution",
	//	  "metadata": {
	//	    "name": "customer-onboarding-20250111-143022",
	//	    "owner_scope": 2  // ORGANIZATION
	//	  },
	//	  "spec": {
	//	    "workflow_instance_id": "wfi-customer-onboarding-prod",
	//	    "trigger_message": "New signup: john.doe@example.com",
	//	    "trigger_metadata": {
	//	      "source": "api",
	//	      "caller_id": "usr-jane-admin",
	//	      "timestamp": "2025-01-11T14:30:22Z"
	//	    },
	//	    "runtime_env": {
	//	      "CUSTOMER_EMAIL": { "value": "john.doe@example.com" }
	//	    }
	//	  }
	//	}
	//
	// Example Response:
	//
	//	{
	//	  "api_version": "agentic.stigmer.ai/v1",
	//	  "kind": "WorkflowExecution",
	//	  "metadata": {
	//	    "id": "wfx-abc123xyz456",  // Auto-generated
	//	    "name": "customer-onboarding-20250111-143022",
	//	    "owner_scope": 2
	//	  },
	//	  "spec": { ... },  // Same as request
	//	  "status": {
	//	    "phase": 1,  // EXECUTION_PENDING
	//	    "audit": {
	//	      "created_at": "2025-01-11T14:30:22Z",
	//	      "created_by": "usr-jane-admin"
	//	    }
	//	  }
	//	}
	Create(ctx context.Context, in *WorkflowExecution, opts ...grpc.CallOption) (*WorkflowExecution, error)
	// Update execution with full state.
	// Used by users to update execution configuration (spec fields).
	// No individual field updates - always provide complete state.
	Update(ctx context.Context, in *WorkflowExecution, opts ...grpc.CallOption) (*WorkflowExecution, error)
	// Update execution status during workflow execution.
	// Used by workflow-runner to send progressive status updates (messages, task states, phase, etc.)
	// This RPC is optimized for frequent status updates and merges status fields with existing state.
	//
	// This RPC is used by the workflow execution engine (Temporal) to update the status
	// of a running workflow execution. Users cannot call this RPC directly.
	//
	// What Can Be Updated:
	// - status.phase (PENDING → IN_PROGRESS → COMPLETED/FAILED/CANCELLED)
	// - status.tasks (update task statuses, outputs, errors)
	// - status.output (set final workflow output when COMPLETED)
	// - status.error (set error message when FAILED)
	// - status.started_at (set when execution starts)
	// - status.completed_at (set when execution finishes)
	//
	// What Cannot Be Updated:
	// - spec.* (user inputs are immutable after creation)
	// - metadata.id (resource ID is immutable)
	// - status.audit.created_at (creation timestamp is immutable)
	//
	// Authorization:
	// Custom authorization verifies:
	// 1. Caller is the workflow runner service (system identity, not a user)
	// 2. Only status fields are being modified (spec and metadata unchanged)
	//
	// Update Flow:
	// 1. Workflow runner executes a task
	// 2. Task completes/fails
	// 3. Workflow runner calls updateStatus() with:
	//   - Updated status.tasks (new task status, output/error)
	//   - Updated status.phase (if all tasks done)
	//
	// 4. Backend validates and persists update
	// 5. Backend broadcasts update via WebSocket (for real-time UI updates)
	//
	// Use Cases:
	//
	// 1. Task Started:
	// - Workflow runner updates status.tasks[i].status = IN_PROGRESS
	//
	// 2. Task Completed:
	// - Workflow runner updates status.tasks[i].status = COMPLETED
	// - Workflow runner sets status.tasks[i].output
	//
	// 3. Task Failed:
	// - Workflow runner updates status.tasks[i].status = FAILED
	// - Workflow runner sets status.tasks[i].error
	// - Workflow runner updates status.phase = EXECUTION_FAILED
	// - Workflow runner sets status.error
	// - Workflow runner sets status.completed_at
	//
	// 4. Workflow Completed:
	// - Workflow runner updates status.phase = EXECUTION_COMPLETED
	// - Workflow runner sets status.output
	// - Workflow runner sets status.completed_at
	//
	// 5. Workflow Cancelled:
	// - Workflow runner receives cancellation signal
	// - Workflow runner updates status.phase = EXECUTION_CANCELLED
	// - Workflow runner sets status.completed_at
	//
	// Error Cases:
	//
	// - PERMISSION_DENIED:
	//   - Caller is not the workflow runner service (users cannot update status)
	//
	// - INVALID_ARGUMENT:
	//   - Trying to modify spec or metadata (only status can be updated)
	//   - Invalid phase transition (e.g., COMPLETED → IN_PROGRESS)
	//
	// - NOT_FOUND:
	//   - WorkflowExecution with given ID doesn't exist
	//
	// Example Request (Task Completed):
	//
	//	{
	//	  "metadata": {
	//	    "id": "wfx-abc123xyz456"
	//	  },
	//	  "status": {
	//	    "phase": 2,  // EXECUTION_IN_PROGRESS
	//	    "completed_tasks": 1,
	//	    "tasks": [
	//	      {
	//	        "task_id": "task-1",
	//	        "task_name": "validate_email",
	//	        "status": 3,  // WORKFLOW_TASK_COMPLETED
	//	        "output": { "valid": true },
	//	        "completed_at": "2025-01-11T14:30:27Z"
	//	      },
	//	      {
	//	        "task_id": "task-2",
	//	        "task_name": "create_account",
	//	        "status": 2,  // WORKFLOW_TASK_IN_PROGRESS
	//	        "timestamp": "2025-01-11T14:30:27Z"
	//	      }
	//	    ]
	//	  }
	//	}
	UpdateStatus(ctx context.Context, in *WorkflowExecutionUpdateStatusInput, opts ...grpc.CallOption) (*WorkflowExecution, error)
	// Delete an execution.
	Delete(ctx context.Context, in *apiresource.ApiResourceId, opts ...grpc.CallOption) (*WorkflowExecution, error)
}

type workflowExecutionCommandControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkflowExecutionCommandControllerClient(cc grpc.ClientConnInterface) WorkflowExecutionCommandControllerClient {
	return &workflowExecutionCommandControllerClient{cc}
}

func (c *workflowExecutionCommandControllerClient) Create(ctx context.Context, in *WorkflowExecution, opts ...grpc.CallOption) (*WorkflowExecution, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowExecution)
	err := c.cc.Invoke(ctx, WorkflowExecutionCommandController_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowExecutionCommandControllerClient) Update(ctx context.Context, in *WorkflowExecution, opts ...grpc.CallOption) (*WorkflowExecution, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowExecution)
	err := c.cc.Invoke(ctx, WorkflowExecutionCommandController_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowExecutionCommandControllerClient) UpdateStatus(ctx context.Context, in *WorkflowExecutionUpdateStatusInput, opts ...grpc.CallOption) (*WorkflowExecution, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowExecution)
	err := c.cc.Invoke(ctx, WorkflowExecutionCommandController_UpdateStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowExecutionCommandControllerClient) Delete(ctx context.Context, in *apiresource.ApiResourceId, opts ...grpc.CallOption) (*WorkflowExecution, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowExecution)
	err := c.cc.Invoke(ctx, WorkflowExecutionCommandController_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkflowExecutionCommandControllerServer is the server API for WorkflowExecutionCommandController service.
// All implementations must embed UnimplementedWorkflowExecutionCommandControllerServer
// for forward compatibility.
//
// WorkflowExecutionCommandController handles write operations (Create, Update, Delete) for WorkflowExecution resources.
//
// This service follows the Command-Query Separation (CQS) pattern:
// - CommandController: Write operations (create, update, delete)
// - QueryController: Read operations (get, list, search)
//
// Authorization:
// All RPCs use custom authorization logic implemented in middleware.
// Custom authorization is needed because:
// - create: Must verify user has "execute" permission on the referenced WorkflowInstance
// - update: Only the workflow runner (system) can update execution status, not users
//
// Service Options:
// - api_resource_kind: workflow_execution - Links this service to the WorkflowExecution resource
type WorkflowExecutionCommandControllerServer interface {
	// Create and trigger a new workflow execution.
	//
	// This RPC creates a WorkflowExecution resource and immediately triggers it for execution.
	// The workflow execution engine (Temporal) picks up the execution and begins processing tasks.
	//
	// Input Validation:
	// - metadata.owner_scope must be ORGANIZATION or IDENTITY_ACCOUNT (not PLATFORM)
	// - spec.workflow_instance_id is required and must reference an existing WorkflowInstance
	// - api_version must be exactly "agentic.stigmer.ai/v1"
	// - kind must be exactly "WorkflowExecution"
	//
	// Authorization:
	// Custom authorization verifies:
	// 1. User has "execute" permission on the referenced WorkflowInstance
	// 2. User has access to all referenced Environments (from WorkflowInstance)
	// 3. User has access to all referenced Secrets (from runtime_env secret_refs)
	//
	// Execution Flow:
	// 1. Validate input (proto validation + business rules)
	// 2. Check authorization (user can execute WorkflowInstance)
	// 3. Create WorkflowExecution resource in database
	// 4. Set initial status.phase = EXECUTION_PENDING
	// 5. Trigger workflow in execution engine (Temporal)
	// 6. Return WorkflowExecution with status.phase = EXECUTION_PENDING or EXECUTION_IN_PROGRESS
	//
	// Status After Create:
	// - status.phase: EXECUTION_PENDING (or EXECUTION_IN_PROGRESS if already picked up)
	// - status.audit.created_at: Current timestamp
	// - status.audit.created_by: Authenticated user ID
	// - status.started_at: Not set yet (set when phase transitions to IN_PROGRESS)
	//
	// Use Cases:
	//
	// 1. API-Triggered Execution:
	// - User calls API to execute a workflow
	// - Input: WorkflowExecution with spec.workflow_instance_id and spec.trigger_message
	// - Output: WorkflowExecution with generated ID and PENDING status
	//
	// 2. Webhook-Triggered Execution:
	// - External system (Stripe, GitHub, etc.) sends webhook
	// - Webhook handler creates WorkflowExecution with webhook payload in spec.trigger_message
	// - spec.trigger_metadata captures webhook source, event type, timestamp
	//
	// 3. Scheduled Execution:
	// - Scheduler service creates WorkflowExecution at scheduled time
	// - spec.trigger_metadata includes schedule ID and cron expression
	//
	// 4. UI-Triggered Execution:
	// - User clicks "Execute" button in web console
	// - UI creates WorkflowExecution with user-provided inputs
	//
	// 5. Workflow Chaining (Workflow A triggers Workflow B):
	// - Workflow A completes, creates WorkflowExecution for Workflow B
	// - spec.trigger_message contains output from Workflow A
	// - spec.trigger_metadata includes parent workflow execution ID
	//
	// Error Cases:
	//
	// - INVALID_ARGUMENT:
	//   - workflow_instance_id is missing or invalid
	//   - owner_scope is PLATFORM (not allowed)
	//   - api_version or kind is incorrect
	//
	// - PERMISSION_DENIED:
	//   - User doesn't have "execute" permission on WorkflowInstance
	//   - User doesn't have access to referenced Environments
	//   - User doesn't have access to referenced Secrets
	//
	// - NOT_FOUND:
	//   - Referenced WorkflowInstance doesn't exist
	//   - Referenced Environment doesn't exist
	//   - Referenced Secret doesn't exist
	//
	// - FAILED_PRECONDITION:
	//   - WorkflowInstance is in invalid state (e.g., archived, disabled)
	//   - Too many concurrent executions (quota exceeded)
	//
	// Example Request:
	//
	//	{
	//	  "api_version": "agentic.stigmer.ai/v1",
	//	  "kind": "WorkflowExecution",
	//	  "metadata": {
	//	    "name": "customer-onboarding-20250111-143022",
	//	    "owner_scope": 2  // ORGANIZATION
	//	  },
	//	  "spec": {
	//	    "workflow_instance_id": "wfi-customer-onboarding-prod",
	//	    "trigger_message": "New signup: john.doe@example.com",
	//	    "trigger_metadata": {
	//	      "source": "api",
	//	      "caller_id": "usr-jane-admin",
	//	      "timestamp": "2025-01-11T14:30:22Z"
	//	    },
	//	    "runtime_env": {
	//	      "CUSTOMER_EMAIL": { "value": "john.doe@example.com" }
	//	    }
	//	  }
	//	}
	//
	// Example Response:
	//
	//	{
	//	  "api_version": "agentic.stigmer.ai/v1",
	//	  "kind": "WorkflowExecution",
	//	  "metadata": {
	//	    "id": "wfx-abc123xyz456",  // Auto-generated
	//	    "name": "customer-onboarding-20250111-143022",
	//	    "owner_scope": 2
	//	  },
	//	  "spec": { ... },  // Same as request
	//	  "status": {
	//	    "phase": 1,  // EXECUTION_PENDING
	//	    "audit": {
	//	      "created_at": "2025-01-11T14:30:22Z",
	//	      "created_by": "usr-jane-admin"
	//	    }
	//	  }
	//	}
	Create(context.Context, *WorkflowExecution) (*WorkflowExecution, error)
	// Update execution with full state.
	// Used by users to update execution configuration (spec fields).
	// No individual field updates - always provide complete state.
	Update(context.Context, *WorkflowExecution) (*WorkflowExecution, error)
	// Update execution status during workflow execution.
	// Used by workflow-runner to send progressive status updates (messages, task states, phase, etc.)
	// This RPC is optimized for frequent status updates and merges status fields with existing state.
	//
	// This RPC is used by the workflow execution engine (Temporal) to update the status
	// of a running workflow execution. Users cannot call this RPC directly.
	//
	// What Can Be Updated:
	// - status.phase (PENDING → IN_PROGRESS → COMPLETED/FAILED/CANCELLED)
	// - status.tasks (update task statuses, outputs, errors)
	// - status.output (set final workflow output when COMPLETED)
	// - status.error (set error message when FAILED)
	// - status.started_at (set when execution starts)
	// - status.completed_at (set when execution finishes)
	//
	// What Cannot Be Updated:
	// - spec.* (user inputs are immutable after creation)
	// - metadata.id (resource ID is immutable)
	// - status.audit.created_at (creation timestamp is immutable)
	//
	// Authorization:
	// Custom authorization verifies:
	// 1. Caller is the workflow runner service (system identity, not a user)
	// 2. Only status fields are being modified (spec and metadata unchanged)
	//
	// Update Flow:
	// 1. Workflow runner executes a task
	// 2. Task completes/fails
	// 3. Workflow runner calls updateStatus() with:
	//   - Updated status.tasks (new task status, output/error)
	//   - Updated status.phase (if all tasks done)
	//
	// 4. Backend validates and persists update
	// 5. Backend broadcasts update via WebSocket (for real-time UI updates)
	//
	// Use Cases:
	//
	// 1. Task Started:
	// - Workflow runner updates status.tasks[i].status = IN_PROGRESS
	//
	// 2. Task Completed:
	// - Workflow runner updates status.tasks[i].status = COMPLETED
	// - Workflow runner sets status.tasks[i].output
	//
	// 3. Task Failed:
	// - Workflow runner updates status.tasks[i].status = FAILED
	// - Workflow runner sets status.tasks[i].error
	// - Workflow runner updates status.phase = EXECUTION_FAILED
	// - Workflow runner sets status.error
	// - Workflow runner sets status.completed_at
	//
	// 4. Workflow Completed:
	// - Workflow runner updates status.phase = EXECUTION_COMPLETED
	// - Workflow runner sets status.output
	// - Workflow runner sets status.completed_at
	//
	// 5. Workflow Cancelled:
	// - Workflow runner receives cancellation signal
	// - Workflow runner updates status.phase = EXECUTION_CANCELLED
	// - Workflow runner sets status.completed_at
	//
	// Error Cases:
	//
	// - PERMISSION_DENIED:
	//   - Caller is not the workflow runner service (users cannot update status)
	//
	// - INVALID_ARGUMENT:
	//   - Trying to modify spec or metadata (only status can be updated)
	//   - Invalid phase transition (e.g., COMPLETED → IN_PROGRESS)
	//
	// - NOT_FOUND:
	//   - WorkflowExecution with given ID doesn't exist
	//
	// Example Request (Task Completed):
	//
	//	{
	//	  "metadata": {
	//	    "id": "wfx-abc123xyz456"
	//	  },
	//	  "status": {
	//	    "phase": 2,  // EXECUTION_IN_PROGRESS
	//	    "completed_tasks": 1,
	//	    "tasks": [
	//	      {
	//	        "task_id": "task-1",
	//	        "task_name": "validate_email",
	//	        "status": 3,  // WORKFLOW_TASK_COMPLETED
	//	        "output": { "valid": true },
	//	        "completed_at": "2025-01-11T14:30:27Z"
	//	      },
	//	      {
	//	        "task_id": "task-2",
	//	        "task_name": "create_account",
	//	        "status": 2,  // WORKFLOW_TASK_IN_PROGRESS
	//	        "timestamp": "2025-01-11T14:30:27Z"
	//	      }
	//	    ]
	//	  }
	//	}
	UpdateStatus(context.Context, *WorkflowExecutionUpdateStatusInput) (*WorkflowExecution, error)
	// Delete an execution.
	Delete(context.Context, *apiresource.ApiResourceId) (*WorkflowExecution, error)
	mustEmbedUnimplementedWorkflowExecutionCommandControllerServer()
}

// UnimplementedWorkflowExecutionCommandControllerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWorkflowExecutionCommandControllerServer struct{}

func (UnimplementedWorkflowExecutionCommandControllerServer) Create(context.Context, *WorkflowExecution) (*WorkflowExecution, error) {
	return nil, status.Error(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedWorkflowExecutionCommandControllerServer) Update(context.Context, *WorkflowExecution) (*WorkflowExecution, error) {
	return nil, status.Error(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedWorkflowExecutionCommandControllerServer) UpdateStatus(context.Context, *WorkflowExecutionUpdateStatusInput) (*WorkflowExecution, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateStatus not implemented")
}
func (UnimplementedWorkflowExecutionCommandControllerServer) Delete(context.Context, *apiresource.ApiResourceId) (*WorkflowExecution, error) {
	return nil, status.Error(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedWorkflowExecutionCommandControllerServer) mustEmbedUnimplementedWorkflowExecutionCommandControllerServer() {
}
func (UnimplementedWorkflowExecutionCommandControllerServer) testEmbeddedByValue() {}

// UnsafeWorkflowExecutionCommandControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkflowExecutionCommandControllerServer will
// result in compilation errors.
type UnsafeWorkflowExecutionCommandControllerServer interface {
	mustEmbedUnimplementedWorkflowExecutionCommandControllerServer()
}

func RegisterWorkflowExecutionCommandControllerServer(s grpc.ServiceRegistrar, srv WorkflowExecutionCommandControllerServer) {
	// If the following call panics, it indicates UnimplementedWorkflowExecutionCommandControllerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WorkflowExecutionCommandController_ServiceDesc, srv)
}

func _WorkflowExecutionCommandController_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowExecution)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowExecutionCommandControllerServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowExecutionCommandController_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowExecutionCommandControllerServer).Create(ctx, req.(*WorkflowExecution))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowExecutionCommandController_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowExecution)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowExecutionCommandControllerServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowExecutionCommandController_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowExecutionCommandControllerServer).Update(ctx, req.(*WorkflowExecution))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowExecutionCommandController_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowExecutionUpdateStatusInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowExecutionCommandControllerServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowExecutionCommandController_UpdateStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowExecutionCommandControllerServer).UpdateStatus(ctx, req.(*WorkflowExecutionUpdateStatusInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowExecutionCommandController_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(apiresource.ApiResourceId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowExecutionCommandControllerServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowExecutionCommandController_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowExecutionCommandControllerServer).Delete(ctx, req.(*apiresource.ApiResourceId))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkflowExecutionCommandController_ServiceDesc is the grpc.ServiceDesc for WorkflowExecutionCommandController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkflowExecutionCommandController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ai.stigmer.agentic.workflowexecution.v1.WorkflowExecutionCommandController",
	HandlerType: (*WorkflowExecutionCommandControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "create",
			Handler:    _WorkflowExecutionCommandController_Create_Handler,
		},
		{
			MethodName: "update",
			Handler:    _WorkflowExecutionCommandController_Update_Handler,
		},
		{
			MethodName: "updateStatus",
			Handler:    _WorkflowExecutionCommandController_UpdateStatus_Handler,
		},
		{
			MethodName: "delete",
			Handler:    _WorkflowExecutionCommandController_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ai/stigmer/agentic/workflowexecution/v1/command.proto",
}
