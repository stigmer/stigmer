// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: ai/stigmer/agentic/workflowrunner/v1/interface.proto

// Package ai.stigmer.agentic.workflowrunner.v1 defines the service interface
// that all workflow execution engines must implement to integrate with Stigmer.
//
// This package belongs to the Agentic bounded context and defines the contract
// between Stigmer's workflow orchestration layer and external execution engines
// (Temporal, Airflow, custom runners, etc.).
//
// ## Architecture Overview
//
// Workflow runners are external services that execute CNCF Serverless Workflow
// definitions on behalf of Stigmer. When a WorkflowExecution is created, Stigmer:
// 1. Fetches the workflow YAML from MongoDB
// 2. Resolves environment variables and secrets
// 3. Calls the runner's execute_async RPC
// 4. Tracks progress through Temporal/flows
//
// ## Future Evolution
//
// This package will eventually contain:
// - WorkflowRunner API resource - For registering execution services
// - WorkflowRunnerCommandController - CRUD operations for runner resources
// - WorkflowRunnerQueryController - Read operations for runner resources
//
// For now, it contains only the service interface definition.
//
// ## Component Distinction
//
// - **WorkflowRunner** (future API resource) - Registered execution service metadata
// - **WorkflowRunnerCommandController** (future) - CRUD operations for runner registration
// - **WorkflowExecutionService** (this file) - Service interface that runners implement
//
// ## Execution Model
//
// All workflow execution is **asynchronous** (fire-and-forget). The execute_async
// RPC returns immediately with execution metadata. Progress tracking happens through
// Temporal workflows and is captured in WorkflowExecution.status.progress_events.
//
// Runners must NOT use gRPC streaming for progress - instead, they should:
// 1. Accept execution request
// 2. Start workflow asynchronously
// 3. Return execution ID and status URLs
// 4. Update progress via Temporal signals/activities

package workflowrunnerv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	WorkflowRunnerServiceController_ExecuteAsync_FullMethodName    = "/ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController/executeAsync"
	WorkflowRunnerServiceController_CancelExecution_FullMethodName = "/ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController/cancelExecution"
	WorkflowRunnerServiceController_PauseExecution_FullMethodName  = "/ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController/pauseExecution"
	WorkflowRunnerServiceController_ResumeExecution_FullMethodName = "/ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController/resumeExecution"
)

// WorkflowRunnerServiceControllerClient is the client API for WorkflowRunnerServiceController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// WorkflowRunnerServiceController defines the service interface that all workflow
// execution engines must implement to integrate with Stigmer.
//
// This is the core contract enabling pluggable workflow execution backends.
// Runners can be anything from managed services (Temporal Cloud, Airflow) to
// custom in-house execution engines.
//
// ## Integration Model
//
// When registering a WorkflowRunner resource (future capability), users provide:
// - Endpoint URL implementing this service interface
// - Authentication credentials (API keys, mTLS certs)
// - Capabilities (supports pause/resume, resource limits, etc.)
//
// Stigmer validates runner health by calling a health check endpoint and routes
// workflow executions based on runner capabilities and availability.
//
// ## Execution Flow
//
// 1. User creates WorkflowExecution resource in Stigmer
// 2. Stigmer backend selects appropriate runner based on requirements
// 3. Stigmer calls runner's execute_async RPC with complete execution context
// 4. Runner starts execution and returns immediately with execution ID
// 5. Progress tracking happens through Temporal workflows/flows
// 6. Final results stored in WorkflowExecution.status
//
// ## Authorization
//
// Authorization for these RPCs is NOT handled through Stigmer's IAM policy system
// because runners are external services. Instead, runners authenticate via:
// - API keys in request headers
// - Mutual TLS certificates
// - Cloud provider IAM (for managed services)
//
// Runner endpoints should be secured and only accessible to Stigmer backend services.
type WorkflowRunnerServiceControllerClient interface {
	// Execute workflow asynchronously (fire-and-forget pattern).
	//
	// This is the primary RPC for workflow execution. It accepts a complete
	// execution context (workflow YAML, environment variables, metadata) and
	// starts execution asynchronously.
	//
	// ## Execution Semantics
	//
	// The runner MUST:
	// - Validate workflow YAML syntax
	// - Start execution in the background
	// - Return immediately with execution metadata
	// - Track progress independently
	// - Handle failures and retries according to workflow definition
	//
	// The runner SHOULD:
	// - Store execution state for resumability
	// - Emit progress events to Stigmer via callbacks
	// - Support graceful cancellation
	// - Enforce resource limits if specified
	//
	// ## Input Validation
	//
	// Runners should validate:
	// - workflow_execution_id is present and unique
	// - workflow_yaml is valid CNCF Serverless Workflow syntax
	// - env_vars don't contain malicious values
	// - config.max_timeout_seconds is within runner's limits
	//
	// ## Use Cases
	//
	// 1. **Deploy Infrastructure**: Workflow orchestrates Terraform/Pulumi runs
	// 2. **Data Pipeline**: Workflow coordinates ETL tasks across services
	// 3. **Multi-Agent Coordination**: Workflow executes agent collaboration tasks
	// 4. **Integration Testing**: Workflow runs end-to-end test scenarios
	// 5. **Incident Response**: Workflow automates runbook execution
	//
	// ## Error Handling
	//
	// Return gRPC errors for:
	// - INVALID_ARGUMENT: Malformed workflow YAML or missing required fields
	// - RESOURCE_EXHAUSTED: Runner at capacity, cannot accept new executions
	// - UNAVAILABLE: Runner temporarily unavailable (maintenance, overload)
	// - INTERNAL: Unexpected runner failure
	//
	// Do NOT return errors for workflow execution failures (tasks failing, timeouts).
	// Those should be tracked in progress events and final status.
	//
	// ## Example
	//
	// Input:
	// ```
	// workflow_execution_id: "wex-abc123def456"
	// workflow_yaml: |
	//
	//	name: deploy-infrastructure
	//	version: 1.0.0
	//	start: validate-config
	//	states:
	//	  - name: validate-config
	//	    type: operation
	//	    actions:
	//	      - name: check-terraform
	//	        functionRef: validate-terraform
	//
	//	env_vars: {
	//	  "AWS_REGION": "us-east-1",
	//	  "ENVIRONMENT": "production"
	//	}
	//
	//	config: {
	//	  max_timeout_seconds: 3600
	//	  debug_enabled: false
	//	}
	//
	// ```
	//
	// Response:
	// ```
	// workflow_execution_id: "wex-abc123def456"
	// status: "running"
	// message: "Workflow execution started successfully"
	// temporal_workflow_id: "deploy-infrastructure-20250111-104530"
	// subscribe_url: "wss://runner.example.com/ws/wex-abc123def456"
	// status_url: "https://runner.example.com/api/v1/executions/wex-abc123def456"
	// ```
	ExecuteAsync(ctx context.Context, in *WorkflowExecuteInput, opts ...grpc.CallOption) (*WorkflowExecuteResponse, error)
	// Cancel a running workflow execution.
	//
	// Requests graceful cancellation of an in-progress workflow. The runner should:
	// 1. Mark execution as cancelling
	// 2. Stop scheduling new tasks
	// 3. Wait for in-flight tasks to complete (unless force=true)
	// 4. Clean up resources (temporary files, locks, connections)
	// 5. Mark execution as cancelled
	//
	// ## Graceful vs Forced Cancellation
	//
	// - **Graceful** (force=false): Allow current tasks to complete, then stop
	// - **Forced** (force=true): Terminate immediately, may leave incomplete work
	//
	// Runners should default to graceful cancellation for data consistency.
	//
	// ## Idempotency
	//
	// Cancelling an already-cancelled or completed execution should succeed (no-op).
	// Multiple cancel requests for the same execution_id should be safe.
	//
	// ## Use Cases
	//
	// 1. User manually cancels long-running workflow via UI
	// 2. Timeout watchdog cancels stuck executions
	// 3. Cost control system cancels expensive workflows
	// 4. Deployment rollback cancels in-progress infrastructure changes
	//
	// ## Error Handling
	//
	// Return gRPC errors for:
	// - NOT_FOUND: execution_id doesn't exist
	// - FAILED_PRECONDITION: Execution already completed/failed (cannot cancel)
	//
	// Do NOT return errors if execution is already cancelled (idempotent success).
	//
	// ## Example
	//
	// Request:
	// ```
	// execution_id: "wex-abc123def456"
	// reason: "User requested cancellation via web console"
	// force: false
	// ```
	//
	// Response: Empty (success)
	CancelExecution(ctx context.Context, in *CancelExecutionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Pause a running workflow execution.
	//
	// Suspends workflow execution while preserving state for later resumption.
	// The runner should:
	// 1. Complete currently-executing tasks
	// 2. Checkpoint workflow state (variables, task status)
	// 3. Release execution resources (workers, locks)
	// 4. Mark execution as paused
	//
	// ## State Preservation
	//
	// Runners MUST preserve:
	// - Workflow input and output variables
	// - Task completion status
	// - Execution metadata and timestamps
	// - Pending task queue
	//
	// Runners MAY release:
	// - Worker processes/threads
	// - Network connections
	// - Temporary compute resources
	//
	// ## Use Cases
	//
	// 1. Cost optimization: Pause development workflows overnight
	// 2. Manual intervention: Pause for human approval before proceeding
	// 3. Dependency wait: Pause until external system is available
	// 4. Debugging: Pause execution to inspect state
	//
	// ## Runner Capability
	//
	// Not all runners support pause/resume (e.g., serverless functions).
	// Runners should return UNIMPLEMENTED if pause is not supported.
	//
	// ## Error Handling
	//
	// Return gRPC errors for:
	// - NOT_FOUND: execution_id doesn't exist
	// - FAILED_PRECONDITION: Execution not in running state
	// - UNIMPLEMENTED: Runner doesn't support pause/resume
	//
	// ## Example
	//
	// Request:
	// ```
	// execution_id: "wex-abc123def456"
	// reason: "Pausing for manual approval of infrastructure changes"
	// ```
	//
	// Response: Empty (success)
	PauseExecution(ctx context.Context, in *PauseExecutionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Resume a paused workflow execution.
	//
	// Restores workflow execution from paused state. The runner should:
	// 1. Restore workflow state from checkpoint
	// 2. Allocate execution resources (workers, connections)
	// 3. Resume from the next pending task
	// 4. Mark execution as running
	//
	// ## State Restoration
	//
	// Runners MUST restore:
	// - All workflow variables and task state
	// - Execution position (which task to execute next)
	// - Original execution configuration and timeouts
	//
	// ## Idempotency
	//
	// Resuming an already-running execution should succeed (no-op).
	// Multiple resume requests should be safe.
	//
	// ## Use Cases
	//
	// 1. Resume overnight-paused development workflows
	// 2. Continue after manual approval granted
	// 3. Resume after dependency becomes available
	// 4. Continue after debugging session
	//
	// ## Error Handling
	//
	// Return gRPC errors for:
	// - NOT_FOUND: execution_id doesn't exist
	// - FAILED_PRECONDITION: Execution not in paused state
	// - UNIMPLEMENTED: Runner doesn't support pause/resume
	//
	// ## Example
	//
	// Request:
	// ```
	// execution_id: "wex-abc123def456"
	// reason: "Manual approval granted, resuming deployment"
	// ```
	//
	// Response: Empty (success)
	ResumeExecution(ctx context.Context, in *ResumeExecutionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type workflowRunnerServiceControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkflowRunnerServiceControllerClient(cc grpc.ClientConnInterface) WorkflowRunnerServiceControllerClient {
	return &workflowRunnerServiceControllerClient{cc}
}

func (c *workflowRunnerServiceControllerClient) ExecuteAsync(ctx context.Context, in *WorkflowExecuteInput, opts ...grpc.CallOption) (*WorkflowExecuteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WorkflowExecuteResponse)
	err := c.cc.Invoke(ctx, WorkflowRunnerServiceController_ExecuteAsync_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowRunnerServiceControllerClient) CancelExecution(ctx context.Context, in *CancelExecutionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WorkflowRunnerServiceController_CancelExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowRunnerServiceControllerClient) PauseExecution(ctx context.Context, in *PauseExecutionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WorkflowRunnerServiceController_PauseExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workflowRunnerServiceControllerClient) ResumeExecution(ctx context.Context, in *ResumeExecutionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, WorkflowRunnerServiceController_ResumeExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkflowRunnerServiceControllerServer is the server API for WorkflowRunnerServiceController service.
// All implementations must embed UnimplementedWorkflowRunnerServiceControllerServer
// for forward compatibility.
//
// WorkflowRunnerServiceController defines the service interface that all workflow
// execution engines must implement to integrate with Stigmer.
//
// This is the core contract enabling pluggable workflow execution backends.
// Runners can be anything from managed services (Temporal Cloud, Airflow) to
// custom in-house execution engines.
//
// ## Integration Model
//
// When registering a WorkflowRunner resource (future capability), users provide:
// - Endpoint URL implementing this service interface
// - Authentication credentials (API keys, mTLS certs)
// - Capabilities (supports pause/resume, resource limits, etc.)
//
// Stigmer validates runner health by calling a health check endpoint and routes
// workflow executions based on runner capabilities and availability.
//
// ## Execution Flow
//
// 1. User creates WorkflowExecution resource in Stigmer
// 2. Stigmer backend selects appropriate runner based on requirements
// 3. Stigmer calls runner's execute_async RPC with complete execution context
// 4. Runner starts execution and returns immediately with execution ID
// 5. Progress tracking happens through Temporal workflows/flows
// 6. Final results stored in WorkflowExecution.status
//
// ## Authorization
//
// Authorization for these RPCs is NOT handled through Stigmer's IAM policy system
// because runners are external services. Instead, runners authenticate via:
// - API keys in request headers
// - Mutual TLS certificates
// - Cloud provider IAM (for managed services)
//
// Runner endpoints should be secured and only accessible to Stigmer backend services.
type WorkflowRunnerServiceControllerServer interface {
	// Execute workflow asynchronously (fire-and-forget pattern).
	//
	// This is the primary RPC for workflow execution. It accepts a complete
	// execution context (workflow YAML, environment variables, metadata) and
	// starts execution asynchronously.
	//
	// ## Execution Semantics
	//
	// The runner MUST:
	// - Validate workflow YAML syntax
	// - Start execution in the background
	// - Return immediately with execution metadata
	// - Track progress independently
	// - Handle failures and retries according to workflow definition
	//
	// The runner SHOULD:
	// - Store execution state for resumability
	// - Emit progress events to Stigmer via callbacks
	// - Support graceful cancellation
	// - Enforce resource limits if specified
	//
	// ## Input Validation
	//
	// Runners should validate:
	// - workflow_execution_id is present and unique
	// - workflow_yaml is valid CNCF Serverless Workflow syntax
	// - env_vars don't contain malicious values
	// - config.max_timeout_seconds is within runner's limits
	//
	// ## Use Cases
	//
	// 1. **Deploy Infrastructure**: Workflow orchestrates Terraform/Pulumi runs
	// 2. **Data Pipeline**: Workflow coordinates ETL tasks across services
	// 3. **Multi-Agent Coordination**: Workflow executes agent collaboration tasks
	// 4. **Integration Testing**: Workflow runs end-to-end test scenarios
	// 5. **Incident Response**: Workflow automates runbook execution
	//
	// ## Error Handling
	//
	// Return gRPC errors for:
	// - INVALID_ARGUMENT: Malformed workflow YAML or missing required fields
	// - RESOURCE_EXHAUSTED: Runner at capacity, cannot accept new executions
	// - UNAVAILABLE: Runner temporarily unavailable (maintenance, overload)
	// - INTERNAL: Unexpected runner failure
	//
	// Do NOT return errors for workflow execution failures (tasks failing, timeouts).
	// Those should be tracked in progress events and final status.
	//
	// ## Example
	//
	// Input:
	// ```
	// workflow_execution_id: "wex-abc123def456"
	// workflow_yaml: |
	//
	//	name: deploy-infrastructure
	//	version: 1.0.0
	//	start: validate-config
	//	states:
	//	  - name: validate-config
	//	    type: operation
	//	    actions:
	//	      - name: check-terraform
	//	        functionRef: validate-terraform
	//
	//	env_vars: {
	//	  "AWS_REGION": "us-east-1",
	//	  "ENVIRONMENT": "production"
	//	}
	//
	//	config: {
	//	  max_timeout_seconds: 3600
	//	  debug_enabled: false
	//	}
	//
	// ```
	//
	// Response:
	// ```
	// workflow_execution_id: "wex-abc123def456"
	// status: "running"
	// message: "Workflow execution started successfully"
	// temporal_workflow_id: "deploy-infrastructure-20250111-104530"
	// subscribe_url: "wss://runner.example.com/ws/wex-abc123def456"
	// status_url: "https://runner.example.com/api/v1/executions/wex-abc123def456"
	// ```
	ExecuteAsync(context.Context, *WorkflowExecuteInput) (*WorkflowExecuteResponse, error)
	// Cancel a running workflow execution.
	//
	// Requests graceful cancellation of an in-progress workflow. The runner should:
	// 1. Mark execution as cancelling
	// 2. Stop scheduling new tasks
	// 3. Wait for in-flight tasks to complete (unless force=true)
	// 4. Clean up resources (temporary files, locks, connections)
	// 5. Mark execution as cancelled
	//
	// ## Graceful vs Forced Cancellation
	//
	// - **Graceful** (force=false): Allow current tasks to complete, then stop
	// - **Forced** (force=true): Terminate immediately, may leave incomplete work
	//
	// Runners should default to graceful cancellation for data consistency.
	//
	// ## Idempotency
	//
	// Cancelling an already-cancelled or completed execution should succeed (no-op).
	// Multiple cancel requests for the same execution_id should be safe.
	//
	// ## Use Cases
	//
	// 1. User manually cancels long-running workflow via UI
	// 2. Timeout watchdog cancels stuck executions
	// 3. Cost control system cancels expensive workflows
	// 4. Deployment rollback cancels in-progress infrastructure changes
	//
	// ## Error Handling
	//
	// Return gRPC errors for:
	// - NOT_FOUND: execution_id doesn't exist
	// - FAILED_PRECONDITION: Execution already completed/failed (cannot cancel)
	//
	// Do NOT return errors if execution is already cancelled (idempotent success).
	//
	// ## Example
	//
	// Request:
	// ```
	// execution_id: "wex-abc123def456"
	// reason: "User requested cancellation via web console"
	// force: false
	// ```
	//
	// Response: Empty (success)
	CancelExecution(context.Context, *CancelExecutionRequest) (*emptypb.Empty, error)
	// Pause a running workflow execution.
	//
	// Suspends workflow execution while preserving state for later resumption.
	// The runner should:
	// 1. Complete currently-executing tasks
	// 2. Checkpoint workflow state (variables, task status)
	// 3. Release execution resources (workers, locks)
	// 4. Mark execution as paused
	//
	// ## State Preservation
	//
	// Runners MUST preserve:
	// - Workflow input and output variables
	// - Task completion status
	// - Execution metadata and timestamps
	// - Pending task queue
	//
	// Runners MAY release:
	// - Worker processes/threads
	// - Network connections
	// - Temporary compute resources
	//
	// ## Use Cases
	//
	// 1. Cost optimization: Pause development workflows overnight
	// 2. Manual intervention: Pause for human approval before proceeding
	// 3. Dependency wait: Pause until external system is available
	// 4. Debugging: Pause execution to inspect state
	//
	// ## Runner Capability
	//
	// Not all runners support pause/resume (e.g., serverless functions).
	// Runners should return UNIMPLEMENTED if pause is not supported.
	//
	// ## Error Handling
	//
	// Return gRPC errors for:
	// - NOT_FOUND: execution_id doesn't exist
	// - FAILED_PRECONDITION: Execution not in running state
	// - UNIMPLEMENTED: Runner doesn't support pause/resume
	//
	// ## Example
	//
	// Request:
	// ```
	// execution_id: "wex-abc123def456"
	// reason: "Pausing for manual approval of infrastructure changes"
	// ```
	//
	// Response: Empty (success)
	PauseExecution(context.Context, *PauseExecutionRequest) (*emptypb.Empty, error)
	// Resume a paused workflow execution.
	//
	// Restores workflow execution from paused state. The runner should:
	// 1. Restore workflow state from checkpoint
	// 2. Allocate execution resources (workers, connections)
	// 3. Resume from the next pending task
	// 4. Mark execution as running
	//
	// ## State Restoration
	//
	// Runners MUST restore:
	// - All workflow variables and task state
	// - Execution position (which task to execute next)
	// - Original execution configuration and timeouts
	//
	// ## Idempotency
	//
	// Resuming an already-running execution should succeed (no-op).
	// Multiple resume requests should be safe.
	//
	// ## Use Cases
	//
	// 1. Resume overnight-paused development workflows
	// 2. Continue after manual approval granted
	// 3. Resume after dependency becomes available
	// 4. Continue after debugging session
	//
	// ## Error Handling
	//
	// Return gRPC errors for:
	// - NOT_FOUND: execution_id doesn't exist
	// - FAILED_PRECONDITION: Execution not in paused state
	// - UNIMPLEMENTED: Runner doesn't support pause/resume
	//
	// ## Example
	//
	// Request:
	// ```
	// execution_id: "wex-abc123def456"
	// reason: "Manual approval granted, resuming deployment"
	// ```
	//
	// Response: Empty (success)
	ResumeExecution(context.Context, *ResumeExecutionRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedWorkflowRunnerServiceControllerServer()
}

// UnimplementedWorkflowRunnerServiceControllerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWorkflowRunnerServiceControllerServer struct{}

func (UnimplementedWorkflowRunnerServiceControllerServer) ExecuteAsync(context.Context, *WorkflowExecuteInput) (*WorkflowExecuteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExecuteAsync not implemented")
}
func (UnimplementedWorkflowRunnerServiceControllerServer) CancelExecution(context.Context, *CancelExecutionRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelExecution not implemented")
}
func (UnimplementedWorkflowRunnerServiceControllerServer) PauseExecution(context.Context, *PauseExecutionRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method PauseExecution not implemented")
}
func (UnimplementedWorkflowRunnerServiceControllerServer) ResumeExecution(context.Context, *ResumeExecutionRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method ResumeExecution not implemented")
}
func (UnimplementedWorkflowRunnerServiceControllerServer) mustEmbedUnimplementedWorkflowRunnerServiceControllerServer() {
}
func (UnimplementedWorkflowRunnerServiceControllerServer) testEmbeddedByValue() {}

// UnsafeWorkflowRunnerServiceControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkflowRunnerServiceControllerServer will
// result in compilation errors.
type UnsafeWorkflowRunnerServiceControllerServer interface {
	mustEmbedUnimplementedWorkflowRunnerServiceControllerServer()
}

func RegisterWorkflowRunnerServiceControllerServer(s grpc.ServiceRegistrar, srv WorkflowRunnerServiceControllerServer) {
	// If the following call panics, it indicates UnimplementedWorkflowRunnerServiceControllerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WorkflowRunnerServiceController_ServiceDesc, srv)
}

func _WorkflowRunnerServiceController_ExecuteAsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowExecuteInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowRunnerServiceControllerServer).ExecuteAsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowRunnerServiceController_ExecuteAsync_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowRunnerServiceControllerServer).ExecuteAsync(ctx, req.(*WorkflowExecuteInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowRunnerServiceController_CancelExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowRunnerServiceControllerServer).CancelExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowRunnerServiceController_CancelExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowRunnerServiceControllerServer).CancelExecution(ctx, req.(*CancelExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowRunnerServiceController_PauseExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowRunnerServiceControllerServer).PauseExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowRunnerServiceController_PauseExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowRunnerServiceControllerServer).PauseExecution(ctx, req.(*PauseExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkflowRunnerServiceController_ResumeExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkflowRunnerServiceControllerServer).ResumeExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkflowRunnerServiceController_ResumeExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkflowRunnerServiceControllerServer).ResumeExecution(ctx, req.(*ResumeExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkflowRunnerServiceController_ServiceDesc is the grpc.ServiceDesc for WorkflowRunnerServiceController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkflowRunnerServiceController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ai.stigmer.agentic.workflowrunner.v1.WorkflowRunnerServiceController",
	HandlerType: (*WorkflowRunnerServiceControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "executeAsync",
			Handler:    _WorkflowRunnerServiceController_ExecuteAsync_Handler,
		},
		{
			MethodName: "cancelExecution",
			Handler:    _WorkflowRunnerServiceController_CancelExecution_Handler,
		},
		{
			MethodName: "pauseExecution",
			Handler:    _WorkflowRunnerServiceController_PauseExecution_Handler,
		},
		{
			MethodName: "resumeExecution",
			Handler:    _WorkflowRunnerServiceController_ResumeExecution_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ai/stigmer/agentic/workflowrunner/v1/interface.proto",
}
