// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: ai/stigmer/agentic/workflowrunner/v1/io.proto

// Package ai.stigmer.agentic.workflowrunner.v1 contains input/output messages
// for the workflow execution service interface.
//
// These messages define the data contracts between Stigmer's workflow orchestration
// layer and workflow-runner service. They are used throughout the workflow execution
// lifecycle: initiation, progress tracking, and control.
//
// ## Message Categories
//
// - **Execution Input**: WorkflowExecuteInput
// - **Execution Output**: WorkflowExecuteResponse, WorkflowProgressEvent
// - **Lifecycle Control**: CancelExecutionRequest, PauseExecutionRequest, ResumeExecutionRequest
// - **Error Reporting**: ErrorDetails
//
// ## Design Philosophy (Agent-Runner Pattern)
//
// Follows the same pattern as agent-runner for consistency:
// - **Temporal workflow** passes execution_id to runner
// - **Runner queries** Stigmer service to fetch WorkflowExecution details
// - **Runner converts** WorkflowSpec proto to YAML using converter
// - **Progressive updates** sent via gRPC during execution
//
// This pattern ensures:
// - Single source of truth (MongoDB)
// - Fresh data at execution time
// - Simple Temporal interface
// - Real-time status updates

package workflowrunnerv1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// WorkflowExecuteInput is the execution request passed to workflow-runner.
//
// Following the agent-runner pattern, this message contains only the execution ID.
// The runner queries Stigmer service to fetch the complete WorkflowExecution details,
// ensuring fresh data and single source of truth.
//
// ## Execution Flow (Polyglot Temporal Workflow)
//
// 1. **Stigmer service** creates WorkflowExecution in MongoDB
// 2. **Stigmer service** starts Temporal workflow with execution_id
// 3. **Temporal workflow** (Java) calls workflow-runner activity
// 4. **workflow-runner** (Go activity):
//   - Queries WorkflowExecution from Stigmer via gRPC
//   - Fetches WorkflowInstance and Workflow
//   - Converts WorkflowSpec proto → YAML (using Phase 2 converter)
//   - Executes via Zigflow
//   - Sends progressive status updates via gRPC
//
// 5. **Temporal workflow** receives final status (observability)
//
// ## Why This Pattern?
//
// ✅ **Consistent with agent-runner** - Same architecture
// ✅ **Single source of truth** - Always fresh from MongoDB
// ✅ **Simple interface** - Just pass execution_id
// ✅ **Progressive updates** - Real-time status via gRPC
// ✅ **Type-safe** - Uses proto → YAML converter
//
// ## Backward Compatibility
//
// The `workflow_yaml` field remains for direct testing/debugging.
// In production, runner uses execution_id to query everything.
type WorkflowExecuteInput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Workflow execution ID to execute.
	//
	// Format: 'wfx-{ulid}' (e.g., 'wfx-01jbrxe9m7q8zn5v3c2k4g6w8t')
	// Generated by Stigmer backend when WorkflowExecution resource is created.
	//
	// ## What Happens Next
	//
	// 1. Runner queries WorkflowExecution from Stigmer service (gRPC)
	// 2. Runner extracts workflow_instance_id from WorkflowExecution.spec
	// 3. Runner queries WorkflowInstance to get workflow_id and environment_ids
	// 4. Runner queries Workflow to get WorkflowSpec (structured proto)
	// 5. Runner converts WorkflowSpec → YAML using proto_to_yaml converter
	// 6. Runner executes workflow via Zigflow
	// 7. Runner sends progressive status updates to Stigmer via gRPC
	//
	// ## Correlation
	//
	// This ID is used for:
	// - Querying WorkflowExecution from Stigmer
	// - Sending status updates during execution
	// - Log aggregation and debugging
	// - Temporal workflow observability
	//
	// Example: "wfx-01jbrxe9m7q8zn5v3c2k4g6w8t"
	WorkflowExecutionId string `protobuf:"bytes,1,opt,name=workflow_execution_id,json=workflowExecutionId,proto3" json:"workflow_execution_id,omitempty"`
	// Optional: Direct workflow YAML (for testing/debugging only).
	//
	// **Production use**: Leave empty, runner queries from Stigmer
	// **Testing use**: Provide YAML directly to bypass Stigmer query
	//
	// When empty, runner:
	// 1. Queries WorkflowExecution(execution_id) from Stigmer
	// 2. Fetches WorkflowInstance and Workflow
	// 3. Converts Workflow.spec → YAML
	//
	// When provided, runner uses this YAML directly (skip query).
	//
	// This is useful for:
	// - gRPC testing without full Stigmer setup
	// - Local development and debugging
	// - Golden tests with known YAML inputs
	//
	// Example:
	// ```yaml
	// document:
	//
	//	dsl: "1.0.0"
	//	namespace: "test"
	//	name: "simple-workflow"
	//	version: "1.0.0"
	//
	// do:
	//   - set:
	//     message: "Hello World"
	//     as: ${.}
	//
	// ```
	WorkflowYaml  string `protobuf:"bytes,2,opt,name=workflow_yaml,json=workflowYaml,proto3" json:"workflow_yaml,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkflowExecuteInput) Reset() {
	*x = WorkflowExecuteInput{}
	mi := &file_ai_stigmer_agentic_workflowrunner_v1_io_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowExecuteInput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowExecuteInput) ProtoMessage() {}

func (x *WorkflowExecuteInput) ProtoReflect() protoreflect.Message {
	mi := &file_ai_stigmer_agentic_workflowrunner_v1_io_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowExecuteInput.ProtoReflect.Descriptor instead.
func (*WorkflowExecuteInput) Descriptor() ([]byte, []int) {
	return file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDescGZIP(), []int{0}
}

func (x *WorkflowExecuteInput) GetWorkflowExecutionId() string {
	if x != nil {
		return x.WorkflowExecutionId
	}
	return ""
}

func (x *WorkflowExecuteInput) GetWorkflowYaml() string {
	if x != nil {
		return x.WorkflowYaml
	}
	return ""
}

// WorkflowExecuteResponse confirms that workflow execution has started.
//
// This is the immediate response from the execute_async RPC. It provides
// metadata for tracking execution progress and accessing real-time status.
//
// ## Execution Lifecycle
//
// After receiving this response:
// 1. Stigmer stores execution metadata in WorkflowExecution resource
// 2. UI subscribes to subscribe_url for real-time updates (WebSocket/SSE)
// 3. Backend polls status_url periodically for final results
// 4. Progress events flow through Temporal workflows
//
// ## Response Time
//
// Runners SHOULD return this response within 1-2 seconds. The execute_async
// pattern means execution continues in the background after returning.
type WorkflowExecuteResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for the workflow execution.
	//
	// Format: 'wex-{ulid}' (e.g., 'wex-01jbrxe9m7q8zn5v3c2k4g6w8t')
	//
	// This is the **same ID** from WorkflowExecuteInput.workflow_execution_id.
	// Runners MUST echo this ID back for correlation.
	//
	// Example: "wex-01jbrxe9m7q8zn5v3c2k4g6w8t"
	WorkflowExecutionId string `protobuf:"bytes,1,opt,name=workflow_execution_id,json=workflowExecutionId,proto3" json:"workflow_execution_id,omitempty"`
	// Initial execution status.
	//
	// Common initial status values:
	// - **pending**: Queued for execution, not started yet
	// - **running**: Execution started immediately
	//
	// Runners should return "running" if execution starts synchronously,
	// or "pending" if execution is queued (e.g., waiting for worker availability).
	//
	// Example: "running"
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	// Human-readable message about execution initiation.
	//
	// This message confirms to users that execution started successfully.
	// It should be concise and user-friendly.
	//
	// Examples:
	// - "Workflow execution started successfully"
	// - "Execution queued, waiting for available worker"
	// - "Starting Terraform deployment workflow"
	//
	// Example: "Workflow execution started successfully"
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	// Temporal workflow ID (runner-specific identifier).
	//
	// If the runner uses Temporal as its execution engine, this is the
	// Temporal workflow ID assigned to this execution.
	//
	// Format: Runner-specific (e.g., 'deploy-infrastructure-20250111-104530')
	//
	// ## Use Cases
	//
	// - Debugging: Look up execution in Temporal UI
	// - Direct control: Cancel/pause via Temporal CLI
	// - Metrics: Correlate Temporal metrics with Stigmer executions
	//
	// ## Other Runners
	//
	// Non-Temporal runners can use this field for their own execution IDs:
	// - Airflow: DAG run ID
	// - Custom: Internal execution reference
	//
	// Leave empty if not applicable.
	//
	// Example: "deploy-infrastructure-20250111-104530"
	TemporalWorkflowId string `protobuf:"bytes,4,opt,name=temporal_workflow_id,json=temporalWorkflowId,proto3" json:"temporal_workflow_id,omitempty"`
	// URL to subscribe to real-time progress updates (WebSocket or SSE).
	//
	// This URL provides a **streaming connection** for real-time progress events.
	// Clients can connect to receive WorkflowProgressEvent messages as they occur.
	//
	// ## Protocol
	//
	// Supported protocols:
	// - **WebSocket**: `wss://runner.example.com/ws/executions/{execution_id}`
	// - **Server-Sent Events (SSE)**: `https://runner.example.com/stream/executions/{execution_id}`
	//
	// ## Authentication
	//
	// URL may include authentication token:
	// - Query parameter: `wss://...?token=abc123`
	// - Header-based: Stigmer includes auth header when connecting
	//
	// ## Event Format
	//
	// Each event is a serialized WorkflowProgressEvent (JSON or protobuf).
	//
	// ## Connection Lifecycle
	//
	// - Client connects to URL
	// - Runner streams events until workflow completes
	// - Connection closes when workflow reaches terminal state (completed/failed/cancelled)
	//
	// ## Optional
	//
	// Not all runners support real-time streaming. Leave empty if not supported.
	//
	// Example: "wss://runner.example.com/ws/executions/wex-01jbrxe9m7q8zn5v3c2k4g6w8t"
	SubscribeUrl string `protobuf:"bytes,5,opt,name=subscribe_url,json=subscribeUrl,proto3" json:"subscribe_url,omitempty"`
	// URL to poll execution status.
	//
	// This URL provides **point-in-time status** for the execution.
	// Clients can poll periodically to check completion status and results.
	//
	// ## HTTP Method
	//
	// GET request returns current execution status (JSON or protobuf).
	//
	// ## Response Format
	//
	// ```json
	//
	//	{
	//	  "execution_id": "wex-01jbrxe9m7q8zn5v3c2k4g6w8t",
	//	  "status": "running",
	//	  "progress": 67,
	//	  "message": "Deploying infrastructure...",
	//	  "started_at": "2025-01-11T10:00:00Z",
	//	  "updated_at": "2025-01-11T10:15:30Z"
	//	}
	//
	// ```
	//
	// ## Polling Strategy
	//
	// Stigmer backend polls with exponential backoff:
	// - Initial: Every 5 seconds
	// - After 1 minute: Every 15 seconds
	// - After 5 minutes: Every 60 seconds
	//
	// ## Authentication
	//
	// URL may require authentication (API key, OAuth token).
	//
	// ## Required
	//
	// All runners MUST provide this URL for status polling.
	//
	// Example: "https://runner.example.com/api/v1/executions/wex-01jbrxe9m7q8zn5v3c2k4g6w8t/status"
	StatusUrl     string `protobuf:"bytes,6,opt,name=status_url,json=statusUrl,proto3" json:"status_url,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WorkflowExecuteResponse) Reset() {
	*x = WorkflowExecuteResponse{}
	mi := &file_ai_stigmer_agentic_workflowrunner_v1_io_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WorkflowExecuteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WorkflowExecuteResponse) ProtoMessage() {}

func (x *WorkflowExecuteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_ai_stigmer_agentic_workflowrunner_v1_io_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WorkflowExecuteResponse.ProtoReflect.Descriptor instead.
func (*WorkflowExecuteResponse) Descriptor() ([]byte, []int) {
	return file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDescGZIP(), []int{1}
}

func (x *WorkflowExecuteResponse) GetWorkflowExecutionId() string {
	if x != nil {
		return x.WorkflowExecutionId
	}
	return ""
}

func (x *WorkflowExecuteResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *WorkflowExecuteResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *WorkflowExecuteResponse) GetTemporalWorkflowId() string {
	if x != nil {
		return x.TemporalWorkflowId
	}
	return ""
}

func (x *WorkflowExecuteResponse) GetSubscribeUrl() string {
	if x != nil {
		return x.SubscribeUrl
	}
	return ""
}

func (x *WorkflowExecuteResponse) GetStatusUrl() string {
	if x != nil {
		return x.StatusUrl
	}
	return ""
}

// CancelExecutionRequest requests cancellation of a running workflow execution.
//
// Cancellation is **best-effort** - runners should attempt graceful shutdown
// but may need to forcefully terminate if cleanup takes too long.
//
// ## Idempotency
//
// Cancelling an already-cancelled or completed execution is a **no-op** (succeeds silently).
// This makes it safe to retry cancel requests without side effects.
//
// ## Audit Trail
//
// Runners should log cancellation events including:
// - Who requested cancellation (inferred from auth context)
// - When cancellation was requested
// - Cancellation reason (from this request)
// - Whether force=true was used
//
// This audit information helps with debugging and compliance.
type CancelExecutionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Workflow execution ID to cancel.
	//
	// Format: 'wex-{ulid}' (e.g., 'wex-01jbrxe9m7q8zn5v3c2k4g6w8t')
	//
	// This is the same ID returned in WorkflowExecuteResponse.
	//
	// ## Error Cases
	//
	// Return gRPC errors for:
	// - **NOT_FOUND**: execution_id doesn't exist
	// - **FAILED_PRECONDITION**: Execution already completed/failed (cannot cancel)
	//
	// Return success (Empty) for:
	// - Already-cancelled executions (idempotent)
	//
	// Example: "wex-01jbrxe9m7q8zn5v3c2k4g6w8t"
	ExecutionId string `protobuf:"bytes,1,opt,name=execution_id,json=executionId,proto3" json:"execution_id,omitempty"`
	// Human-readable reason for cancellation.
	//
	// This reason is recorded in audit logs and execution history.
	// It helps answer: "Why was this execution cancelled?"
	//
	// Common reasons:
	// - **User-initiated**: "User clicked cancel button in web console"
	// - **Timeout watchdog**: "Execution exceeded organization timeout policy"
	// - **Cost control**: "Execution cost exceeded budget threshold"
	// - **Deployment rollback**: "Cancelling in-progress deployment due to errors"
	// - **System maintenance**: "Draining runner for planned maintenance"
	//
	// ## Best Practices
	//
	// - Be specific (include who/what/why)
	// - Include context for debugging
	// - Avoid sensitive information
	//
	// Example: "User alice@acmecorp.com cancelled via web console"
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	// Force immediate termination without graceful cleanup.
	//
	// ## Graceful Cancellation (force=false, default)
	//
	// Runner should:
	// 1. Stop scheduling new tasks
	// 2. Wait for in-flight tasks to complete (with timeout)
	// 3. Clean up resources (close connections, delete temp files)
	// 4. Mark execution as cancelled
	//
	// Graceful timeout: 30 seconds (configurable per runner)
	//
	// ## Forced Cancellation (force=true)
	//
	// Runner should:
	// 1. Immediately terminate all tasks (SIGKILL)
	// 2. Skip cleanup (may leave incomplete work)
	// 3. Mark execution as cancelled
	//
	// ## When to Use Force
	//
	// - Stuck executions (graceful cancel hangs)
	// - Emergency situations (security incident, resource leak)
	// - Time-critical cancellations
	//
	// ## Trade-offs
	//
	// - **Graceful**: Safe, consistent state, slower
	// - **Forced**: Fast, may leave incomplete work, less safe
	//
	// Default: false (prefer graceful)
	//
	// Example: false (graceful cancellation)
	Force         bool `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CancelExecutionRequest) Reset() {
	*x = CancelExecutionRequest{}
	mi := &file_ai_stigmer_agentic_workflowrunner_v1_io_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CancelExecutionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CancelExecutionRequest) ProtoMessage() {}

func (x *CancelExecutionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ai_stigmer_agentic_workflowrunner_v1_io_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CancelExecutionRequest.ProtoReflect.Descriptor instead.
func (*CancelExecutionRequest) Descriptor() ([]byte, []int) {
	return file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDescGZIP(), []int{2}
}

func (x *CancelExecutionRequest) GetExecutionId() string {
	if x != nil {
		return x.ExecutionId
	}
	return ""
}

func (x *CancelExecutionRequest) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

func (x *CancelExecutionRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

// PauseExecutionRequest requests suspension of a running workflow execution.
//
// Pausing preserves execution state for later resumption. This is useful for:
// - Cost optimization (pause overnight, resume in morning)
// - Manual intervention (pause for human approval)
// - Dependency waiting (pause until external system available)
// - Debugging (pause to inspect state)
//
// ## Runner Capability
//
// Not all runners support pause/resume:
// - ✅ **Supported**: Temporal, Airflow, custom state-based runners
// - ❌ **Not supported**: Serverless functions, stateless runners
//
// Runners without pause support should return gRPC error: **UNIMPLEMENTED**
//
// ## State Checkpoint
//
// Runners MUST checkpoint execution state including:
// - Workflow input and output variables
// - Task completion status and results
// - Current execution position (next task to execute)
// - Execution metadata and timestamps
//
// Runners MAY release:
// - Worker processes/threads
// - Network connections
// - Temporary compute resources
//
// ## Idempotency
//
// Pausing an already-paused execution is a **no-op** (succeeds silently).
type PauseExecutionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Workflow execution ID to pause.
	//
	// Format: 'wex-{ulid}' (e.g., 'wex-01jbrxe9m7q8zn5v3c2k4g6w8t')
	//
	// ## Error Cases
	//
	// Return gRPC errors for:
	// - **NOT_FOUND**: execution_id doesn't exist
	// - **FAILED_PRECONDITION**: Execution not in running state (already paused, completed, or failed)
	// - **UNIMPLEMENTED**: Runner doesn't support pause/resume
	//
	// Return success (Empty) for:
	// - Already-paused executions (idempotent)
	//
	// Example: "wex-01jbrxe9m7q8zn5v3c2k4g6w8t"
	ExecutionId string `protobuf:"bytes,1,opt,name=execution_id,json=executionId,proto3" json:"execution_id,omitempty"`
	// Human-readable reason for pausing.
	//
	// This reason is recorded in audit logs and execution history.
	// It helps answer: "Why was this execution paused?"
	//
	// Common reasons:
	// - **Cost optimization**: "Pausing overnight to save compute costs"
	// - **Manual approval**: "Pausing for security team approval before production deployment"
	// - **Dependency wait**: "Pausing until database migration completes"
	// - **Debugging**: "Pausing to inspect intermediate state and logs"
	// - **Scheduled maintenance**: "Pausing before runner maintenance window"
	//
	// ## Best Practices
	//
	// - Be specific about pause reason
	// - Include expected resume condition if applicable
	// - Avoid sensitive information
	//
	// Examples:
	// - "Pausing overnight (8pm-8am) to reduce development costs"
	// - "Waiting for manual approval from security team before proceeding"
	Reason        string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PauseExecutionRequest) Reset() {
	*x = PauseExecutionRequest{}
	mi := &file_ai_stigmer_agentic_workflowrunner_v1_io_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PauseExecutionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PauseExecutionRequest) ProtoMessage() {}

func (x *PauseExecutionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ai_stigmer_agentic_workflowrunner_v1_io_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PauseExecutionRequest.ProtoReflect.Descriptor instead.
func (*PauseExecutionRequest) Descriptor() ([]byte, []int) {
	return file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDescGZIP(), []int{3}
}

func (x *PauseExecutionRequest) GetExecutionId() string {
	if x != nil {
		return x.ExecutionId
	}
	return ""
}

func (x *PauseExecutionRequest) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

// ResumeExecutionRequest requests continuation of a paused workflow execution.
//
// Resuming restores workflow state from checkpoint and continues execution
// from where it was paused.
//
// ## State Restoration
//
// Runners MUST restore:
// - All workflow variables and task state
// - Execution position (which task to execute next)
// - Original execution configuration (timeouts, resource limits)
// - Execution metadata and timestamps
//
// ## Execution Continuation
//
// After resume:
// 1. Execution picks up from the **next pending task**
// 2. Already-completed tasks are NOT re-executed
// 3. Timeouts continue from paused state (don't reset)
//
// ## Idempotency
//
// Resuming an already-running execution is a **no-op** (succeeds silently).
//
// ## Runner Capability
//
// Runners without pause/resume support should return: **UNIMPLEMENTED**
type ResumeExecutionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Workflow execution ID to resume.
	//
	// Format: 'wex-{ulid}' (e.g., 'wex-01jbrxe9m7q8zn5v3c2k4g6w8t')
	//
	// ## Error Cases
	//
	// Return gRPC errors for:
	// - **NOT_FOUND**: execution_id doesn't exist
	// - **FAILED_PRECONDITION**: Execution not in paused state (already running, completed, or failed)
	// - **UNIMPLEMENTED**: Runner doesn't support pause/resume
	//
	// Return success (Empty) for:
	// - Already-running executions (idempotent)
	//
	// Example: "wex-01jbrxe9m7q8zn5v3c2k4g6w8t"
	ExecutionId string `protobuf:"bytes,1,opt,name=execution_id,json=executionId,proto3" json:"execution_id,omitempty"`
	// Human-readable reason for resuming.
	//
	// This reason is recorded in audit logs and execution history.
	// It helps answer: "Why was this execution resumed?"
	//
	// Common reasons:
	// - **Scheduled resume**: "Resuming after overnight pause (8am)"
	// - **Approval granted**: "Security team approved production deployment, resuming"
	// - **Dependency ready**: "Database migration completed, resuming workflow"
	// - **Debugging complete**: "Inspection complete, resuming execution"
	// - **Maintenance complete**: "Runner maintenance finished, resuming workflows"
	//
	// ## Best Practices
	//
	// - Reference the original pause reason if applicable
	// - Include who/what triggered the resume
	// - Avoid sensitive information
	//
	// Examples:
	// - "Resuming after overnight pause (8am scheduled resume)"
	// - "Manual approval granted by security-team@acmecorp.com"
	Reason        string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResumeExecutionRequest) Reset() {
	*x = ResumeExecutionRequest{}
	mi := &file_ai_stigmer_agentic_workflowrunner_v1_io_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResumeExecutionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResumeExecutionRequest) ProtoMessage() {}

func (x *ResumeExecutionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ai_stigmer_agentic_workflowrunner_v1_io_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResumeExecutionRequest.ProtoReflect.Descriptor instead.
func (*ResumeExecutionRequest) Descriptor() ([]byte, []int) {
	return file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDescGZIP(), []int{4}
}

func (x *ResumeExecutionRequest) GetExecutionId() string {
	if x != nil {
		return x.ExecutionId
	}
	return ""
}

func (x *ResumeExecutionRequest) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

var File_ai_stigmer_agentic_workflowrunner_v1_io_proto protoreflect.FileDescriptor

const file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDesc = "" +
	"\n" +
	"-ai/stigmer/agentic/workflowrunner/v1/io.proto\x12$ai.stigmer.agentic.workflowrunner.v1\x1a\x1bbuf/validate/validate.proto\"w\n" +
	"\x14WorkflowExecuteInput\x12:\n" +
	"\x15workflow_execution_id\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x13workflowExecutionId\x12#\n" +
	"\rworkflow_yaml\x18\x02 \x01(\tR\fworkflowYaml\"\xf5\x01\n" +
	"\x17WorkflowExecuteResponse\x122\n" +
	"\x15workflow_execution_id\x18\x01 \x01(\tR\x13workflowExecutionId\x12\x16\n" +
	"\x06status\x18\x02 \x01(\tR\x06status\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\x120\n" +
	"\x14temporal_workflow_id\x18\x04 \x01(\tR\x12temporalWorkflowId\x12#\n" +
	"\rsubscribe_url\x18\x05 \x01(\tR\fsubscribeUrl\x12\x1d\n" +
	"\n" +
	"status_url\x18\x06 \x01(\tR\tstatusUrl\"q\n" +
	"\x16CancelExecutionRequest\x12)\n" +
	"\fexecution_id\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\vexecutionId\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\x12\x14\n" +
	"\x05force\x18\x03 \x01(\bR\x05force\"Z\n" +
	"\x15PauseExecutionRequest\x12)\n" +
	"\fexecution_id\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\vexecutionId\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\"[\n" +
	"\x16ResumeExecutionRequest\x12)\n" +
	"\fexecution_id\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\vexecutionId\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reasonB\xc7\x02\n" +
	"(com.ai.stigmer.agentic.workflowrunner.v1B\aIoProtoP\x01Z]github.com/stigmer/stigmer/internal/gen/ai/stigmer/agentic/workflowrunner/v1;workflowrunnerv1\xa2\x02\x04ASAW\xaa\x02$Ai.Stigmer.Agentic.Workflowrunner.V1\xca\x02$Ai\\Stigmer\\Agentic\\Workflowrunner\\V1\xe2\x020Ai\\Stigmer\\Agentic\\Workflowrunner\\V1\\GPBMetadata\xea\x02(Ai::Stigmer::Agentic::Workflowrunner::V1b\x06proto3"

var (
	file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDescOnce sync.Once
	file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDescData []byte
)

func file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDescGZIP() []byte {
	file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDescOnce.Do(func() {
		file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDesc), len(file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDesc)))
	})
	return file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDescData
}

var file_ai_stigmer_agentic_workflowrunner_v1_io_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_ai_stigmer_agentic_workflowrunner_v1_io_proto_goTypes = []any{
	(*WorkflowExecuteInput)(nil),    // 0: ai.stigmer.agentic.workflowrunner.v1.WorkflowExecuteInput
	(*WorkflowExecuteResponse)(nil), // 1: ai.stigmer.agentic.workflowrunner.v1.WorkflowExecuteResponse
	(*CancelExecutionRequest)(nil),  // 2: ai.stigmer.agentic.workflowrunner.v1.CancelExecutionRequest
	(*PauseExecutionRequest)(nil),   // 3: ai.stigmer.agentic.workflowrunner.v1.PauseExecutionRequest
	(*ResumeExecutionRequest)(nil),  // 4: ai.stigmer.agentic.workflowrunner.v1.ResumeExecutionRequest
}
var file_ai_stigmer_agentic_workflowrunner_v1_io_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_ai_stigmer_agentic_workflowrunner_v1_io_proto_init() }
func file_ai_stigmer_agentic_workflowrunner_v1_io_proto_init() {
	if File_ai_stigmer_agentic_workflowrunner_v1_io_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDesc), len(file_ai_stigmer_agentic_workflowrunner_v1_io_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_ai_stigmer_agentic_workflowrunner_v1_io_proto_goTypes,
		DependencyIndexes: file_ai_stigmer_agentic_workflowrunner_v1_io_proto_depIdxs,
		MessageInfos:      file_ai_stigmer_agentic_workflowrunner_v1_io_proto_msgTypes,
	}.Build()
	File_ai_stigmer_agentic_workflowrunner_v1_io_proto = out.File
	file_ai_stigmer_agentic_workflowrunner_v1_io_proto_goTypes = nil
	file_ai_stigmer_agentic_workflowrunner_v1_io_proto_depIdxs = nil
}
