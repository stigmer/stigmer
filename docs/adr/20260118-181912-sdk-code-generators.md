Here is the updated **ADR (Architectural Decision Record)** tailored specifically for **Go**.

I have removed all Python/Jinja2 references and replaced them with Go specific tooling (like `text/template` and Go struct patterns). You can save this file and pass it to Cursor.

---

# ADR 001: Automated Code Generation for Go SDK

**Date:** 2026-01-18
**Status:** Accepted
**Context:** Gas Orchestra Product Engineering

## 1. Context and Problem Statement

We are building "Gas Orchestra," an agent orchestration platform. We currently define our resource specifications (Agents, Workflows, Tasks) using **Protocol Buffers (Protos)**.

We are building our primary **Go SDK**.

* **The Problem:** We cannot ask users to use raw generated Proto structs in their application code. Raw Protos lack validation logic, helper methods, and the "Future/Promise" patterns required for defining dependencies between resources (e.g., passing an Agent ID to a Workflow).
* **The Scale Challenge:** While core resources are few, we have an "unlimited" number of **Task** types (Email, SQL, Scrape, etc.). Maintaining hand-written Go wrappers for 50+ task types is not scalable.

**We need a mechanism to automatically generate idiomatic, user-friendly Go structs and constructor functions that wrap our underlying Protos.**

## 2. Decision

We will build a **Custom Code Generator** specifically for our Go SDK.

1. **Source of Truth:** We will use our Proto definitions (or an intermediate metadata format derived from them).
2. **Generator Engine:** We will write a lightweight generator tool in Go (using `text/template`).
3. **Output:** The tool will generate idiomatic Go files containing typed structs, functional options/constructors, and validation logic.

## 3. Alternatives Considered

### Option A: Raw Proto Structs (Rejected)

* *Approach:* Users import the `pb` package directly.
* *Pros:* No extra work.
* *Cons:* Poor DX. Users have to deal with pointers for optional fields (`&s`), cannot validate inputs easily, and cannot implement the "Input" pattern for resolving dependencies.

### Option B: Hand-Written Go Wrappers (Rejected)

* *Approach:* Manually write `type EmailTask struct { ... }` for every task.
* *Pros:* Full control.
* *Cons:* High maintenance. Adding a field to a Proto requires manual updates to the SDK. High risk of inconsistencies across different Task types.

## 4. Detailed Design

### A. The "Input" (Dependencies)

The generator will depend on the existing `_pb.go` files generated by `protoc`. It may also read a simple config file (JSON/YAML) that defines which fields need validation (e.g., `regex` patterns).

### B. The Generator Tool (`tools/codegen`)

We will create a standalone Go program that:

1. Reads the Task definitions.
2. Uses Go's standard `text/template` package.
3. Loops through tasks to generate file `sdk/tasks.go` (or individual files).

### C. The Output Code Pattern

The generator will produce Go code that looks like this:

```go
// Code generated by gas-orchestra-codegen. DO NOT EDIT.

package sdk

import (
    pb "github.com/org/repo/proto"
    "errors"
)

// EmailTask is the user-facing struct.
// It hides the complexity of the underlying Proto.
type EmailTask struct {
    To      Input[string] // wrapper to handle raw strings or futures
    Subject Input[string]
}

// NewEmailTask is the constructor with validation.
func NewEmailTask(to string, subject string) *EmailTask {
    // 1. Validation Logic
    if to == "" {
        panic("to address is required")
    }

    return &EmailTask{
        To:      StringInput(to),
        Subject: StringInput(subject),
    }
}

// ToProto converts the SDK model to the raw wire format.
func (t *EmailTask) ToProto() *pb.TaskSpec {
    return &pb.TaskSpec{
        Kind: "EMAIL",
        Config: &pb.TaskConfig{
            Recipient: t.To.Value(), 
            Subject:   t.Subject.Value(),
        },
    }
}

```

## 5. Consequences

* **Positive:** We ensure all Go Tasks have consistent constructors and validation. We can add "Input/Output" logic to all resources instantly by updating the template.
* **Negative:** We must maintain the generator template.

---

### ðŸš€ Instructions for Cursor

**Copy the text below and paste it into Cursor:**

> "I am working on the Go SDK for my product, Gas Orchestra. I have defined an ADR (Architectural Decision Record) for building a code generator to automate the creation of our Go structs.
> Please read the ADR above carefully.
> **Your Task:**
> I need you to set up the scaffolding for this generator.
> 1. Create a folder `tools/codegen`.
> 2. Inside it, create a `main.go` that uses the `text/template` package.
> 3. Create a template file `task.tmpl` that generates a Go struct and a `ToProto` method.
> 4. Define a dummy Go struct (inside main.go) to represent the 'Metadata' of a Task (Name, Fields, Types) and pass it to the template to generate a sample file.
> 
> 
> Focus ONLY on Go. Do not use Python or any other language."