# Build System Architecture

## Overview

Stigmer uses **Go toolchain + Make** as the canonical build system for all production builds, releases, and CI/CD pipelines.

## Build Systems

### Primary: Go + Make

All production builds use the Go toolchain orchestrated through Make:

| Command | Purpose |
|---------|---------|
| `make build` | Build the Stigmer CLI |
| `make build-backend` | Build backend services |
| `make test` | Run unit tests |
| `make lint` | Run linters |
| `make protos` | Generate protocol buffer stubs |
| `make release-local` | Build and install CLI locally |

### Auxiliary: Bazel

Bazel configuration exists but is **not used for production releases**:

- `MODULE.bazel` - Dependency management
- `BUILD.bazel` files - Generated by Gazelle
- `.bazelrc` - Build configuration

**Why Bazel exists but isn't primary:**

1. **Proto stub generation** - Gazelle helps maintain BUILD files
2. **Future migration path** - If codebase grows significantly
3. **Local development convenience** - Some developers prefer Bazel

**Why Go + Make for releases:**

1. **Simpler CI configuration** - No Bazel cache infrastructure needed
2. **Faster builds** - Go's built-in caching is sufficient for current codebase size
3. **Wider tooling support** - More developers familiar with Make
4. **GitHub Actions compatibility** - Native Go support without Bazel setup

## CI/CD Pipeline

### Release Workflow

The release process is defined in `.github/workflows/release-embedded.yml`:

```
Tag Push (v*) → Build Matrix → GitHub Release → Homebrew Tap Update
                    │
                    ├── darwin-arm64 (macOS Apple Silicon)
                    ├── darwin-amd64 (macOS Intel)
                    ├── linux-amd64 (Linux)
                    └── Docker Image (agent-runner)
```

### Build Matrix

| Platform | Runner | Output |
|----------|--------|--------|
| darwin-arm64 | macos-latest | `stigmer-{version}-darwin-arm64.tar.gz` |
| darwin-amd64 | macos-latest (cross-compile) | `stigmer-{version}-darwin-amd64.tar.gz` |
| linux-amd64 | ubuntu-latest | `stigmer-{version}-linux-amd64.tar.gz` |

### Docker Images

Published to GitHub Container Registry (ghcr.io):

- `ghcr.io/stigmer/agent-runner:{version}` - Agent runner service
- `ghcr.io/stigmer/agent-sandbox-basic:{version}` - Sandbox environment

## Go Version Policy

**Standard Version: Go 1.25.x**

All configuration files must use the same Go version:

| File | Format |
|------|--------|
| `go.work` | `go 1.25.6` |
| `go.mod` files | `go 1.25.6` |
| `MODULE.bazel` | `version = "1.25.6"` |
| CI workflows | `go-version: '1.25'` (uses latest patch) |

**Why consistent versioning matters:**

1. **Reproducible builds** - Same behavior locally and in CI
2. **Language features** - Avoid using features unavailable in CI
3. **Dependency resolution** - `go.mod` version affects module graph

## Module Structure

Stigmer uses Go workspaces to manage multiple modules:

```
stigmer/
├── go.work                          # Workspace coordinator
├── apis/stubs/go/go.mod            # Proto stubs
├── backend/
│   ├── libs/go/go.mod              # Shared libraries
│   └── services/
│       ├── stigmer-server/go.mod   # Main server
│       └── workflow-runner/go.mod  # Workflow service
├── client-apps/cli/go.mod          # CLI
├── sdk/go/go.mod                   # Go SDK
├── test/e2e/go.mod                 # E2E tests
└── tools/go.mod                    # Build tools
```

See [go-module-structure.md](go-module-structure.md) for details.

## Local Development

### Quick Start

```bash
# Build CLI
make build

# Build and install locally
make release-local

# Run in development mode
make dev
```

### Full Development Environment

```bash
# Build everything (CLI + Docker images)
make dev-full
```

### Running Tests

```bash
# Unit tests only
make test

# E2E tests (requires infrastructure)
make test-e2e

# All tests
make test-all
```

## Adding New Services

1. Create Go module in appropriate directory
2. Add to `go.work`
3. Add build target to `Makefile`
4. Update CI workflow if release artifact needed

## Design Decisions

### Why No GoReleaser?

GoReleaser was evaluated but not adopted because:

1. **Custom requirements** - BusyBox pattern (server embedded in CLI) requires custom build logic
2. **Docker integration** - Multi-arch Docker builds need specific handling
3. **Homebrew tap** - Custom formula generation for multiple binaries
4. **Simplicity** - Direct Go builds in CI are easier to debug

### Why Go Workspaces?

1. **Module isolation** - Each service has explicit dependencies
2. **Independent versioning** - Modules can be published separately if needed
3. **IDE support** - Better code navigation and refactoring
4. **Planton alignment** - Consistent with Planton Cloud patterns

## References

- [Go Module Structure](go-module-structure.md)
- [SDK Code Generation](sdk-code-generation.md)
- [Go Workspaces Documentation](https://go.dev/blog/get-familiar-with-workspaces)
